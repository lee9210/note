### 基本概念 ###
1. 操作系统中 heap 和 stack 的区别
1.Java中对象都是分配在heap(堆)中。从heap中分配内存所消耗的时间远远大于从stack产生存储空间所需的时间。
 
(1)每个应用程序运行时，都有属于自己的一段内存空间，用于存放临时变量、参数传递、函数调用时的PC值的保存。这叫stack。 
(2)所有的应用可以从一个系统共用的空间中申请供自己使用的内存，这个共用的空间叫heap。 
(3)stack中的对象或变量只要定义好就可使用了，应用程序结束时会自动释放。 
(4)而要使用heap中申请的变量或对象只能定义变量指针，并要求在运行过程中通过new来动态分配内存空间，而且必须显示地free你申请过的内存，不过Java的垃圾回收机解决了这个问题，它会帮你释放这部分内存。 
(5)stack中变量的大小和个数会影响exe的文件大小，但速度快。堆中的变量大小与exe大小关系不大，但分配和释放需要耗费的时间远大于stack中分配内存所需的时间。 

2.在Java语言里堆(heap)和栈(stack)里的区别 

     1). 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 

　　2). 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 

　　3). Java中的数据类型有两种。 
　　一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。 
　　另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义 

　　int a = 3; 
　　int b = 3； 

　　编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 
　　特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 
　　另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 

 4).每个JVM的线程都有自己的私有的栈空间，随线程创建而创建，java的stack存放的是frames ，java的stack和c的不同，只是存放本地变量，返回值和调用方法，不允许直接push和pop frames ，因为frames 可能是有heap分配的，所以java的stack分配的内存不需要是连续的。java的heap是所有线程共享的，堆存放所有 runtime data ，里面是所有的对象实例和数组，heap是JVM启动时创建。 

　　5). String是一个特殊的包装类数据。即可以用String str = new String("abc");的形式来创建，也可以用String str = "abc"；的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java 中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = "abc"；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。 

　　5.1). 关于String str = "abc"的内部工作。Java内部将此语句转化为以下几个步骤： 
　　(1)先定义一个名为str的对String类的对象引用变量：String str； 
　　(2)在栈中查找有没有存放值为"abc"的地址，如果没有，则开辟一个存放字面值为"abc"的地址，接着创建一个新的String类的对象o，并将o 的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。 
　　(3)将str指向对象o的地址。 
　　值得注意的是，一般String类中字符串值都是直接存值的。但像String str = "abc"；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！ 
为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。 

　　String str1 = "abc"; 
　　String str2 = "abc"; 
　　System.out.println(str1==str2);   //true 
  
　　注意，我们这里并不用str1.equals(str2)；的方式，因为这将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。 
　　结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。 

　　我们再来更进一步，将以上代码改成： 

　　String str1 = "abc"; 
　　String str2 = "abc"; 
　　str1 = "bcd"; 
　　System.out.println(str1 + "," + str2);   //bcd, abc 
　　System.out.println(str1==str2);   //false 

　　这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为"bcd"时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。 
　　事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。 

　　再修改原来代码： 

　　String str1 = "abc"; 
　　String str2 = "abc"; 
  
　　str1 = "bcd"; 
  
　　String str3 = str1; 
　　System.out.println(str3);   //bcd 

　　String str4 = "bcd"; 
　　System.out.println(str1 == str4);   //true 
    
　　str3 这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其值后，再创建一个String的引用str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。 

　　我们再接着看以下的代码。 

　　String str1 = new String("abc"); 
　　String str2 = "abc"; 
　　System.out.println(str1==str2);   //false 

　　创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 

　　String str1 = "abc"; 
　　String str2 = new String("abc"); 
　　System.out.println(str1==str2);   //false 

　　创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 

　　以上两段代码说明，只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。 

　　6). 数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。 

　　7). 结论与建议： 

　　(1)我们在使用诸如String str = "abc"；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向 String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为"abc"的String类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。 

　　(2)使用String str = "abc"；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String("abc")；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。 

　　(3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。 

　　(4)由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。 
如果java不能成功分配heap的空间，将抛出OutOfMemoryError.



#### 什么是基于注解的切面实现 ####
(使用非侵入式来操作程序，类似于权限控制，log记录等)
http://blog.csdn.net/program_guys/article/details/78724090

#### 什么是 对象/关系 映射集成模块 ####
对象的抽象是类，类的具象是对象。
对象关系映射（Object Relational Mapping，简称ORM）是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。


#### 什么是 Java 的反射机制 ####
动态的操作类
http://blog.csdn.net/caide3/article/details/52402764

#### 什么是 ACID ####
ACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。
##### 原子性 #####
整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

##### 一致性 #####
一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。
也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性

##### 隔离性 #####
隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。	

##### 持久性 #####
在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，要正确实现ACID并不容易。ACID建议数据库将所有需要更新以及修改的资料一次操作完毕，但实际上并不可行。
目前主要有两种方式实现ACID：第一种是Write ahead logging，也就是日志式的方式(现代数据库均基于这种方式)。第二种是Shadow paging。
相对于WAL（write ahead logging）技术，shadow paging技术实现起来比较简单，消除了写日志记录的开销恢复的速度也快(不需要redo和undo)。shadow paging的缺点就是事务提交时要输出多个块，这使得提交的开销很大，而且以块为单位，很难应用到允许多个事务并发执行的情况——这是它致命的缺点。
WAL 的中心思想是对数据文件 的修改（它们是表和索引的载体）必须是只能发生在这些修改已经 记录了日志之后 -- 也就是说，在日志记录冲刷到永久存储器之后． 如果我们遵循这个过程，那么我们就不需要在每次事务提交的时候 都把数据页冲刷到磁盘，因为我们知道在出现崩溃的情况下， 我们可以用日志来恢复数据库：任何尚未附加到数据页的记录 都将先从日志记录中重做（这叫向前滚动恢复，也叫做 REDO） 然后那些未提交的事务做的修改将被从数据页中删除 （这叫向后滚动恢复 - UNDO）。

#### BS与CS的联系与区别 ####
C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。 
B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。 

http://blog.csdn.net/hengbao4/article/details/52505427

#### Cookie 和 Session的区别 ####
http://blog.csdn.net/axin66ok/article/details/6175522

#### fail-fast 与 fail-safe 机制有什么区别 ####
什么是同步修改？
当一个或多个线程正在遍历一个集合Collection，此时另一个线程修改了这个集合的内容（添加，删除或者修改）。这就是并发修改
什么是 fail-fast 机制?
fail-fast机制在遍历一个集合时，当集合结构被修改，会抛出Concurrent Modification Exception。
fail-fast会在以下两种情况下抛出ConcurrentModificationException
（1）单线程环境
集合被创建后，在遍历它的过程中修改了结构。
注意 remove()方法会让expectModcount和modcount 相等，所以是不会抛出这个异常。
（2）多线程环境
当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。
**注意：**迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。
 fail-fast机制是如何检测的？
迭代器在遍历过程中是直接访问内部数据的，因此内部的数据在遍历的过程中无法被修改。为了保证不被修改，迭代器内部维护了一个标记 “mode” ，当集合结构改变（添加删除或者修改），标记"mode"会被修改，而迭代器每次的hasNext()和next()方法都会检查该"mode"是否被改变，当检测到被修改时，抛出Concurrent Modification Exception

fail-safe机制
fail-safe任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException
fail-safe机制有两个问题
（1）需要复制集合，产生大量的无效对象，开销大
（2）无法保证读取的数据是目前原始数据结构中的数据。

fail-safe例子
````
public static void main(String[] args){
    ConcurrentHashMap<String,String> premiumPhone = new ConcurrentHashMap<String,String>();
    premiumPhone.put("Apple", "iPhone");
    premiumPhone.put("HTC", "HTC one");
    premiumPhone.put("Samsung","S5");
    Iterator iterator = premiumPhone.keySet().iterator();
    while (iterator.hasNext()){
        System.out.println(premiumPhone.get(iterator.next()));
        premiumPhone.put("Sony", "Xperia Z");
    }
}
````
运行结果：
````
iPhone
HTC one
S5
````
fail-fast例子
````
public static void main(String[] args){
    Map<String,String> premiumPhone = new HashMap<String,String>();
    premiumPhone.put("Apple", "iPhone");
    premiumPhone.put("HTC", "HTC one");
    premiumPhone.put("Samsung","S5");
    Iterator iterator = premiumPhone.keySet().iterator();
    while (iterator.hasNext()){
        System.out.println(premiumPhone.get(iterator.next()));
        premiumPhone.put("Sony", "Xperia Z");
    }
}
````
运行结果：
````
iPhone
Exception in thread "main" java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1437)
	at java.util.HashMap$KeyIterator.next(HashMap.java:1461)
	at com.test.FailFast.main(FailFast.java:15)
````
ConcurrentHashMap实现了线程安全，所以不会抛出ConcurrentModificationException的异常。
https://www.cnblogs.com/dolphin0520/p/3932905.html

#### get 和 post请求的区别 ####
##### get请求 #####
根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。
1. 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
2. 幂等的意味着对同一URL的多个请求应该返回同样的结果。
注意：这里安全的含义仅仅是指是非修改信息。
##### post请求 #####
根据HTTP规范，POST表示可能修改变服务器上的资源的请求。
#### 表象上get和post的区别 ####
1. GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&相连，如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。POST把提交的数据则放置在是HTTP包的包体中。
2. get请求：URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。
3. post请求：POST是没有大小限制的，HTTP协议规范也没有进行大小限制
4. 在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\"XXXX\")来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&password=hyddd，用request.getQueryString()得到的是：name=hyddd&password=hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据
5. POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。

#### Interface 与 abstract 类的区别 ####
抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。

对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。
1. 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。

2. 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。

3. 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。 


##### 总结 #####
1. 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。
2. 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。
3. 抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。


#### IOC的优点是什么 ####
IoC优点：不用手动生成对象，把对象的生成和注入交给容器解决。
IoC最大的缺点是：
1. 生成一个对象的步骤变复杂了（其实上操作上还是挺简单的），对于不习惯这种方式的人，会觉得有些别扭和不直观。 
2. 对象 生成因为是使用反射编程，在效率上有些损耗。但相对于IoC提高的维护性和灵活性来说，这点损耗是微不足道的，除非某对象的生成对效率要求特别高。 
3. 缺少IDE重构操作的支持，如果在Eclipse要对类改名，那么你还需要去XML文件里手工去改了，这似乎是所有XML方式的缺憾所在。


#### IO 和 NIO的区别，NIO优点 ####
NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同，NIO主要用到的是块，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。

|IO|NIO|
|-|-|
|面向流|面向缓冲|
|阻塞IO|非阻塞IO|
|无|选择器|

1. 面向流与面向缓冲
Java IO和NIO之间第一个最大的区别是，**IO是面向流的，NIO是面向缓冲区的**。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。
2. 阻塞与非阻塞IO
 **IO的各种流是阻塞的**。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。**NIO的非阻塞模式**，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。
3. 选择器（Selectors）
Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。

https://www.cnblogs.com/xiaoxi/p/6576588.html

13. Java 8 / Java 7 为我们提供了什么新功能

#### 什么是竞态条件？ 举个例子说明。 ####
竞态条件是由和事件时间相关的意料之外的依赖所导致的反常行为。换句话说，一个程序员不正确的假设一个特殊的事件总是在另一个事件之前发生。
http://blog.csdn.net/Clifnich/article/details/78447524

#### JRE、JDK、JVM 及 JIT 之间有什么不同 ####
**java虚拟机(JVM)**
使用java编程语言的主要优势就是平台的独立性。你曾经想知道过java怎么实现平台的独立性吗？对，就是虚拟机，它抽象化了硬件设备，开发者和他们的程序的得以操作系统。虚拟机的职责就是处理和操作系统的交流。java不同的接口规范对任何平台都有良好的支持，因为jvm很好的实现了每个平台的规范。jvm可以理解伪代码字节码，在用户和操作系统之间建立了一层枢纽。
 
**java运行时环境(JRE)**
java运行时环境是JVM的一个超集。JVM对于一个平台或者操作系统是明确的，而JRE确实一个一般的概念，他代表了完整的运行时环境。我们在jre文件夹中看到的所有的jar文件和可执行文件都会变成运行时的一部分。事实上，运行时JRE变成了JVM。所以对于一般情况时候使用JRE，对于明确的操作系统来说使用JVM。当你下载了JRE的时候，也就自动下载了JVM。
 
**java开发工具箱(JDK)**
java开发工具箱指的是编写一个java应用所需要的所有jar文件和可执行文件。事实上，JRE是JKD的一部分。如果你下载了JDK,你会看到一个名叫JRE的文件夹在里面。JDK中要被牢记的jar文件就是tools.jar,它包含了用于执行java文档的类还有用于类签名的jar包。
 
**即时编译器(JIT)**
即时编译器是种特殊的编译器，它通过有效的把字节码变成机器码来提高JVM的效率。JIT这种功效很特殊，因为他把检测到的相似的字节码编译成单一运行的机器码，从而节省了CPU的使用。这和其他的字节码编译器不同，因为他是运行时(第一类执行的编译？)the firs of its kind to perform the compilation(从字节码到机器码）而不是在程序运行之前。正是因为这些，动态编译这个词汇才和JIT有那么紧密的关系。

#### MVC的各个部分都有那些技术来实现?如何实现? ####
MVC 是 Model－View－Controller 的简写

M(DAO)层,就相当于后台，
V(jsp),相当于前台，
C(control)层，相当于控制页面跳转；
MVC模式的目的就是实现Web系统的职能分工。
Model层实现系统中的业务逻辑，通常可以用JavaBean或EJB来实现。
View层用于与用户的交互，通常用JSP来实现。
Controller层是Model与View之间沟通的桥梁，它可以分派用户的请求并选择恰当的视图以用于显示，同时它也可以解释用户的输入并将它们映射为模型层可执行的操作。

M：hibernate、mybatis、ibatis
C：severlet、struts、spring、action
V：jsp、FreeMarker、tails、taglib、EL、Velocity	

#### RPC 通信和 RMI 区别 ####
远程过程调用被设计为在应用程序间通信的平台中立的方式，它不理会操作系统之间以及语言之间的差异。即 RPC 支持多种语言，而 RMI(Remote Method Invocation)只支持 Java 写的应用程序。
另外 RMI 调用远程对象方法，允许方法返回 Java 对象以及基本数据类型。而 RPC 不支持对象的概念，传送到 RPC 服务的消息由外部数据表示 (External Data Representation, XDR) 语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由 XDR 定义的数据类型才能被传递， RPC 不允许传递对象。可以说 RMI 是面向对象方式的 Java RPC 。
RMI和RPC之间最主要的区别在于方法是如何被调用的。在RMI中，远程接口使每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口上，那么这个新方法就不能被RMI客户方所调用。
在RPC中，当一个请求到达RPC服务器时，这个请求就包含了一个参数集和一个文本值，通常形成“classname.methodname”的形式。这就向RPC服务器表明，被请求的方法在为“classname”的类中，名叫“methodname”。然后RPC服务器就去搜索与之相匹配的类和方法，并把它作为那种方法参数类型的输入。这里的参数类型是与RPC请求中的类型是匹配的。一旦匹配成功，这个方法就被调用了，其结果被编码后返回客户方。

#### 什么是 Web Service（Web服务） ####
WebService是一种跨编程语言和跨操作系统平台的远程调用技术。
所谓跨编程语言和跨操作平台，就是说服务端程序采用java编写，客户端程序则可以采用其他编程语言编写，反之亦然！跨操作系统平台则是指服务端程序和客户端程序可以在不同的操作系统上运行。
XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。
WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。
XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，64位？这些细节对实现互操作性很重要。XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。
WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。
SOAP协议 = HTTP协议 + XML数据格式
SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。打个比喻：HTTP就是普通公路，XML就是中间的绿色隔离带和两边的防护栏，SOAP就是普通公路经过加隔离带和防护栏改造过的高速公路。
SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。

WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。

WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。

WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。

https://www.cnblogs.com/hsq0622/p/5604743.html


19. JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。


#### WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。 ####
Web容器给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接跟容器中的环境变量交互，不必关注其它系统问题
小型的Tomcat，大型的WebLogic、WebService。Web容器简单的说就是提供Web应用运行的环境，协调控制外界访问Web资源及服务的程序。

#### 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制 ####

这个是可以的，一个“.java”源文件里面可以包含多个类，但是只允许有一个public类，并且类名必须和文件名一致。

每个编译单元只能有一个public 类。这么做的意思是，每个编译单元只能有一个公开的接口，而这个接口就由其public 类来表示。
你可以根据需要，往这个文件里面添加任意多个提供辅助功能的package 权限的类。但是如果这个编译单元里面有两个或两个以上的public 类的话，程序就不知道从哪里导入了，编译器就会报错。

22. 简单说说你了解的类加载器。是否实现过类加载器
#### 解释一下什么叫AOP（面向切面编程） ####
在运行时，动态地将代码切入到类的指定方法、 指定位置上的编程思想就是面向切面的编程。
一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。
这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。

24. 请简述 Servlet 的生命周期及其相关的方法
25. 请简述一下 Ajax 的原理及实现步骤
26. 简单描述Struts的主要功能
27. 什么是 N 层架构
28. 什么是CORBA？用途是什么
29. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”
30. 什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配
31. 什么是懒加载（Lazy Loading）
32. 什么是尾递归，为什么需要尾递归
33. 什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）

### 关键字 ###

#### finalize ####
http://blog.csdn.net/x_i_y_u_e/article/details/51377417
#### 什么是finalize()方法 ####
finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。 
特殊情况下，需要程序员实现finalize，当对象被回收的时候释放一些资源，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。 
使用finalize还需要注意一个事，调用super.finalize();

#### finalize()方法什么时候被调用 ####
唯一的原因只能是gc并没有执行，gc只有在JVM内存不足的时候才会自动执行。
http://blog.csdn.net/before_morning/article/details/48311167

3. 析构函数(finalization)的目的是什么
4. final 和 finalize 的区别
5. final
6. final关键字有哪些用法
7. final 与 static 关键字可以用于哪里？它们的作用是什么
8. final, finally, finalize的区别
9. final、finalize 和 finally 的不同之处？
10. 能否在运行时向 static final 类型的赋值
11. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变
12. 一个类被声明为final类型，表示了什么意思
13. throws, throw, try, catch, finally分别代表什么意义
14. Java 有几种修饰符？分别用来修饰什么

#### volatile ####
1. volatile 修饰符的有过什么实践
2. volatile 变量是什么？volatile 变量和 atomic 变量有什么不同
3. volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗
4. 能创建 volatile 数组吗？

####  ####
1. transient变量有什么特点
2. super什么时候使用
3. public static void 写成 static public void会怎样
4. 说明一下public static void main(String args[])这段声明里每个关键字的作用
5. 请说出作用域public, private, protected, 以及不写时的区别
6. sizeof 是Java 的关键字吗
#### static ####

#### static class 与 non static class的区别 ####
##### static class #####
1. 用static修饰的是内部类，此时这个内部类变为静态内部类；对测试有用；
2. 内部静态类不需要有指向外部类的引用；
3. 静态类只能访问外部类的静态成员，不能访问外部类的非静态成员；
##### not static class #####
1. 非静态内部类需要持有对外部类的引用；
2. 非静态内部类能够访问外部类的静态和非静态成员；
3. 一个非静态内部类不能脱离外部类实体被创建；
4. 一个非静态内部类可以访问外部类的数据和方法；


2. static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法
3. 静态类型有什么特点
4. main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态
5. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用
6. 静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢
7. 成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量

#### switch ####

1. switch 语句中的表达式可以是什么类型数据
2. switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上
3. while 循环和 do 循环有什么不同

#### 操作符 ####
1. &操作符和&&操作符有什么区别?
#### a = a + b 与 a += b 的区别？ ####
需要明确的是“+=”这个运算符在Java中是一个运算符，而不是两个，程序在执行“+=”时，会自动向高精度进行数据类型转换
a=a+b的形式时出现了问题，因为a是short类型的变量，而5默认为int类型的变量，short类型+int类型结果肯定会自动转换成int类型啦，
这两种形式的主要区别在于是否进行数据类型的自动转换，当两个操作数同类型时这两种形式的运算结果是没有差别的，当两个操作数数据类型不同时，且左操作数即保存结果的操作数的数据精度要低，此时这两种形式才有区别。

#### 逻辑操作符 (&,|,^)与条件操作符(&&,||)的区别 ####
逻辑运算符&与&&的区别是：
& 无论左边结果是什么，右边还是继续运算；
&&当左边为假，右边不再进行运算。

#### 3*0.1 == 0.3 将会返回什么？true 还是 false？ ####
false，因为3*0.1运算过程中自动类型提升了

5. float f=3.4; 是否正确？
6. short s1 = 1; s1 = s1 + 1;有什么错?

### 数据结构 ###

#### 基础类型(Primitives) ####
1. 基础类型(Primitives)与封装类型(Wrappers)的区别在哪里
2. 简述九种基本数据类型的大小，以及他们的封装类
3. int 和 Integer 哪个会占用更多的内存？ int 和 Integer 有什么区别？parseInt()函数在什么时候使用到
4. float和double的默认值是多少
5. 如何去小数四舍五入保留小数点后两位
6. char 型变量中能不能存贮一个中文汉字，为什么

#### 类型转换 ####
1. 怎样将 bytes 转换为 long 类型
2. 怎么将 byte 转换为 String
3. 如何将数值型字符转换为数字
4. 我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象
5. 能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗
6. 类型向下转换是什么

#### 数组 ####
#### 如何权衡是使用无序的数组还是有序的数组 ####
有序数组最大的好处在于查找的时间复杂度是O(logn)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。

#### 怎么判断数组是 null 还是为空 ####
if (news != null && news.length == 0) {}

#### 怎么打印数组？ 怎样打印数组中的重复元素 ####
输出数组
````
 Arrays.toString(arr)  
  
for(int n: arr)   
   System.out.println(n+", ");  
  
for (int i = 0; i < arr.length; i++) {  
   System.out.print(arr[i] + ", ");  
}  
  
System.out.println(Arrays.asList(arr));  
  
Arrays.asList(arr).stream().forEach(s -> System.out.println(s));//java8  
````
#### Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList ####
1. Array 和 ArrayList有什么区别
可以将 ArrayList想象成一种“会自动扩增容量的Array”。
ArrayList可以算是Array的加强版，（对array有所取舍的加强）。

存储内容比较： 
Array数组可以包含基本类型和对象类型，
ArrayList却只能包含对象类型。
但是需要注意的是：Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。

空间大小比较： 
它的空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小。
ArrayList的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。（比较麻烦的地方）。

方法上的比较： 
ArrayList作为Array的增强版，当然是在方法上比Array更多样化，比如添加全部addAll()、删除全部removeAll()、返回迭代器iterator()等。

适用场景： 
如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。而且还有一个地方是必须知道的，就是如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。

5. 数组和链表数据结构描述，各自的时间复杂度
6. 数组有没有length()这个方法? String有没有length()这个方法

#### 队列 ####
1. 队列和栈是什么，列出它们的区别
2. BlockingQueue是什么
3. 简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。
4. ArrayList、Vector、LinkedList的存储性能和特性


#### String StringBuffer ####

1. ByteBuffer 与 StringBuffer有什么区别

#### HashMap ####
1. HashMap的工作原理是什么
2. 内部的数据结构是什么
3. HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？
4. HashMap 实现的数据结构是什么？如何实现
5. HashMap 和 HashTable、ConcurrentHashMap 的区别
6. HashMap的遍历方式及效率
7. HashMap、LinkedMap、TreeMap的区别
8. 如何决定选用HashMap还是TreeMap
9. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办
10. HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等

#### HashSet ####

1. HashSet和TreeSet有什么区别
2. HashSet 内部是如何工作的
3. WeakHashMap 是怎么工作的？

#### Set ####

1. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？ 它们有何区别?
2. TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。
3. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？
4. TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。
5. EnumSet 是什么

#### Hash算法 ####
1. Hashcode 的作用
2. 简述一致性 Hash 算法
3. 有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象
4. 为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里
5. a.hashCode() 有什么用？与 a.equals(b) 有什么关系
6. hashCode() 和 equals() 方法的重要性体现在什么地方
7. Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述
8. 如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。
9. 可以在 hashcode() 中使用随机数字吗？

#### LinkedHashMap ####
LinkedHashMap 和 PriorityQueue 的区别是什么

#### List ####
1. List, Set, Map三个接口，存取元素时各有什么特点
2. List, Set, Map 是否继承自 Collection 接口
3. 遍历一个 List 有哪些不同的方式

#### LinkedList ####

1. LinkedList 是单向链表还是双向链表
2. LinkedList 与 ArrayList 有什么区别
3. 描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。LinkedList 与 ArrayList 的区别是什么？
4. 插入数据时，ArrayList, LinkedList, Vector谁速度较快？

#### ArrayList ####

1. ArrayList 和 HashMap 的默认大小是多数
2. ArrayList 和 LinkedList 的区别，什么时候用 ArrayList？
3. ArrayList 和 Set 的区别？
4. ArrayList, LinkedList, Vector的区别
5. ArrayList是如何实现的，ArrayList 和 LinkedList 的区别
6. ArrayList如何实现扩容
7. Array 和 ArrayList 有何区别？什么时候更适合用Array
8. 说出ArraList,Vector, LinkedList的存储性能和特性

#### Map ####
1. Map, Set, List, Queue, Stack
2. Map 接口提供了哪些不同的集合视图
3. 为什么 Map 接口不继承 Collection 接口

#### Collections ####
1. 介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些
2. Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现
3. 集合类框架的最佳实践有哪些
4. 为什么 Collection 不从 Cloneable 和 Serializable 接口继承
5. 说出几点 Java 中使用 Collections 的最佳实践？
6. Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别

什么是 B+树，B-树，列出实际的使用场景。

#### 接口 ####
Comparator 与 Comparable 接口是干什么的？列出它们的区别

### 对象 ###
#### 拷贝(clone) ####
1. 如何实现对象克隆
2. 深拷贝和浅拷贝区别
3. 深拷贝和浅拷贝如何实现激活机制
4. 写clone()方法时，通常都有一行代码，是什么

#### 比较 ####
1. 在比较对象时，”==” 运算符和 equals 运算有何区别
2. 如果要重写一个对象的equals方法，还要考虑什么
3. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对
#### 构造器 ####
1. 构造器链是什么
2. 创建对象时构造器的调用顺序

#### 不可变对象 ####
1. 什么是不可变象（immutable object）
2. 为什么 Java 中的 String 是不可变的（Immutable）
3. 如何构建不可变的类结构？关键点在哪里
4. 能创建一个包含可变对象的不可变对象吗


如何对一组对象进行排序

#### 方法 ####
1. 构造器（constructor）是否可被重写（override）
2. 方法可以同时即是 static 又是 synchronized 的吗
3. abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized
4. Java支持哪种参数传递类型
5. 
5. 一个对象被当作参数传递到一个方法，是值传递还是引用传递当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递
6. 我们能否重载main()方法
7. 如果main方法被声明为private会怎样

### GC ###
#### 概念 ####
1. GC是什么？为什么要有GC
2. 什么时候会导致垃圾回收
3. GC是怎么样运行的
4. 新老以及永久区是什么
5. GC 有几种方式？怎么配置
6. 什么时候一个对象会被GC？ 如何判断一个对象是否存活
7. System.gc() Runtime.gc()会做什么事情？ 能保证 GC 执行吗
8. 垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
9. Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生
10. 垃圾回收算法的实现原理
11. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
12. 垃圾回收的最佳做法是什么


#### GC收集器有哪些 ####
1. 垃圾回收器的基本原理是什么？
2. 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么
3. Serial 与 Parallel GC之间的不同之处
4. CMS 收集器 与 G1 收集器的特点与区别
5. CMS垃圾回收器的工作过程
6. JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代
7. 吞吐量优先和响应优先的垃圾收集器选择

#### GC策略 ####
1. 举个实际的场景，选择一个GC策略
2. JVM的永久代中会发生垃圾回收吗

#### 收集方法 ####

1. 标记清除、标记整理、复制算法的原理与特点？分别用在什么地方
2. 如果让你优化收集方法，有什么思路

### JVM ###

#### 参数 ####
1. 说说你知道的几种主要的jvm 参数
2. -XX:+UseCompressedOops 有什么作用

#### 类加载器(ClassLoader) ####
1. Java 类加载器都有哪些
2. JVM如何加载字节码文件

#### 内存管理 ####
1. JVM内存分哪几个区，每个区的作用是什么
2. 一个对象从创建到销毁都是怎么在这些部分里存活和转移的
3. 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法
4. JVM中哪个参数是用来控制线程的栈堆栈小
5. 简述内存分配与回收策略
6. 简述重排序，内存屏障，happen-before，主内存，工作内存
7. Java中存在内存泄漏问题吗？请举例说明
8. 简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用
9. 内存映射缓存区是什么
10. jstack，jstat，jmap，jconsole怎么用
11. 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？32 位和 64 位的 JVM，int 类型变量的长度是多数？
12. 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位
13. JVM自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理堆
14. 什么情况下会发生栈内存溢出
15. 双亲委派模型是什么

### 多线程 ###
#### 基本概念 ####
##### 什么是线程 #####
是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。线程有就绪、阻塞和运行三种基本状态。

##### 多线程的优点 #####
1. 多线程技术使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态;
2. 当前没有进行处理的任务时可以将处理器时间让给其它任务;
3. 占用大量处理时间的任务可以定期将处理器时间让给其它任务;
4. 可以随时停止任务;
5. 可以分别设置各个任务的优先级以优化性能。
 是否需要创建多个线程取决于各种因素。在以下情况下,最适合采用多线程处理: 
(1)耗时或大量占用处理器的任务阻塞用户界面操作;

(2)各个任务必须等待外部资源 (如远程文件或 Internet连接)。


同样的 ,多线程也存在许多缺点 ,在考虑多线程时需要进行充分的考虑。多线程的主要缺点包括: 
(1)等候使用共享资源时造成程序的运行速度变慢。这些共享资源主要是独占性的资源 ,如打印机等。

(2)对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。当这种负担超过一定程度时,多线程的特点主要表现在其缺点上,比如用独立的线程来更新数组内每个元素。

(3)线程的死锁。即较长时间的等待或资源竞争以及死锁等多线程症状。

(4)对公有变量的同时读或写。当多个线程需要对公有变量进行写操作时,后一个线程往往会修改掉前一个线程存放的数据,从而使前一个线程的参数被修改;另外 ,当公用变量的读写操作是非原子性时,在不同的机器上,中断时间的不确定性,会导致数据在一个线程内的操作产生错误,从而产生莫名其妙的错误,而这种错误是程序员无法预知的。

##### 多线程的几种实现方式 #####
1. 继承Thread类创建线程
2. 实现Runnable接口创建线程
3. 实现Callable接口通过FutureTask包装器来创建Thread线程
4. 使用ExecutorService、Callable、Future实现有返回结果的线程


##### 用 Runnable 还是 Thread #####
实现Runnable接口方式可以避免继承Thread方式由于Java单继承特性带来的缺陷。实现Runnable的代码可以被多个线程共享，适合于多个线程处理同一资源的情况.

##### 什么是线程安全 #####
线程安全  就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
线程不安全  就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

6. Vector, SimpleDateFormat 是线程安全类吗
7. 什么 Java 原型不是线程安全的
##### 哪些集合类是线程安全的 #####
Vector：就比Arraylist多了个同步化机制（线程安全）。
Hashtable：就比Hashmap多了个线程安全。
ConcurrentHashMap:是一种高效但是线程安全的集合。
Stack：栈，也是线程安全的，继承于Vector。

##### 多线程中的忙循环是什么 #####
忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。

10. 如何创建一个线程
11. 编写多线程程序有几种实现方式
12. 什么是线程局部变量
##### 线程和进程有什么区别？进程间如何通讯，线程间如何通讯 #####
1.定义
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

2.关系
一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.
相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
3.区别
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
4.优缺点
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

###### 进程间的通讯 ######
  （1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
  （2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关 系 进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
  （3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺
  （5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
  （6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
  （7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
  （8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
而在java中我们实现多线程间通信则主要采用"共享变量"和"管道流"这两种方法

###### 线程间的通讯 ######
1. 线程同步。多个线程通过synchronized关键字这种方式来实现线程间的通信。
2. while轮询的方式
3. wait/notify机制
4. 管道通信就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信
https://www.cnblogs.com/hapjin/p/5492619.html

14. 什么是多线程环境下的伪共享（false sharing）
15. 同步和异步有何异同，在什么情况下分别使用他们？举例说明

#### Current ####

1. ConcurrentHashMap 和 Hashtable的区别
2. ArrayBlockingQueue, CountDownLatch的用法
3. ConcurrentHashMap的并发度是什么
4. CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么
Semaphore的用法

#### Thread ####

1. 启动一个线程是调用 run() 还是 start() 方法？start() 和 run() 方法有什么区别
2. 调用start()方法时会执行run()方法，为什么不能直接调用run()方法
3. sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别
4. yield方法有什么作用？sleep() 方法和 yield() 方法有什么区别
5. Java 中如何停止一个线程
6. stop() 和 suspend() 方法为何不推荐使用
7. 如何在两个线程间共享数据
8. 如何强制启动一个线程
9. 如何让正在运行的线程暂停一段时间
10. 什么是线程组，为什么在Java中不推荐使用
11. 你是如何调用 wait（方法的）？使用 if 块还是循环？为什么

#### 生命周期 ####
1. 有哪些不同的线程生命周期
2. 线程状态，BLOCKED 和 WAITING 有什么区别
3. 画一个线程的生命周期状态图
4. ThreadLocal 用途是什么，原理是什么，用的时候要注意什么

#### ThreadPool ####
1. 线程池是什么？为什么要使用它
2. 如何创建一个Java线程池
3. ThreadPool用法与优势
4. 提交任务时，线程池队列已满时会发会生什么
5. newCache 和 newFixed 有什么区别？简述原理。构造函数的各个参数的含义是什么，比如 coreSize, maxsize 等
6. 线程池的实现策略
7. 线程池的关闭方式有几种，各自的区别是什么
8. 线程池中submit() 和 execute()方法有什么区别？

#### 线程调度 ####

1. Java中用到的线程调度算法是什么
2. 什么是多线程中的上下文切换
3. 你对线程优先级的理解是什么
4. 什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)

#### 线程同步 ####
1. 请说出你所知的线程同步的方法
2. synchronized 的原理是什么
3. synchronized 和 ReentrantLock 有什么不同
4. 什么场景下可以使用 volatile 替换 synchronized
5. 有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行
6. 同步块内的线程抛出异常会发生什么
7. 当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B
8. 使用 synchronized 修饰静态方法和非静态方法有什么区别
9. 如何从给定集合那里创建一个 synchronized 的集合

#### 锁 ####
1. Java Concurrency API 中 的 Lock 接口是什么？对比同步它有什么优势
2. Lock 与 Synchronized 的区别？Lock 接口比 synchronized 块的优势是什么
3. ReadWriteLock是什么？
4. 锁机制有什么用
5. 什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题
6. 解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁
7. 什么时候应该使用可重入锁
8. 简述锁的等级方法锁、对象锁、类锁
9. Java中活锁和死锁有什么区别？
10. 什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁
11. 死锁与活锁的区别，死锁与饥饿的区别
12. 怎么检测一个线程是否拥有锁
13. 如何实现分布式锁
14. 有哪些无锁数据结构，他们实现的原理是什么
15. 读写锁可以用于什么应用场景
16. Executors类是什么？ Executor和Executors的区别
17. 什么是Java线程转储(Thread Dump)，如何得到它
18. 如何在Java中获取线程堆栈
19. 说出 3 条在 Java 中使用线程的最佳实践
20. 在线程中你怎么处理不可捕捉异常
21. 实际项目中使用多线程举例。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的
22. 请说出与线程同步以及线程调度相关的方法
23. 程序中有3个 socket，需要多少个线程来处理
24. 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到
25. 如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长
26. 如何确保 main() 方法所在的线程是 Java 程序最后结束的线程
27. 非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案
28. 你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它

### 异常 ###
#### 基本概念 ####
1. Error 和 Exception有什么区别
2. UnsupportedOperationException是什么
3. NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处
4. 什么是受检查的异常，什么是运行时异常
5. 运行时异常与一般异常有何异同
6. 简述一个你最常见到的runtime exception(运行时异常)

#### finally ####
1. finally关键词在异常处理中如何使用
2. 如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗
3. try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后
4. 在什么情况下，finally语句不会执行

throw 和 throws 有什么区别？
OOM你遇到过哪些情况？你是怎么搞定的？
SOF你遇到过哪些情况？
既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常
当自己创建异常类的时候应该注意什么
导致空指针异常的原因
异常处理 handle or declare 原则应该如何理解
怎么利用 JUnit 来测试一个方法的异常
catch块里别不写代码有什么问题
你曾经自定义实现过异常吗？怎么写的
什么是 异常链
在try块中可以抛出异常吗

### JDBC ###

1. 通过 JDBC 连接数据库有哪几种方式
2. 阐述 JDBC 操作数据库的基本步骤
3. JDBC 中如何进行事务处理
4. 什么是 JdbcTemplate
5. 什么是 DAO 模块
6. 使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能
7. 列出 5 个应该遵循的 JDBC 最佳实践

### IO ###
#### File ####
1. File类型中定义了什么方法来创建一级目录
2. File类型中定义了什么方法来判断一个文件是否存在

#### 流 ####

1. 为了提高读写性能，可以采用什么流
2. Java中有几种类型的流
3. JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类
4. 对文本文件操作用什么I/O流
5. 对各种基本数据类型和String类型的读写，采用什么流
6. 能指定字符编码的 I/O 流类型是什么

#### 序列化 ####
##### 什么是序列化？如何实现 Java 序列化及注意事项 #####

序列化：将对象转换成二进制
实现序列化：首先我们要把准备要序列化类，实现 Serializabel接口
java中的序列化机制能够将一个实例对象（只序列化对象的属性值，而不会去序列化什么所谓的方法。）的状态信息写入到一个字节流中使其可以通过socket进行传输、或者持久化到存储数据库或文件系统中；然后在需要的时候通过字节流中的信息来重构一个相同的对象。

一般而言，要使得一个类可以序列化，只需简单实现java.io.Serializable接口即可。

注意事项：
1、基本类型的数据可以直接序列化

2、对象要被序列化，它的类必须要实现Serializable接口；如果一个类中有引用类型的实例变量，这个引用类型也要实现Serializable接口。

3、可以用这个代码：ObjectOutputStream out  = new ObjectOutputStream(new FileOutputStream("seria"));
但是不能用这个代码：ObjectOutputStream out  = new ObjectOutputStream(new FileOutputStream("seria",true));

4、如果对象的引用类型没有实现序列化，但是还是想将这个对象序列化，那么可以将对象中用到的那个引用类型对象设置为transient类型。
（如果A包含了对B的引用，那么在序列化A的时候也会将B一并地序列化；如果此时A可以序列化，B无法序列化，那么在序列化A的时候就会发生异常，这时就需要将对B的引用设为transient，该关键字表示变量不会被序列化。）

5、如果用transient修饰引用类型对象，则这个引用类型的对象不会保存，那么如果希望保存下来又如何实现呢？
用这两段儿代码：

````
private transient Book book;//用transient关键字声明book
//这个方法会在序列化的过程中被调用     
    private void writeObject(ObjectOutputStream out){    
        try {    
            out.defaultWriteObject(); //这个方法会把这当前中非静态变量和非transient变量写到流中    
                                      //在这里我们就把name写到了流中。    
            //因为我们要保存Book的状态，所以我们还要想办法把其状态写入流中    
            out.writeInt(book.getIsbn());//ObjectOutputStream中提供了写基本类型数据的方法    
            //out.close();//注意，这句千万不能有，否刚将直接导致写入失败    
        } catch (IOException e) {    
            e.printStackTrace();    
        }     
    }    
        
    //这个方法会在反序列化的过程中被调用    
    private void readObject(ObjectInputStream in){    
        try {    
            in.defaultReadObject(); //和defaultWriteObject()方法相对应，默认的反序列化方法，会从流中读取    
                                    //非静态变量和非transient变量    
            int isbn  = in.readInt(); //用这个方法来读取一个int型值，这里我们是读取书号    
            book  = new Book(isbn); //这里我们就通过读取的 保存的状态构造 了一个和原来一样的Book对象    
            //in.close();同样的这句也不能有    
        } catch (IOException e) {    
            e.printStackTrace();    
        } catch (ClassNotFoundException e) {    
            e.printStackTrace();    
        }    
    }   
````
6、如果一个类没有实现Serializable接口，但是它的父类实现了，那么这个类也可以序列化。

7、如果一个类实现了Serializable接口，但是它的父类没有实现，那么这个类可以进行序列化吗？
答案是可以的，因为超类Object类没有实现Serializable接口，所以你懂了吧，但是会有个问题，你需要在父类中是实现默认的构造方法，否则会报异常:no validconstructor。

##### Serializable 与 Externalizable 的区别 #####
serializable和externalizable的区别是什么:
实现serializable,这个确确实实就是一个可以序列化的标示,对serializable进行implements之后,我们不用实现任何的功能,但是如果选择用externalizable,则需要进行实现它其中的接口,那么这其中的工作都将是程序员的.
但是serializable是虚拟机内建的,那么必然是占用大多的资源,导致速度减慢.而externalizable则是由程序员决定,存储什么,那么性能就要比serializable好多了.

https://www.cnblogs.com/davidwang456/p/3932025.html
#### Socket ####

1. socket 选项 TCP NO DELAY 是指什么
2. Socket 工作在 TCP/IP 协议栈是哪一层
3. TCP、UDP 区别及 Java 实现方式


说几点 IO 的最佳实践
##### 直接缓冲区与非直接缓冲器有什么区别？ #####
1. 字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。
2. 直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。
3. 直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer 。 Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。
4. 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。

怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么
当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少
如何使用扫描器类（Scanner Class）令牌化


#### 面向对象编程（OOP） ####
1. 解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling)


##### 多态的实现原理 #####
多态的概念：同一操作作用于不同对象，可以有不同的解释，有不同的执行结果，这就是多态，简单来说就是：父类的引用指向子类对象
https://www.cnblogs.com/startRuning/p/5673485.html

3. 封装、继承和多态是什么
4. 对象封装的原则是什么?  
#### 类 ####
##### 获得一个类的类对象有哪些方式 #####
- 方法1：类型.class，例如：String.class
- 方法2：对象.getClass()，例如："hello".getClass() 
- 方法3：Class.forName()，例如：Class.forName("java.lang.String")

##### 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ #####
###### 区别 ######
方法重载（overload）:

方法重载就是在一个类中可以创建多个方法，它们具有相同的名字，但是具有不同的参数和不同的定义，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法，这就是多态性，重载的时候方法名一样，参数类型和个数不一样，返回值类型可以相同可以不同，可以有不同的访问修饰符，可以抛出不同的异常.

方法重写（override）：

父类与子类之间的多态性，对父类的函数进行重新定义，如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写，在java中子类可以继承父类中的方法，而不需要重新编写相同的方法，但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这就需要采用方法重写，方法重写又称方法覆盖

若子类中的方法与父类中的某一方法具有相同的方法名，返回类型，参数列表，则新方法将覆盖原有的方法，如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类

子类函数的访问修饰权限不能小于父类的

重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查性异常（父类的异常宽泛性比子类的广）


3. 说出几条 Java 中方法重载的最佳实践

#### 抽象类 ####
##### 抽象类和接口的区别 #####
一 接口和抽象类的相似性
1 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。
2 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

二 接口和抽象类的区别
1 接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现，抽象类则完全可以包含普通方法。
2 接口里只能定义静态常量，不能定义普通成员变量，抽象类里则既可以定义普通成员变量，也可以定义静态常量。
3 接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
4 接口里不能包含初始化块，但抽象类里完全可以包含初始化块。
5 一个类最多只能有一个直接父类，包括抽象类，但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承不足。
http://www.importnew.com/18780.html
2. 抽象类中是否可以有静态的main方法
3. 抽象类是否可实现(implements)接口
4. 抽象类是否可继承具体类(concrete class)

#### 匿名类（Anonymous Inner Class） ####
1. 匿名内部类是否可以继承其它类？是否可以实现接口 

#### 内部类 ####
##### 内部类分为几种 #####

java中的内部类有四种：
1.静态内部类：作为类的静态成员，存在于某个类的内部。
  静态内部类虽然是外部类的成员，但是在未创建外部类的对象的情况下，可以直接创建静态内部类的对象。静态内部类可以引用外部类的静态成员变量和静态方法，但不能引用外部类的普通成员。

//静态内部类的测试程序
````
public class Outter {
static int a=1;
int b=5;
static void test(){
    System.out.println("外部类的静态方法");
}
static class Inner{
    public void test2(){
        System.out.println("a的值为"+a);;//直接引用外部类的静态成员变量
        test();//直接引用外部类的静态方法
        //b++;试图引用外部类的非静态成员变量，不能通过编译
        System.out.println("静态内部类的方法");
    }
}
public static void main(String[] args) {
    Inner in=new Inner();//静态内部类的对象可以直接创建，无需先创建外部类的对象
    in.test2();
}
}
````
2.成员内部类：作为类的成员，存在于某个类的内部。
  成员内部类可以调用外部类的所有成员，但只有在创建了外部类的对象后，才能调用外部的成员。
````
 public class Outter1 {
static int a=1;
int b=0;
public static void test1(){
    System.out.println("外部类的静态方法");
}
public void test2(){
    System.out.println("外部类的非静态方法");
}

class Inner{
    public void test(){
        System.out.println("在成员内部类的方法中");
        test1();//调用外部类的静态方法
        test2();//调用外部类的非静态方法
        System.out.println(a+b);//访问外部类的静态成员变量和非静态成员变量
    }
}
public static void main(String[] args) {
    //Inner in=new Inner();成员内部类的对象不能直接创建，会报错
    Outter1 out=new Outter1();//先创建外部类的对象
    Inner in=out.new Inner();//注意：！！成员内部类的对象必须通过外部类的对象创建
}
}
````
3.局部内部类：存在于某个方法的内部。
  局部内部类只能在方法内部中使用，一旦方法执行完毕，局部内部类就会从内存中删除。
  必须注意：如果局部内部类中要使用他所在方法中的局部变量，那么就需要将这个局部变量定义为final的。
````
public class Outter2 {
int a=10;
public void test(){
    final int c=5;

　 System.out.println("在外部类的方法中");
    class Inner{
        int b=20;
        void test1(){
            System.out.println("局部内部类的方法中");

            System.out.println(c);//注意：如果局部内部类中要使用他所在方法中的局部变量，那么就需要将这个局部变量定义为final的。
        }
    }
    Inner inner=new Inner();
    inner.test1();
}

public static void main(String[] args) {
    Outter2 outter=new Outter2();
    outter.test();
}
}
````
4.匿名内部类：存在于某个类的内部，但是无类名的类。

  匿名内部类的定义与对象的创建合并在一起，匿名内部类一般通过如下形式定义，并且在定义的同时进行对象的实例化。

  new 类或者接口的名字(){

  //匿名内部类的主体，大括号中是匿名内部类的主体，这个主体就是类或者接口的实现，如果是类，那么匿名内部类是该类的子类，如果是接口，匿名内部类需要完成接口的实现。

````
class Person{
    public void show(Message message){
        message.show();
    }
}

class Message{
    public void show(){
        System.out.println("在Message类中");
    }
}

public class Outter3 {
    public static void main(String[] args) {
        Person person=new Person();
        person.show(new Message(){
            public void show(){
                System.out.println("在匿名内部类中");
            }
        });
    }
}

}
````
 java中绝大多数情况下，类的访问修饰符只有public和默认这两种，但也有例外。静态内部类和成员内部类还可以有protected和private两种
2. 内部类可以引用它的包含类（外部类）的成员吗
3. 请说一下 Java 中为什么要引入内部类？还有匿名内部类

#### 继承 ####
1. 继承（Inheritance）与聚合（Aggregation）的区别在哪里
2. 继承和组合之间有什么不同
3. 为什么类只能单继承，接口可以多继承
4. 存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C = (C) B
5. 如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题


#### 接口 ####
1. 接口是什么
2. 接口是否可继承接口
3. 为什么要使用接口而不是直接使用具体类？接口有什么优点

#### 泛型 ####

1. 泛型的存在是用来解决什么问题
2. 泛型的常用特点
3. List能否转为List

### 工具类 ###
#### 日历 ####
1. Calendar Class的用途
2. 如何在Java中获取日历类的实例
3. 解释一些日历类中的重要方法
4. GregorianCalendar 类是什么
5. SimpleTimeZone 类是什么
6. Locale类是什么
7. 如何格式化日期对象
8. 如何添加小时(hour)到一个日期对象(Date Objects)
9. 如何将字符串 YYYYMMDD 转换为日期

#### Math ####
Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？

#### XML ####
##### XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？DOM 和 SAX 解析器有什么不同？ #####
两种形式 dtd schema，
本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)，
有DOM,SAX,STAX等
DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问
SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问
STAX:Streaming API for XML (StAX)
DOM和SAX都有自己的不同应用领域 


|区别|dom|sax|
|-|-|-|
|操作|将所有文件读取到内存中形成dom树，如文件过大，则无法操作|顺序读入所需要的文件内容，不会一次性全部读取，不受文件大小限制|
|访问限制|dom树在内存中形成，可以随意存放或读取文件树的任何部分，没有次数限制|由于采用部分读取，只能对文件按顺序从头到尾读取xml文件内容，但不能修改|
|修改|可以任意修改文件树|只能读取xml文件内容，但不能修改|
|复杂度|易于理解，易于开发|开发上比较复杂，需要用户自定义事件处理器|
|对象模型|系统为使用者自动建立dom树，xml对象模型由系统提供|对开发人员更灵活，可以用sax建立自己的对象模型|


由两者的特点可以发现两者的区别： 
DOM解析适合于对文件进行修改和随机存取的操作，但是不适合于大型文件的操作； 
SAX采用部分读取的方式，所以可以处理大型文件，而且只需要从文件中读取特定内容，SAX解析可以由用户自己建立自己的对象模型。比如，想要做一个新闻类的应用，就可以用SAX解析，只需要从接口读取数据，不需要修改。
所以DOM解析适合于修改，SAX解析适合于读取大型文件，2者结合的话可以用JDOM
2. Java解析XML的方式
3. 用 jdom 解析 xml 文件时如何解决中文问题？如何解析
4. 你在项目中用到了 XML 技术的哪些方面？如何实现

#### 动态代理 ####
描述动态代理的几种实现方式，分别说出相应的优缺点

#### 设计模式 ####
1. 什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合
2. 你知道哪些商业级设计模式？
3. 哪些设计模式可以增加系统的可扩展性
##### 单例模式 #####
````
public class Singleton {  
    private static Singleton instance=null;  
    private Singleton() {};  
    public static Singleton getInstance(){  
         if (instance == null) {    //第一重校验，线程不安全，有多个线程可能同时得到Singleton的值为null，
              synchronized (Singleton.class) {    //同步块代码，保证只有一条线程进入此方法
                  if (instance == null) {    //此时创建了对象，其他线程进入的时候就会判断为false，直接返回以前创建的对象。
                      instance = new Singleton();    
                  }    
              }    
          }    
          return instance;    
    }  
}  
````

5. 除了单例模式，你在生产环境中还用过什么设计模式？
6. 写 Singleton 单例模式
7. 单例模式的双检锁是什么
8. 如何创建线程安全的 Singleton
9. 什么是类的单例模式
10. 写出三种单例模式实现
11. 适配器模式
12. 适配器模式是什么？什么时候使用
13. 适配器模式和代理模式之前有什么不同
14. 适配器模式和装饰器模式有什么区别
15. 什么时候使用享元模式
16. 什么时候使用组合模式
17. 什么时候使用访问者模式
18. 什么是模板方法模式
19. 请给出1个符合开闭原则的设计模式的例子


### 开放问题 ###
1. 用一句话概括 Web 编程的特点
2. Google是如何在一秒内把搜索结果返回给用户
3. 哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入
4. 树（二叉或其他）形成许多普通数据结构的基础。请描述一些这样的数据结构以及何时可以使用它
5. 某一项功能如何设计
6. 线上系统突然变得异常缓慢，你如何查找问题
7. 什么样的项目不适合用框架
8. 新浪微博是如何实现把微博推给订阅者
9. 简要介绍下从浏览器输入 URL 开始到获取到请求界面之后 Java Web 应用中发生了什么
10. 请你谈谈SSH整合
11. 高并发下，如何做到安全的修改同一行数据
12. 12306网站的订票系统如何实现，如何保证不会票不被超卖
13. 网站性能优化如何优化的
14. 聊了下曾经参与设计的服务器架构
15. 请思考一个方案，实现分布式环境下的 countDownLatch
16. 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存.
17. 在你的职业生涯中，算得上最困难的技术挑战是什么
18. 如何写一篇设计文档，目录是什么
19. 大写的O是什么？举几个例子
20. 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用
21. 解释一下网络应用的模式及其特点
22. 设计一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新
23. 说出数据连接池的工作机制是什么
24. 怎么获取一个文件中单词出现的最高频率
25. 描述一下你最常用的编程风格
26. 如果有机会重新设计你们的产品，你会怎么做
28. 如何搭建一个高可用系统如何启动时不需输入用户名与密码
29. 如何在基于Java的Web项目中实现文件上传和下载
30. 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。
31. 如何实现负载均衡，有哪些算法可以实现.
32. 如何设计一个购物车？想想淘宝的购物车如何实现的
33. 如何设计一套高并发支付方案，架构如何设计
34. 如何设计建立和保持 100w 的长连接
35. 如何避免浏览器缓存。
36. 如何防止缓存雪崩
37. 如果AB两个系统互相依赖，如何解除依
38. 如果有人恶意创建非法连接，怎么解决
39. 如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能
40. 如果系统要使用超大整数（超过long长度范围），请你设计一个数据结构来存储这种超大型数字以及设计一种算法来实现超大整数加法运算）
41. 如果要设计一个图形系统，请你设计基本的图形元件(Point,Line,Rectangle,Triangle)的简单实现
42. 如果让你实现一个并发安全的链表，你会怎么做
43. 应用服务器与WEB 服务器的区别？应用服务器怎么监控性能，各种方式的区别？你使用过的应用服务器优化技术有哪些
44. 大型网站在架构上应当考虑哪些问题
45. 有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的
46. 最近看什么书，印象最深刻的是什么
47. 描述下常用的重构技巧
48. 你使用什么版本管理工具？分支（Branch）与标签（Tag）之间的区别在哪里
49. 你有了解过存在哪些反模式（Anti-Patterns）吗
50. 你用过的网站前端优化的技术有哪些
51. 如何分析Thread dump
52. 你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念
53. 你是如何处理内存泄露或者栈溢出问题的
54. 你们线上应用的 JVM 参数有哪些
55. 怎么提升系统的QPS和吞吐量


#### 知识面 ####
1. 解释什么是 MESI 协议(缓存一致性)
2. 谈谈 reactor 模型
3. Java 9 带来了怎样的新功能
4. Java 与 C++ 对比，C++ 或 Java 中的异常处理机制的简单原理和应用
5. 简单讲讲 Tomcat 结构，以及其类加载器流程
6. 虚拟内存是什么
7. 阐述下 SOLID 原则
8. 请简要讲一下你对测试驱动开发（TDD）的认识
9. CDN实现原理
10. Maven 和 ANT 有什么区别
11. UML中有哪些常用的图 

#### Linux ####
1. Linux 下 IO 模型有几种，各自的含义是什么。
2. Linux 系统下你关注过哪些内核参数，说说你知道的
3. Linux 下用一行命令查看文件的最后五行
4. 平时用到哪些 Linux 命令
5. 用一行命令输出正在运行的 Java 进程
6. 使用什么命令来确定是否有 Tomcat 实例运行在机器上



1. 什么是 N+1 难题
2. 什么是 paxos 算法
3. 什么是 restful，讲讲你理解的 restful
4. 什么是 zab 协议
5. 什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别
6. 什么是领域驱动开发（Domain Driven Development）
7. 介绍一下了解的 Java 领域的 Web Service 框架
8. Web Server、Web Container 与 Application Server 的区别是什么
9. 微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里
10. 描述 Cookie 和 Session 的作用，区别和各自的应用范围，Session工作原理
11. 你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些
12. 简述下数据库正则化（Normalizations）
13. KISS,DRY,YAGNI 等原则是什么含义
14. 分布式事务的原理，优缺点，如何使用分布式事务？
15. 布式集群下如何做到唯一序列号  
#### 网络 ####
1. HTTPS 的加密方式是什么，讲讲整个加密解密流程
2. HTTPS和HTTP的区别
3. HTTP连接池实现原理
4. HTTP集群方案
5. Nginx、lighttpd、Apache三大主流 Web服务器的区别

是否看过框架的一些代码
持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些
数值提升是什么
你能解释一下里氏替换原则吗
你是如何测试一个应用的？知道哪些测试框架
传输层常见编程协议有哪些？并说出各自的特点


#### 反射 ####

1. 反射机制提供了什么功能？
2. 反射是如何实现的
3. 哪里用到反射机制
4. 反射中 Class.forName 和 ClassLoader 区别
5. 反射创建类实例的三种方式是什么
6. 如何通过反射调用对象的方法
7. 如何通过反射获取和设置对象私有字段的值
8. 反射机制的优缺点
