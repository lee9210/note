2.2 运行时数据区域。图示：图2-1.png

1). 方法区。线程共享的内存区域。图示：方法区保存信息.png
		用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译期编译后的代码缓存等数据。别名"非堆"。(class的元数据就保存在此区间)
	a). 运行时常量池。
		方法区间的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的
	各种字面量与符号引用，这部分内容将在类加载后放到方法区的运行池常量池中。
	当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。
	
2). 虚拟机栈。线程私有
		
		为虚拟机执行java方法(即字节码)服务。生命周期与线程相同。
		每个方法被执行的时候，java虚拟机都会同步创建一个栈帧，用于存储：局部变量表、操作数栈、动态链接、方法出口等信息。
		每个方法被调用直至执行完毕的过程，就对应一个栈帧在虚拟机中从入栈到出栈的过程。
		局部变量表保存了编译期可知的各种java虚拟机基本数据类型(8种)、对象引用(reference类型)和returnAddress类型(指向了一条字节
	码指令的地址)。这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示。局部变量表所需的内存空间在编译期间完成，当进入
	一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小(Slot数量)
	注：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果java虚拟机栈容量可以动态扩展，当无法申请到
	足够的内存时，则抛出OutOfMemoryError异常。
	
3). 本地方法栈。线程私有
		为虚拟机使用到的本地(Native)方法服务
		hotspot虚拟机直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，也会抛出StackOverflowError异常和OutOfMemoryError异常。
	
4). 堆
		被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。
		从内存分配角度来看，所有线程共享java堆中可以划分出多个线程私有的分配缓冲区(TLAB)，
		java堆可以处于物理上不连续的内存空间中，但在逻辑上，它应该被视为连续的。
		java堆即可以被实现成固定大小的，也可以是扩展的(参数-Xmx和-Xms设定)。如果在java堆中没有内存完成实例分配，并且堆也无法再
	扩展时，java虚拟机将会抛出OutOfMemoryError异常。
		
5). 程序计数器。线程私有
		程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器
	的值来选取下一条需要执行的字节码指令。他是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖
	这个计数器来完成。
		多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的。一个处理器都只会执行一条线程中的指令。为了切换后能恢复到正
	确的执行位置，每个线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。
		如果正在执行的是本地(Native)方法，这个计数器值则为空(Undefined)
		
6). 执行引擎
	充当了将高级语言翻译为机器语言的译者。
7). 本地库接口
8). 本地方法库

2.2.7 直接内存
	NIO：基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的
DirectByteBuffer对象作为这块内存的引用进行操作。避免了在java堆和Native堆中来回复制数据。
	动态扩展时也会抛出OutOfMemoryError异常。

2.3 对象
2.3.1 对象的创建

1. 当java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引
用代表的代表的类是否已被加载解析和初始化过，如果没有，那必须先执行相应的类加载过程。

2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便完全确定。分配过程中，就相当于把一
块确定大小的内存块从java堆中划分出来。// todo 分配方式

3. 内存分配完成之后，虚拟机必须将分配到的内存空间(不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB
分配时顺便进行。

4. 接下来，java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC
分代年龄等信息。这些信息存放在对象的对象头中。根据虚拟机当前运行状态的不同，如是否启用偏向锁，对象头会有不同的设置方式。

5. new指令之后会接着执行<init>()方法，对对象进行初始化

2.3.2 对象的内存布局
	在hotspot虚拟机中，对象在内存中的存储布局可以划分为三个部分:对象头(Header)、实例数据(Instance Data)、和对齐填充(Padding)
	
	对象头部分包含两类信息。第一类是用于存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向
时间戳等。这部分称为Mark Word。图示：HotSpot虚拟机对象头Mark Word.png
	对象头的另一部分是类型指针，即指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例
	如果对象是一个数组，在对象头中还必须有一块用于记录数组长度的数据。
	
	实例数据部分是对象真正存储的有效信息，即程序代码里面所定义的各种类型的字段内容，无论是从父类集成下来的，还是子类中定义的
	
	对其填充不是特别必要，仅仅起着占位符的作用。

2.3.3 对象的访问定位
	句柄访问：java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型
数据各自具体的地址信息。图示：通过句柄访问对象.png

	指针访问：java堆中对象的内存布局就必须考虑如何防止访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问
对象本身的话，就不需要多一次间接访问的开销。图示：通过直接指针访问对象.png

	优劣：
	使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集)时，只会改变句柄中的实例数据指针，而referece
本身不需要被修改
	使用直接指针的最大好处就是速度快，它节省了一次指针定位的时间开销。**hotspot使用的就是这种方式**
	
	
3.2.2 可达性分析算法
	通过一系列称为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系，向下搜索，搜索过程所走过的路径称为"引用链"，
如果某个对象到GC Roots间没有任何引用链相连，或者从GC Roots到这个对象不可达时，则证明此对象不可能再被使用的。图示:可达性分析算法判断对象是否可回收.png

**GC Roots**
1. 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
2. 在方法区中类静态属性引用的对象。如java类的引用类型静态变量
3. 在方法区中常量引用的对象，如字符串常量池(String table)里的引用
4. 在本地方法栈中JNI(Native方法)引用的对象
5. java虚拟机内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象(如NullPointException)等，还有系统类加载器
6. 所有被同步锁(synchronized关键字)持有的对象
7. 反应java虚拟机内部情况的JMXBean、JVMTI中注册的回调，本地代码缓存等

3.2.3 引用
	强引用、软引用、弱引用、虚引用。四种引用强度依次减弱
	
1. 强引用
	在程序代码中普遍存在的引用赋值，即类似"Object obj = new Object()"这种引用关系。无论在任何情况下，只要强引用关系还在，垃圾
收集器就不会回收被引用的对象。

2. 软引用
	还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，
如果这次回收还没有足够的内存，才会抛出内存溢出异常。

3. 弱引用
	非必须对象，比软引用更弱一下，被弱引用关联的对象能生存到下一次垃圾收集器发生为止。当垃圾收集器开始工作，无论当前内存是否足
够，都会回收掉只被弱引用关联的对象

4. 虚引用
	一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯
一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

3.2.5 回收方法区
	方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。
	常量池回收类似对象，不再引用的直接回收
	
	"不再使用的类"需要满足三个条件
	1. 该类的所有实例都已经被回收，即java堆中不存在该类及其任何派生子类的实例
	2. 加载该类的类加载器已经被回收。这个除非是可替换类加载器的场景，如OSGi、JSP的重加载等，通常很难达成
	3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
	
	满足上面三个条件，仅仅是被允许，而不是必然回收。

3.3 垃圾收集算法

3.3.1 分代收集理论
1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
3. 跨代引用假说：新生代引用老年代内的对象或老年代引用新生代的对象。存在相互引用的关系的两个对象，是应该倾向于同时生存或消亡的

部分收集
1. 新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集
2. 老年代收集(Major GC/Old GC):目标只是老年代的垃圾收集
3. 混合收集(Mixed GC):指目标是收整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为
4. 整堆收集(Full GC):收集整个java堆和方法去的垃圾收集
	
3.3.2 标记-清除算法。图示：标记-清除算法示意图.png
	分为两个阶段：标记和清除。首先标记出素有需要回收的对象，在标记完成后，统一回收掉被标记的对象，也可以反过来。

3.3.3 标记-复制算法。图示：标记-复制算法示意图.png
	将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存永王了，就将还存活着的对象复制到另外一块上面，然后
再把已使用过的内存空间一次清理掉。
	如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但是对于多数对象都是可回收的情况，算法需要复制就占少
数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑空间碎片的复杂情况。但是有一半的空间浪费
	
	标记-复制算法在对象存活率较高时要进行较多的复制操作，效率将会降低。如果不想浪费50%的空间，就需要有额外的空间进行分配担保，
以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代不采用这种算法。

3.3.4 标记-整理算法。图示：标记-整理算法示意图.png
	老年代采用此算法。
	其过程与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理
掉边界以外的内存。

3.4 HotSpot算法实现
3.4.1 根节点枚举
	所有收集器在枚举根节点时都必须"stop the world"。
	HotSpot使用OopMap的数据结构来获取哪些地方存放着对象引用。因此不用真正一个不漏的从方法区等GC Roots开始查找

3.4.2 安全点
	安全点位置的选取基本上是以"是否具有让程序长时间执行的特征"为标准进行选定的。
	"长时间执行"的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令
才会产生安全点。
	让线程跑到最近的安全点，然后停顿下来有两种方案：抢先中断式和主动中断式。
	抢先中断：不需要线程的执行代码主动配合，在垃圾收集发生时，首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点
上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上（这个方式没有使用）
	主动中断：不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程会不停地主动去轮训这个标志，一旦发现中断标致为真，就自
己在最近的安全点上主动挂起。
	
	程序没有分配处理器时间时。如用户线程处于sleep或blckked状态，这时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起
自己。需要用安全区域解决

3.4.3 安全区域
	在某一段打码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。即安全区域是被拉伸了的安全点。
	当用户线程执行到安全区域时，首先会标识自己进入安全区域，当这段时间里虚拟机要发起垃圾收集时就不必取关这些已声明自己在安全区域
的线程，当线程要离开安全区域时，要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)，如果完成了，
继续执行，否则等待。

3.4.4 记忆集与卡表
	为了解决对象跨代引用的问题，垃圾收集器在新生代中建立记忆集的数据结构，用以避免把整个老年代加进GC Roots扫描范围。
	记忆集用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。
	记录精度分为：字长精度、对象精度、卡精度。卡表就是以卡精度实现的记忆集。
	卡精度：每个记录精确到一块内存区域，该区域内含有对象含有跨代指针
	
	// todo
	
3.4.5 写屏障
	// todo
	
3.4.6 并发的可达性分析
	
	
	
	
	
	
	
	
	
84


























