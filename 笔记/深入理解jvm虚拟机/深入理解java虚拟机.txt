2.2 运行时数据区域。图示：图2-1.png

1). 方法区。线程共享的内存区域。图示：方法区保存信息.png
		用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译期编译后的代码缓存等数据。别名"非堆"。(class的元数据就保存在此区间)
	a). 运行时常量池。
		方法区间的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的
	各种字面量与符号引用，这部分内容将在类加载后放到方法区的运行池常量池中。
	当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。
	
2). 虚拟机栈。线程私有
		
		为虚拟机执行java方法(即字节码)服务。生命周期与线程相同。
		每个方法被执行的时候，java虚拟机都会同步创建一个栈帧，用于存储：局部变量表、操作数栈、动态链接、方法出口等信息。
		每个方法被调用直至执行完毕的过程，就对应一个栈帧在虚拟机中从入栈到出栈的过程。
		局部变量表保存了编译期可知的各种java虚拟机基本数据类型(8种)、对象引用(reference类型)和returnAddress类型(指向了一条字节
	码指令的地址)。这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示。局部变量表所需的内存空间在编译期间完成，当进入
	一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小(Slot数量)
	注：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果java虚拟机栈容量可以动态扩展，当无法申请到
	足够的内存时，则抛出OutOfMemoryError异常。
	
3). 本地方法栈。线程私有
		为虚拟机使用到的本地(Native)方法服务
		hotspot虚拟机直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，也会抛出StackOverflowError异常和OutOfMemoryError异常。
	
4). 堆
		被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。
		从内存分配角度来看，所有线程共享java堆中可以划分出多个线程私有的分配缓冲区(TLAB)，
		java堆可以处于物理上不连续的内存空间中，但在逻辑上，它应该被视为连续的。
		java堆即可以被实现成固定大小的，也可以是扩展的(参数-Xmx和-Xms设定)。如果在java堆中没有内存完成实例分配，并且堆也无法再
	扩展时，java虚拟机将会抛出OutOfMemoryError异常。
		
5). 程序计数器。线程私有
		程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器
	的值来选取下一条需要执行的字节码指令。他是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖
	这个计数器来完成。
		多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的。一个处理器都只会执行一条线程中的指令。为了切换后能恢复到正
	确的执行位置，每个线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。
		如果正在执行的是本地(Native)方法，这个计数器值则为空(Undefined)
		
6). 执行引擎
	充当了将高级语言翻译为机器语言的译者。
7). 本地库接口
8). 本地方法库

2.2.7 直接内存
	NIO：基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的
DirectByteBuffer对象作为这块内存的引用进行操作。避免了在java堆和Native堆中来回复制数据。
	动态扩展时也会抛出OutOfMemoryError异常。

2.3 对象
2.3.1 对象的创建

1. 当java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引
用代表的代表的类是否已被加载解析和初始化过，如果没有，那必须先执行相应的类加载过程。

2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便完全确定。分配过程中，就相当于把一
块确定大小的内存块从java堆中划分出来。// todo 分配方式

3. 内存分配完成之后，虚拟机必须将分配到的内存空间(不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB
分配时顺便进行。

4. 接下来，java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC
分代年龄等信息。这些信息存放在对象的对象头中。根据虚拟机当前运行状态的不同，如是否启用偏向锁，对象头会有不同的设置方式。

5. new指令之后会接着执行<init>()方法，对对象进行初始化

2.3.2 对象的内存布局
	在hotspot虚拟机中，对象在内存中的存储布局可以划分为三个部分:对象头(Header)、实例数据(Instance Data)、和对齐填充(Padding)
	
	对象头部分包含两类信息。第一类是用于存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向
时间戳等。这部分称为Mark Word。图示：HotSpot虚拟机对象头Mark Word.png
	对象头的另一部分是类型指针，即指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例
	如果对象是一个数组，在对象头中还必须有一块用于记录数组长度的数据。
	
	实例数据部分是对象真正存储的有效信息，即程序代码里面所定义的各种类型的字段内容，无论是从父类集成下来的，还是子类中定义的
	
	对其填充不是特别必要，仅仅起着占位符的作用。

2.3.3 对象的访问定位
	句柄访问：java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型
数据各自具体的地址信息。图示：通过句柄访问对象.png

	指针访问：java堆中对象的内存布局就必须考虑如何防止访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问
对象本身的话，就不需要多一次间接访问的开销。图示：通过直接指针访问对象.png

	优劣：
	使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集)时，只会改变句柄中的实例数据指针，而referece
本身不需要被修改
	使用直接指针的最大好处就是速度快，它节省了一次指针定位的时间开销。**hotspot使用的就是这种方式**
	
	
3.2.2 可达性分析算法
	通过一系列称为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系，向下搜索，搜索过程所走过的路径称为"引用链"，
如果某个对象到GC Roots间没有任何引用链相连，或者从GC Roots到这个对象不可达时，则证明此对象不可能再被使用的。图示:可达性分析算法判断对象是否可回收.png

**GC Roots**
1. 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
2. 在方法区中类静态属性引用的对象。如java类的引用类型静态变量
3. 在方法区中常量引用的对象，如字符串常量池(String table)里的引用
4. 在本地方法栈中JNI(Native方法)引用的对象
5. java虚拟机内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象(如NullPointException)等，还有系统类加载器
6. 所有被同步锁(synchronized关键字)持有的对象
7. 反应java虚拟机内部情况的JMXBean、JVMTI中注册的回调，本地代码缓存等

3.2.3 引用
	强引用、软引用、弱引用、虚引用。四种引用强度依次减弱
	
1. 强引用
	在程序代码中普遍存在的引用赋值，即类似"Object obj = new Object()"这种引用关系。无论在任何情况下，只要强引用关系还在，垃圾
收集器就不会回收被引用的对象。

2. 软引用
	还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，
如果这次回收还没有足够的内存，才会抛出内存溢出异常。

3. 弱引用
	非必须对象，比软引用更弱一下，被弱引用关联的对象能生存到下一次垃圾收集器发生为止。当垃圾收集器开始工作，无论当前内存是否足
够，都会回收掉只被弱引用关联的对象

4. 虚引用
	一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯
一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

3.2.5 回收方法区
	方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。
	常量池回收类似对象，不再引用的直接回收
	
	"不再使用的类"需要满足三个条件
	1. 该类的所有实例都已经被回收，即java堆中不存在该类及其任何派生子类的实例
	2. 加载该类的类加载器已经被回收。这个除非是可替换类加载器的场景，如OSGi、JSP的重加载等，通常很难达成
	3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
	
	满足上面三个条件，仅仅是被允许，而不是必然回收。

3.3 垃圾收集算法

3.3.1 分代收集理论
1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
3. 跨代引用假说：新生代引用老年代内的对象或老年代引用新生代的对象。存在相互引用的关系的两个对象，是应该倾向于同时生存或消亡的

部分收集
1. 新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集
2. 老年代收集(Major GC/Old GC):目标只是老年代的垃圾收集
3. 混合收集(Mixed GC):指目标是收整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为
4. 整堆收集(Full GC):收集整个java堆和方法去的垃圾收集
	
3.3.2 标记-清除算法。图示：标记-清除算法示意图.png
	分为两个阶段：标记和清除。首先标记出素有需要回收的对象，在标记完成后，统一回收掉被标记的对象，也可以反过来。

3.3.3 标记-复制算法。图示：标记-复制算法示意图.png
	将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存永王了，就将还存活着的对象复制到另外一块上面，然后
再把已使用过的内存空间一次清理掉。
	如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但是对于多数对象都是可回收的情况，算法需要复制就占少
数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑空间碎片的复杂情况。但是有一半的空间浪费
	
	标记-复制算法在对象存活率较高时要进行较多的复制操作，效率将会降低。如果不想浪费50%的空间，就需要有额外的空间进行分配担保，
以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代不采用这种算法。

3.3.4 标记-整理算法。图示：标记-整理算法示意图.png
	老年代采用此算法。
	其过程与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理
掉边界以外的内存。

3.4 HotSpot算法实现
3.4.1 根节点枚举
	所有收集器在枚举根节点时都必须"stop the world"。
	HotSpot使用OopMap的数据结构来获取哪些地方存放着对象引用。因此不用真正一个不漏的从方法区等GC Roots开始查找

3.4.2 安全点
	安全点位置的选取基本上是以"是否具有让程序长时间执行的特征"为标准进行选定的。
	"长时间执行"的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令
才会产生安全点。
	让线程跑到最近的安全点，然后停顿下来有两种方案：抢先中断式和主动中断式。
	抢先中断：不需要线程的执行代码主动配合，在垃圾收集发生时，首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点
上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上（这个方式没有使用）
	主动中断：不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程会不停地主动去轮训这个标志，一旦发现中断标致为真，就自
己在最近的安全点上主动挂起。
	
	程序没有分配处理器时间时。如用户线程处于sleep或blckked状态，这时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起
自己。需要用安全区域解决

3.4.3 安全区域
	在某一段打码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。即安全区域是被拉伸了的安全点。
	当用户线程执行到安全区域时，首先会标识自己进入安全区域，当这段时间里虚拟机要发起垃圾收集时就不必取关这些已声明自己在安全区域
的线程，当线程要离开安全区域时，要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)，如果完成了，
继续执行，否则等待。

3.4.4 记忆集与卡表
	为了解决对象跨代引用的问题，垃圾收集器在新生代中建立记忆集的数据结构，用以避免把整个老年代加进GC Roots扫描范围。
	记忆集用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。
	记录精度分为：字长精度、对象精度、卡精度。卡表就是以卡精度实现的记忆集。
	卡精度：每个记录精确到一块内存区域，该区域内含有对象含有跨代指针
	
	// todo
	
3.4.5 写屏障
	// todo
	
3.4.6 并发的可达性分析
	三色标记。图示；三色分析流程.png
	白色：表示对象尚未被垃圾收集器访问过。在可达性分析刚开始的阶段，所有的对象都是白色的，若在分析结束阶段，仍是白色，即代表不可达
	黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对
象引用指向了黑色对象，无需重新扫描。黑色对象不可直接（不经过灰色对象）指向某个白色对象
	灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过
	
	“对象消失”的两个条件
	1. 赋值器插入了一条或多条从黑色到白色对象的新引用
	2. 赋值器删除了全部从灰色对象到白色对象的直接或间接引用
	
	要解决并发扫描时的对象消失问题，只需破坏这两个条件中的任意一个即可。因此有两种解决方案：增量更新和原始原始快照。
	
	增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束后，再将
这些记录过的引用关系中的黑色对象为根，重新扫描一次。即：黑色对象一旦新插入了指向白色对象的引用后，他就变回灰色对象
	
	原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将
这些记录过引用关系中的灰色对象为根，重新扫描一次。即：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来搜索。
	
3.5 经典垃圾收集器：图示：HotSpot虚拟机的垃圾收集器.png

tips：
并行：多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态
并发：垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务
请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理和吞吐量受到一定影响

Parallel Scavenge和CMS等收集器的区别
CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间
Parallel Scavenge的目标是达到一个可控制的吞吐量。吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间)
 
3.5.1 Serial收集器。图示：Serial+Serial Old收集器运行示意图.png
	一个单线程工作的收集器。在工作时，必须暂停其他所有工作线程，直到收集结束。

3.5.2 ParNew收集器。图示：ParNew收集器运行示意图.png
	Serial收集器多线程版本。
	
3.5.3 Parallel Scavenge收集器
	基于“标记-复制”算法，能并行收集的多线程收集器。注重吞吐量

3.5.5 Parallel Old收集器
	基于“标记-复制”算法，能并行收集的多线程收集器。
	
3.5.6 CMS收集器。图示：CMS收集器运行示意图.png
	以最短回收停顿为目标的收集器。基于“标记-清除”算法实现
	分为四个步骤
		1. 初始标记(需要全局暂停)。标记一下GC Roots能直接关联到的对象
		2. 并发标记。从GC Roots的直接关联对象开始遍历整个对象图的过程，不需要停顿用户线程
		3. 重新标记(需要全局暂停)。修正并发标记期间，因用户程序继续运行而产生的变动那一部分对象的标记记录。
		4. 并发清除。清理标记阶段判断的已经死亡过的对象。
		
	优点：并发收集、低停顿。
	缺点：
		1. 对处理器资源非常敏感。会占用用户线程资源，导致程序变慢
		2. 无法处理“浮动垃圾”，有可能出现"current mode failure"而导致Full GC。在并发标记和并发清理阶段，用户线程还
	是在继续运行的，因此会有新的垃圾产生，CMS无法在档次回收中处理掉他们，只能留到下次。
		3. 基于“标记-清除”算法实现，会有大量空间水平产生。
		
3.5.7 G1收集器
	主要是面向服务端应用的垃圾收集器。
	把java堆划分为多个大小相等的独立区域(Region)，每个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或老年代空间。收集
器能够对扮演不同角色的Region采用不同的策略去处理。图示:G1收集器Region分布示意图.png
	Region中还有一类特殊的Humogous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。将会被存
放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来看待。
	
	G1会在后台维护一个优先级列表，此列表保存各个Region里面的垃圾堆的“价值”大小，优先处理回收加载收益最大的Region
	G1使用记忆集避免全堆作为GC Roots扫描，每个Region都维护有自己的记忆集。这些记忆集会记录下别的Region指向自己的指针，并标记这些指
针分别在哪些卡页范围内。是一种双向结构。
	G1采用**原始快照**方法来解决标记结果出现错误。
	
收集过程：图示：G1收集器运行示意图.png
1. 初始标记：仅仅只是标记一下GC Roots能直接关联的对象，并且修改(原始快照)TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用
的Region中分配新对象。需要停顿用户线程
2. 从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。对象图扫描完成以后，还要重新处理SATB记录下的
在并发期间引用变动的对象。不需要停顿用户线程。不需要停顿用户线程。
3. 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录
4. 筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所戚薇的停顿时间来制定回收计划，可以自由选择任
意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。需要暂停用户线程。
	

3.6 低延迟垃圾收集器
	衡量垃圾收集器的三项最重要的指标是：内存占用、吞吐量和低延迟，不可能同时满足三项条件。
	
3.6.1 Shenandoah收集器
	类似G1，使用Region的堆内存布局，存放大对象的Humongous Region，回收策略同样优先处理回收价值最大的Region
	采用整理算法实现。不会有新生代Region和老年代Region的划分，采用“连接矩阵”的全局数据结构来记录跨Region的引用关系降低了处理跨代指
针的记忆集维护消耗。
	“连接矩阵”可以理解为一张二维表格，如果Region N 有对象指向了Region M，就在表格的N行M列中打上一个标记，如果Region 5中的对象Baz引
用指向了Region 3 的Foo，Foo又引用了Region 1 的Bar，那“连接矩阵”中的5行3列，3行1列就应该被打上标记。
	图示：Shenandoah收集器的连接矩阵示意图.png
	
收集过程分为9个步骤：图示：Shenandoah收集器工作过程.png
1. 初始标记：标记与GC Roots直接关联的对象。停顿用户线程
2. 并发标记：遍历对象图，标记出全部可达的对象。不停顿用户线程
3. 最终标记：处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集。一小段的暂停
4. 并发清理：清理那些整个区域内连一个存活对象都没有找到的Region
5. 并发回收：**核心差异**。把回收集里面的存活对象先复制一份到其他未被使用的Region之中，并通过读屏障和“Brooks Pointer”的指针来解决对
象引用的问题。此过程取决于回收集的大小
6. 初始引用更新：把堆中所有指向旧对象的 引用修正到复制后的新地址。此过程只是确保所有并发回收阶段中进行的收集线程都分配给他们的
对象任务已完成。
7. 并发引用更新：把旧的引用改成新的引用。与用户线程并发
8. 最终引用更新：修正存在于GC Roots中的引用。停顿用户线程
9. 并发清理：整个回收集中的Region已无存活对选哪个，此过程会回收这些Region空间。
	
	brooker points：类似于句柄的方式，在GC过程中使用，在复制过程中，指向一个新引用

3.6.2 ZGC收集器

采用Region堆内存布局，且具有动态性--动态创建和销毁，以及动态的区域容量大小。
分为大、中、小三类：图示：ZGC的堆内存布局.png
	小型Region：固定容量2MB，用于存放小玉256KB的小对象
	中型Region：固定容量32MB，用于存放大于等于256KB且小玉4MB的对象
	大型Region：容量不固定，可以动态变化，但必须为2MB的整数倍，用于存放4MB或以上的大对象。每个大型Region中只会存放一个大对象，
即有可能小于中型Region，最小容量可低至4MB.

ZGC使用读屏障来实现清理过程中对象的定位。染色指针技术：图示：染色指针示意.png
染色指针是将少量额外的信息存储在指针上的技术。
优势：
	1. 一旦某个Region的存活对象被移走之后，这个Region立即就能被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后
才能清理。这使理论上只要还有一个空间Region，ZGC就能完成收集。
	2. 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量。
	3. 可以作为一种可扩展的存储结构来记录更多与对象标记、重定位过程中相关的数据，以及日后进一步提高性能。

过程分为4个步骤：图示：ZGC运行过程.png

1. 并发标记：遍历对象图做可达性分析。此阶段会更新染色指针中的Marked0、Markded1标志位
2. 并发预备重分配：根据特定的查询条件统计出本次收集过程要清理哪些Region，将这些Region组成重分配集。ZGC每次回收都会扫描所有Region
	用范围更大的扫描成本来换取省去G1中记忆集的维护成本。
3. 并发重分配：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表。记录从就对象到新对象的转向关系
	此时访问对象的话，会被预置的内存屏障接货，然后访问新的对象，并同时修正该引用的值。此过程称为“自愈”
4. 并发重映射：修正整个堆中指向重分配集中就对象的所有引用。这不是一个迫切的过程(由于并发重分配的“自愈”过程)


六 类文件结构

6.3 class类文件的结构
	图示：class文件格式.png
	采用一种类似C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数和表
	无符号数：基本的数据类型，以u1、u2、u4、u8来分别代表1、2、4、8个字节和无符号数，无符号数可以用来描述数字、索引引用、数量值或者
按照UTF-8编码构成字符串值
	表：由多个无符号数或者其他表作为数据项构成的符合数据类型，所有的表的命名习惯都由“_info”结尾。
		表用于描述有层次关系的符合结构的数据，整个class文件本质上也可以视为一张表。

**从JDK9 开始，javac编译器不再支持使用source参数编号小于1.5的源码**

6.3.2 常量池。
	常量池主要存放两大类常量：字面量和符号引用。
	字面量：如文本字符串，被声明为final的常量值等
	符号引用：属于编译原理的概念，主要包含以下几类
		1. 被模块导出或者开放的包
		2. 类和接口的全限定名
		3. 字段的名称和描述符
		4. 方法的名称和描述符
		5. 方法句柄和方法类型
		6. 动态调用点和动态常量
	图示：常量池的类型项目.png
	
6.3.3 访问标志。图示：访问标志.png
	常量池结束之后，紧接着的2个字节代表访问标志。，这个标志用于识别一些类或者接口层次的访问信息，包括：这个class是类还是接口；是否
定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final。
	
6.3.4 类索引、父类索引和接口索引集合。
	类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合interfaces是一组u2类型的数据集合，class文件中由这
三项数据来确定该类型的继承关系。

6.3.5 字段表集合
	用于描述接口或者类中生命的变量。java中的“字段”包括类级变量以及实例级变量，但不包括方法内部声明的局部变量。
	字段可以包括的修饰符有字段的作用域(public、private、protected...)、是实例变量还是类变量(static修饰)、可变性(final)、并发可见性(volatile)、
可否被序列化(transient)、字段数据类型(基本类型、对象、数组)、字段名称。
	除了是否用标志位来表示，其他用常量池中的常量来表示
	
6.3.6 方发表集合
	方法表的结构同字段表一样，依次包括访问标志、名称索引、描述符索引、属性表集合
	
6.3.7 属性表集合
	class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息
	
	1. code属性。
		在方法表的集合中，接口或抽象类中的方法就不存在code属性。
		attribute_name_index：// todo 
		max_stack：此属性中包含了操作数栈深度的最大值。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度
		max_locals：局部变量表所需的空间，单位是变量槽(slot)。存储方法参数(包括实例方法中的隐参数this)、显式异常处理程序的参数(try-catch)、
			方法体中定义的局部变量
		**操作数栈和局部变量表决定一个该方法的栈帧锁耗费的内存。变量槽可重复利用**
		code_length：代表字节码长度，和code用来存储java源码程序编译后生成的字节码指令
		code：用于存储字节码指令的一系列字节流
	2. Exceptions属性
		方法表中与code属性平级的一项，列举出方法中可能抛出的受查一行，即方法描述时在throws关键字后面列举的异常
	3. LineNumberTable属性
		用于描述java源码行好与字节码行号之间的对应关系
	4. LocalVariableTable、LocalVariableTypeTable属性
		描述栈帧中局部变量表的变量与java源码中定义变量之间的关系。
	5. SourcesFile和SourceDebugExtension属性
		SourcesFile：用于记录生成这个class文件的源码文件名称
		SourceDebugExtension：用于存储额外的代码调试信息。典型的场景就是JSP文件调试时，无法通过java堆栈来定位JSP文件的行号。
	6. ConstantValue属性
		通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量(类变量)才可以使用这项属性。不是final修饰的也具有这个属性
	7. InnerClasses属性
		用于记录内部类与宿主类之间的关联。
	8. Deprecated及Synthetic属性
		都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。
		Deprecated：用于标示某个类、字段或方法，已经被程序作者定为不再推荐使用，通过"@deprecated"进行设置
		Synthetic：由编译器自行添加。所有由不属于用户代码产生的类、方法及字段都由此设置。
	9. StackMapTable属性
		位于属性表中，在虚拟机类加载的字节码验证阶段被新类型检察验证器使用。**目的在于替代以前比较消耗性能的基于数据流分析的类型推导验证器**
	10. Signature属性
		可以出现于类、字段表和方法表结构的属性表中。任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或参数化类型，则
			Signature属性会为他记录泛型签名信息。主要是用于泛型的类型擦除。
	11. BootstrapMethods属性
		用于保存invokedynamic指令引用的引导方法限定符，位于类文件的属性表中。
	12. MethodParameters属性
		记录方法的各个形参名称和信息，主要用在方法表中的变长属性。以前的参数用arg1...表示，现在使用源码参数表示
	13. 模块化相关熟悉
		module-info.java文件的class存储
	14. 运行时注解相关属性
		包含了了RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleParameterAnnotations和RuntimeInvisibleParameterAnnotations四个属性
		RuntimeVisibleAnnotations：记录类、字段或方法的声明上记录运行时可见注解。变长属性

6.4 字节码


7 虚拟机类加载机制

7.2 类加载的时机

	生命周期：加载、验证、准备、解析、初始化、使用、卸载。图示：类的生命周期.png
	验证、准备、解析三个部分统称为连接。
	解析阶段可以在初始化阶段之再开始。
	有六种情况必须立即对类进行“初始化”(加载、验证、准备需要在此之前开始)
	1. 遇到new、getstatic、putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则需要先触发其初始化阶段。能生成
		这些字节码的场景
		1). 使用new关键字实例化对象的时候
		2). 读取或设置一个类型的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)
		3). 调用一个类型的静态方法的时候
	2. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有初始化，则需要先触发其初始化
	3. 当初始化类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
	4. 当虚拟机启动时，用户需要制定一个需要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类
	5. 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invode.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、
		REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，
	6. 当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的借口方法时)，如果有这个接口的实现类发生了初始化，那该接口
		要在其之前初始化
	
7.3 类加载过程
7.3.1 加载
	加载阶段是整个类加载过程中的一个阶段。在此阶段，java虚拟机需要完成三件事
	1. 通过一个类的全限定名来获取定义此类的二进制字节流
	2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
	3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
	
	获取二进制字节流的方法
	1. 从zip包中读取，如JAR、EAR、WAR
	2. 从网络中获取。Web Applet
	3. 运行时计算生成。动态代理技术。java.lang.reflect.Proxy中，用PRoxyGenerator.generateProxyClass()来为特定接口生成形式为"*$Proxy"
	的代理类的二进制字节流。
	4. 其他文件生成。如JSP
	5. 从数据库中读取，
	6. 从加密文件中读取。通过加载时解密Class文件来保障程序运行逻辑不被窥探
	
	数组类本身不通过类加载器创建，它是由java虚拟机直接在内存中动态构造出来的。数组类创建过程中遵循以下规则
	1. 如果数组的组件类型是引用类型，那就递归采用上面定义的加载过程去加载这个组件类型，数组建将被标识在加载该组件类型的类加载器的类
	名称空间上。
	2. 如果数组的组件类型不是引用类型(如int[]的数组组件类型为int)，java虚拟机将会把数组标记为引导类加载器关联
	3. 数组类的可访问性与他的组件的可访问性一致，如果组件类型不是引用类型，他的数组类型的可访问性将默认为public，可被所有的类和接口访问
	
	加载阶段结束后，java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区中。并且在java堆内存中实例化一个java.lang.Class类型
	的对象，这个对象将作为程勋访问方法区中的类型数据的外部接口
	
	**注**：加载阶段与连接阶段的部分动作是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。但是夹在加载阶段之中进行的动作，仍然属于
	连接阶段的一部分，这两个阶段开始时间仍然保持着固定的先后顺序。
	
7.3.2 验证
	验证是连接阶段的第一步。，这一阶段的目的是确保Class文件的字节流中包含的信息符合《java虚拟机规范》的全部约束要求，确保这些信息被当做
	代码运行后不会危害虚拟机自身的安全。
	
	主要有四个阶段
	1. 文件格式验证。主要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
		1). 是否以魔数0xCAFEBABE开头
		2). 主、次版本号是否在当前java虚拟机接受范围之内
		3). 常量池的常量中是否有不被支持的常量类型(检查常量tag标志)
		4). 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
		5). CONSTANT_Utf8——info类型的常量中是否有不符合UTF-8编码的数据
		6). Class文件中各个部分及文件本身是否有被删除的或附加的其他信息
		.......
		
	2. 元数据验证。对字节码描述的信息进行语义分析，以保证其描述的信息符合《java语言规范》的要求
		1). 这个类是否有父类。
		2). 这个类的父类是否继承了不允许被继承的类(final关键字修饰)
		3). 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
		4). 类中的字段、方法是否与父类产生矛盾(例如重写，参数不一致......)
		......
		
	3. 字节码验证。通过数据流分析和控制流分析，确定语义是合法的、符合逻辑的。对类的方法体(Class文件中的code属性)进行校验分析，保证被校验
	类的方法在运行时不会做出危害虚拟机安全的行为。
		1). 保证任意时刻操作数栈的数据结构与指定代码顺序都能配合工作，例如不会出现在操作栈放置了一个int类型的数据，使用时却按long类型来加
			载如本地变量表中
	    2). 保证任何跳转指令都不会跳转到方法体以外的字节码指令上
	    3). 保证方法体中的类型转换总是有效的。
	    4). 
	    .......
	4. 符号引用验证。发生在虚拟机将符号引用转换为直接引用的时候，这个转化将在解析阶段发生。校验以下内容
		1). 通过字符串描述的全限定名是否能找到对应的类
		2). 在指定类中是否存在符合方法的字段描述符及简单名称锁描述的方法和字段
		3). 符号引用中的类、字段、方法的可访问性(private、protected...)是否可被当前类访问

7.3.3 准备
	正式为类中定义的变量(被static修饰的静态变量)分配内存并设置类变量初始值的阶段。
	**此时进行内存分配的仅包括类变量，不包括实例变量。实例变量将在对象实例化随着对象一起分配在java堆中。
	**初始值通常情况下是数据类型的零值。零值，图示：基本数据类型的零值.png

7.3.4 解析
	将常量池内的符号引用替换为直接引用。
	**符号引用**：以一组符号来描述锁引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可
	**直接引用**：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。

1. 类或接口的解析
	假设当前代码所处的类为D，入股偶要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，主要分成以下3个步骤
	1. 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。
	2. 如果C是一个数组类型，并且数组的元数据类型为对象，那将会按照第一点的规则加载数组元数据类型，接着由虚拟机生成一个代表该维度和元素的数组对象
	3. 如果上面两步没有异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，接下来进行符号引用验证，确认D是否具备对C的访问权限。如果不
	具备访问权限，将抛出java.lang.IllegalAccessError异常。

2. 字段解析
	首先会对字段表内class_index项中索引的CONSTANT_Class_info符号进行解析，即字段所属的类或符号的引用。如果解析完成，那把这个字段所属的类或
	接口用C表示。按照如下步骤：
	1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
	2. 如果在C中实现了接口，将会按照继承关心从下往上递归搜索各个接口和他的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，
		则返回这个字段的直接引用，查找结束。
	3. 如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，
		则，返回这个字段的直接引用，查找结束。
	4. 否则，查找失败，抛出java.lang.NoSuchFieldError异常

3. 方法解析
	需要先解析出方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，那么用C表示这个类，接下来按照以下步骤进行
	1. 由于Class文件格式中类的方法和接口的的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就
		直接抛出java.lang.IncompatibleClassChangeError异常
	2. 在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束
	3. 在类C的父类中递归查找是否有简单名称和符描述符都与目标匹配的方法，如果有，则直接返回这个方法的直接引用，查找结束
	4. 在类C实现的接口列表及他们的父接口中递归查找是否有简单名称和符号描述都与目标相匹配的方法，如果存在匹配的方法，说明C是一个抽象类，
		查找结束，抛出java.lang.AbstractMethodError异常
	5. 宣告方法查找失败，抛出java.lang.NoSuchMethodError
	
	最后如果查找过程中成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备此方法的访问权限，将抛出java.lang.IllegalAccessError异常
	
4. 接口方法解析
	需要解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，那么用C表示这个类，接下来按照以下步骤进行
	1. 与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常
	2. 在接口C中查找是否有简单名称和描述符都与目标匹配的方法，如果有则返回这个方法的直接引用，查找结束
	3. 在接口C的父类中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束
	4. java的接口运行多重继承，如果C的不同父类接口中存有多个简单名称和描述符都与目标匹配的方法，那将会从多个方法中返回其中一个并结束查找。
	5. 否则，查找失败，抛出java.lang.NoSuchMethodError异常
	
7.3.5 初始化
	虚拟机开始执行java代码。执行类构造器<clinit>()方法的过程。他是javac编译器自动生成的。
	<clinit>()方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的。
	此函数不需要显示地调用父类构造器，java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕，因此第一个执行的是java.lang.Object
	<clinit>()对类或接口不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法
	// todo 接口的<clinit>()执行

7.4 类加载器
7.4.2 双亲委派模型。图示：类加载器双亲委派模型.png
	java虚拟机存在两种不同的类加载器，一种是启动类加载器(BootsrapClassLoader)，一种就是其他所有的类加载器，由java虚拟机实现
	
	启动类加载器：<JAVA_HOME>\lib
	扩展类加载器：sun.misc.Launcher$ExtClassLoader中以java代码实现负责加载\lib\ext，或者被java.ext.dirs系统变量所指定路径中的所有库
	应用程序类加载器：由sun.misc.Launcher$AppClassLoader实现。负责加载用户类路径ClassPath上所有的类库。

	**通过组合的关系来复用父加载器的代码**
	
	双亲委派模型工作过程：
	一个类加载器收到了类加载器的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每个层的类加载器都是如此，因此所有的加
		载器请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。
	
7.4.3 破坏双亲委派模型
	// todo 四次
	
7.5 java模块化系统
	定义：
	1. 依赖其他模块的列表
	2. 导出的包列表，即其他模块可以使用的列表
	3. 开放的包列表，即其他模块可以反射访问模块的列表
	4. 使用的服务列表
	5. 提供服务的实现列表
	
7.5.1 模块的兼容性


8 虚拟机字节码执行引擎
8.2 运行时栈帧结构
	java虚拟机以方法作为最基本的执行单元，"栈帧"是用于支持虚拟机进行犯法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的虚拟机栈的栈元素。
	栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。
	从java的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。
	对于执行引擎来讲，在活动线程中，只有位于栈顶的的方法才是在运行的，只有位于栈顶的栈帧才是生效的，被成为"当前栈帧"执行引擎所有运行的所有字节码指
	令都只针对当前栈帧进行操作
	图示:栈帧的概念结构.png
	
8.2.1 局部变量表
	一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
	局部变量表的容量以变量槽为最小单位。
	**局部标量表中的变量槽是可以重用的**，方法体中定义的变量，其作用于不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，
		那这个变量对应的变量槽就可以交给其他变量来重用
	
8.2.2 操作数栈
	一个后入先出的栈，在一个方法刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，即出栈和入
		栈操作。
		
8.2.3 动态连接
	每个栈帧都包含一个指向运行池常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接
	
8.2.4 方法返回地址
	当一个方法开始执行后，有两种方式退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。或者
		在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。
	方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：
	恢复上层方法的局部变量表和操作数栈，把返回值(如果有)压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。
	
8.3 方法调用	
	确定调用方法的版本(即调用哪一个方法)。

8.3.1 解析
	所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。
	这种歇息能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。
	即调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。
	符合"编译期可知，运行期不可"这个要求的方法啊，主要有静态方法和私有方法两种。因此他们都适合在类加载阶段进行解析。
	
	解析调用是一个静态过程，在编译期就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期去完成。

8.3.2 分派
	多态的提现。
	
1. 静态分派
	
````
	Human man = new Man();
````
	静态类型：Human
	实际类型：Man
	
	**虚拟机在重载时是通过参数的静态类型而不是实际类型作为判定依据**
	
	所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。最典型的就是重载。根据传入参数不同，选择不同的函数名相同的函数。静态分派发生在编译阶段。

2. 动态分派
	重写
	
3. 单分派与多分派
	单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择

````
public class Dispatcher {
    static class QQ{}
    static class _360{}
    public static class Father{
        public void hardChoice(QQ qq){
            System.out.println("father choose qq");
        }
        public void hardChoice(_360 _360){
            System.out.println("father choose 360");
        }
    }
    public static class Son extends Father{
        @Override
        public void hardChoice(QQ qq){
            System.out.println("son choose qq");
        }
        @Override
        public void hardChoice(_360 _360){
            System.out.println("son choose 360");
        }
    }
    public static void main(String[] args) {
        Father father = new Father();
        Father son = new Son();
        father.hardChoice(new _360());
        son.hardChoice(new QQ());
    }
}
----
father choose 360
son choose qq
````
	基于一个宗量来选择适合的方法。
	
4. 虚拟机动态分派的实现
	图示：方法表结构.png
	
	虚拟机方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入款和父类相同方法的地址入口是一致的，都指向
	父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。
	
8.4 动态类型语言支持
	
	java.lang.invoke包的支持
	
8.5 基于栈的字节码解释执行引擎
	// todo
	
	
	450
	
9 实战 // todo 

10 前端编译与代码优化
	前端编译器：JDK的Javac、Eclipse JDT中的增量式编译器(ECJ)
	即时编译器：HotSpot虚拟机的C1、C2编译器、Graal编译器
	提前编译器：JDK的Jaotc、GNU Compiler for the Java(GCJ)、Excelsior JET
	
	主要是指第一类编译器
	
10.2.1 javac的源码与调试
	
	// todo
	
12 java内存模型与线程
	
	
	
	
	
	
596

























