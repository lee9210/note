2.2 运行时数据区域。图示：图2-1.png

1). 方法区。线程共享的内存区域。图示：方法区保存信息.png
		用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译期编译后的代码缓存等数据。别名"非堆"。(class的元数据就保存在此区间)
	a). 运行时常量池。
		方法区间的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的
	各种字面量与符号引用，这部分内容将在类加载后放到方法区的运行池常量池中。
	当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。
	
2). 虚拟机栈。线程私有
		
		为虚拟机执行java方法(即字节码)服务。生命周期与线程相同。
		每个方法被执行的时候，java虚拟机都会同步创建一个栈帧，用于存储：局部变量表、操作数栈、动态链接、方法出口等信息。
		每个方法被调用直至执行完毕的过程，就对应一个栈帧在虚拟机中从入栈到出栈的过程。
		局部变量表保存了编译期可知的各种java虚拟机基本数据类型(8种)、对象引用(reference类型)和returnAddress类型(指向了一条字节
	码指令的地址)。这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示。局部变量表所需的内存空间在编译期间完成，当进入
	一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小(Slot数量)
	注：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果java虚拟机栈容量可以动态扩展，当无法申请到
	足够的内存时，则抛出OutOfMemoryError异常。
	
3). 本地方法栈。线程私有
		为虚拟机使用到的本地(Native)方法服务
		hotspot虚拟机直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，也会抛出StackOverflowError异常和OutOfMemoryError异常。
	
4). 堆
		被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。
		从内存分配角度来看，所有线程共享java堆中可以划分出多个线程私有的分配缓冲区(TLAB)，
		java堆可以处于物理上不连续的内存空间中，但在逻辑上，它应该被视为连续的。
		java堆即可以被实现成固定大小的，也可以是扩展的(参数-Xmx和-Xms设定)。如果在java堆中没有内存完成实例分配，并且堆也无法再
	扩展时，java虚拟机将会抛出OutOfMemoryError异常。
		
5). 程序计数器。线程私有
		程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器
	的值来选取下一条需要执行的字节码指令。他是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖
	这个计数器来完成。
		多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的。一个处理器都只会执行一条线程中的指令。为了切换后能恢复到正
	确的执行位置，每个线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。
		如果正在执行的是本地(Native)方法，这个计数器值则为空(Undefined)
		
6). 执行引擎
	充当了将高级语言翻译为机器语言的译者。
7). 本地库接口
8). 本地方法库

2.2.7 直接内存
	NIO：基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的
DirectByteBuffer对象作为这块内存的引用进行操作。避免了在java堆和Native堆中来回复制数据。
	动态扩展时也会抛出OutOfMemoryError异常。

2.3 对象
2.3.1 对象的创建

1. 当java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引
用代表的代表的类是否已被加载解析和初始化过，如果没有，那必须先执行相应的类加载过程。

2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便完全确定。分配过程中，就相当于把一
块确定大小的内存块从java堆中划分出来。// todo 分配方式

3. 内存分配完成之后，虚拟机必须将分配到的内存空间(不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB
分配时顺便进行。

4. 接下来，java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC
分代年龄等信息。这些信息存放在对象的对象头中。根据虚拟机当前运行状态的不同，如是否启用偏向锁，对象头会有不同的设置方式。

5. new指令之后会接着执行<init>()方法，对对象进行初始化

2.3.2 对象的内存布局
	在hotspot虚拟机中，对象在内存中的存储布局可以划分为三个部分:对象头(Header)、实例数据(Instance Data)、和对齐填充(Padding)
	
	对象头部分包含两类信息。第一类是用于存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向
时间戳等。这部分称为Mark Word。图示：HotSpot虚拟机对象头Mark Word.png
	对象头的另一部分是类型指针，即指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例
	如果对象是一个数组，在对象头中还必须有一块用于记录数组长度的数据。
	
	实例数据部分是对象真正存储的有效信息，即程序代码里面所定义的各种类型的字段内容，无论是从父类集成下来的，还是子类中定义的
	
	对其填充不是特别必要，仅仅起着占位符的作用。

2.3.3 对象的访问定位
	句柄访问：java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型
数据各自具体的地址信息。图示：通过句柄访问对象.png

	指针访问：java堆中对象的内存布局就必须考虑如何防止访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问
对象本身的话，就不需要多一次间接访问的开销。图示：通过直接指针访问对象.png

	优劣：
	使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集)时，只会改变句柄中的实例数据指针，而referece
本身不需要被修改
	使用直接指针的最大好处就是速度快，它节省了一次指针定位的时间开销。**hotspot使用的就是这种方式**
	
	
3.2.2 可达性分析算法
	通过一系列称为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系，向下搜索，搜索过程所走过的路径称为"引用链"，
如果某个对象到GC Roots间没有任何引用链相连，或者从GC Roots到这个对象不可达时，则证明此对象不可能再被使用的。图示:可达性分析算法判断对象是否可回收.png

**GC Roots**
1. 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
2. 在方法区中类静态属性引用的对象。如java类的引用类型静态变量
3. 在方法区中常量引用的对象，如字符串常量池(String table)里的引用
4. 在本地方法栈中JNI(Native方法)引用的对象
5. java虚拟机内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象(如NullPointException)等，还有系统类加载器
6. 所有被同步锁(synchronized关键字)持有的对象
7. 反应java虚拟机内部情况的JMXBean、JVMTI中注册的回调，本地代码缓存等

3.2.3 引用
	强引用、软引用、弱引用、虚引用。四种引用强度依次减弱
	
1. 强引用
	在程序代码中普遍存在的引用赋值，即类似"Object obj = new Object()"这种引用关系。无论在任何情况下，只要强引用关系还在，垃圾
收集器就不会回收被引用的对象。

2. 软引用
	还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，
如果这次回收还没有足够的内存，才会抛出内存溢出异常。

3. 弱引用
	非必须对象，比软引用更弱一下，被弱引用关联的对象能生存到下一次垃圾收集器发生为止。当垃圾收集器开始工作，无论当前内存是否足
够，都会回收掉只被弱引用关联的对象

4. 虚引用
	一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯
一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

3.2.5 回收方法区
	方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。
	常量池回收类似对象，不再引用的直接回收
	
	"不再使用的类"需要满足三个条件
	1. 该类的所有实例都已经被回收，即java堆中不存在该类及其任何派生子类的实例
	2. 加载该类的类加载器已经被回收。这个除非是可替换类加载器的场景，如OSGi、JSP的重加载等，通常很难达成
	3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
	
	满足上面三个条件，仅仅是被允许，而不是必然回收。

3.3 垃圾收集算法

3.3.1 分代收集理论
1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
3. 跨代引用假说：新生代引用老年代内的对象或老年代引用新生代的对象。存在相互引用的关系的两个对象，是应该倾向于同时生存或消亡的

部分收集
1. 新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集
2. 老年代收集(Major GC/Old GC):目标只是老年代的垃圾收集
3. 混合收集(Mixed GC):指目标是收整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为
4. 整堆收集(Full GC):收集整个java堆和方法去的垃圾收集
	
3.3.2 标记-清除算法。图示：标记-清除算法示意图.png
	分为两个阶段：标记和清除。首先标记出素有需要回收的对象，在标记完成后，统一回收掉被标记的对象，也可以反过来。

3.3.3 标记-复制算法。图示：标记-复制算法示意图.png
	将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存永王了，就将还存活着的对象复制到另外一块上面，然后
再把已使用过的内存空间一次清理掉。
	如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但是对于多数对象都是可回收的情况，算法需要复制就占少
数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑空间碎片的复杂情况。但是有一半的空间浪费
	
	标记-复制算法在对象存活率较高时要进行较多的复制操作，效率将会降低。如果不想浪费50%的空间，就需要有额外的空间进行分配担保，
以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代不采用这种算法。

3.3.4 标记-整理算法。图示：标记-整理算法示意图.png
	老年代采用此算法。
	其过程与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理
掉边界以外的内存。

3.4 HotSpot算法实现
3.4.1 根节点枚举
	所有收集器在枚举根节点时都必须"stop the world"。
	HotSpot使用OopMap的数据结构来获取哪些地方存放着对象引用。因此不用真正一个不漏的从方法区等GC Roots开始查找

3.4.2 安全点
	安全点位置的选取基本上是以"是否具有让程序长时间执行的特征"为标准进行选定的。
	"长时间执行"的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令
才会产生安全点。
	让线程跑到最近的安全点，然后停顿下来有两种方案：抢先中断式和主动中断式。
	抢先中断：不需要线程的执行代码主动配合，在垃圾收集发生时，首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点
上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上（这个方式没有使用）
	主动中断：不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程会不停地主动去轮训这个标志，一旦发现中断标致为真，就自
己在最近的安全点上主动挂起。
	
	程序没有分配处理器时间时。如用户线程处于sleep或blckked状态，这时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起
自己。需要用安全区域解决

3.4.3 安全区域
	在某一段打码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。即安全区域是被拉伸了的安全点。
	当用户线程执行到安全区域时，首先会标识自己进入安全区域，当这段时间里虚拟机要发起垃圾收集时就不必取关这些已声明自己在安全区域
的线程，当线程要离开安全区域时，要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)，如果完成了，
继续执行，否则等待。

3.4.4 记忆集与卡表
	为了解决对象跨代引用的问题，垃圾收集器在新生代中建立记忆集的数据结构，用以避免把整个老年代加进GC Roots扫描范围。
	记忆集用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。
	记录精度分为：字长精度、对象精度、卡精度。卡表就是以卡精度实现的记忆集。
	卡精度：每个记录精确到一块内存区域，该区域内含有对象含有跨代指针
	
	// todo
	
3.4.5 写屏障
	// todo
	
3.4.6 并发的可达性分析
	三色标记。图示；三色分析流程.png
	白色：表示对象尚未被垃圾收集器访问过。在可达性分析刚开始的阶段，所有的对象都是白色的，若在分析结束阶段，仍是白色，即代表不可达
	黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对
象引用指向了黑色对象，无需重新扫描。黑色对象不可直接（不经过灰色对象）指向某个白色对象
	灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过
	
	“对象消失”的两个条件
	1. 赋值器插入了一条或多条从黑色到白色对象的新引用
	2. 赋值器删除了全部从灰色对象到白色对象的直接或间接引用
	
	要解决并发扫描时的对象消失问题，只需破坏这两个条件中的任意一个即可。因此有两种解决方案：增量更新和原始原始快照。
	
	增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束后，再将
这些记录过的引用关系中的黑色对象为根，重新扫描一次。即：黑色对象一旦新插入了指向白色对象的引用后，他就变回灰色对象
	
	原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将
这些记录过引用关系中的灰色对象为根，重新扫描一次。即：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来搜索。
	
3.5 经典垃圾收集器：图示：HotSpot虚拟机的垃圾收集器.png

tips：
并行：多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态
并发：垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务
请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理和吞吐量受到一定影响

Parallel Scavenge和CMS等收集器的区别
CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间
Parallel Scavenge的目标是达到一个可控制的吞吐量。吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间)
 
3.5.1 Serial收集器。图示：Serial+Serial Old收集器运行示意图.png
	一个单线程工作的收集器。在工作时，必须暂停其他所有工作线程，直到收集结束。

3.5.2 ParNew收集器。图示：ParNew收集器运行示意图.png
	Serial收集器多线程版本。
	
3.5.3 Parallel Scavenge收集器
	基于“标记-复制”算法，能并行收集的多线程收集器。注重吞吐量

3.5.5 Parallel Old收集器
	基于“标记-复制”算法，能并行收集的多线程收集器。
	
3.5.6 CMS收集器。图示：CMS收集器运行示意图.png
	以最短回收停顿为目标的收集器。基于“标记-清除”算法实现
	分为四个步骤
		1. 初始标记(需要全局暂停)。标记一下GC Roots能直接关联到的对象
		2. 并发标记。从GC Roots的直接关联对象开始遍历整个对象图的过程，不需要停顿用户线程
		3. 重新标记(需要全局暂停)。修正并发标记期间，因用户程序继续运行而产生的变动那一部分对象的标记记录。
		4. 并发清除。清理标记阶段判断的已经死亡过的对象。
		
	优点：并发收集、低停顿。
	缺点：
		1. 对处理器资源非常敏感。会占用用户线程资源，导致程序变慢
		2. 无法处理“浮动垃圾”，有可能出现"current mode failure"而导致Full GC。在并发标记和并发清理阶段，用户线程还
	是在继续运行的，因此会有新的垃圾产生，CMS无法在档次回收中处理掉他们，只能留到下次。
		3. 基于“标记-清除”算法实现，会有大量空间水平产生。
		
3.5.7 G1收集器
	主要是面向服务端应用的垃圾收集器。
	把java堆划分为多个大小相等的独立区域(Region)，每个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或老年代空间。收集
器能够对扮演不同角色的Region采用不同的策略去处理。图示:G1收集器Region分布示意图.png
	Region中还有一类特殊的Humogous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。将会被存
放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来看待。
	
	G1会在后台维护一个优先级列表，此列表保存各个Region里面的垃圾堆的“价值”大小，优先处理回收加载收益最大的Region
	G1使用记忆集避免全堆作为GC Roots扫描，每个Region都维护有自己的记忆集。这些记忆集会记录下别的Region指向自己的指针，并标记这些指
针分别在哪些卡页范围内。是一种双向结构。
	G1采用**原始快照**方法来解决标记结果出现错误。
	
收集过程：图示：G1收集器运行示意图.png
1. 初始标记：仅仅只是标记一下GC Roots能直接关联的对象，并且修改(原始快照)TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用
的Region中分配新对象。需要停顿用户线程
2. 从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。对象图扫描完成以后，还要重新处理SATB记录下的
在并发期间引用变动的对象。不需要停顿用户线程。不需要停顿用户线程。
3. 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录
4. 筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所戚薇的停顿时间来制定回收计划，可以自由选择任
意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。需要暂停用户线程。
	

3.6 低延迟垃圾收集器
	衡量垃圾收集器的三项最重要的指标是：内存占用、吞吐量和低延迟，不可能同时满足三项条件。
	
3.6.1 Shenandoah收集器
	类似G1，使用Region的堆内存布局，存放大对象的Humongous Region，回收策略同样优先处理回收价值最大的Region
	采用整理算法实现。不会有新生代Region和老年代Region的划分，采用“连接矩阵”的全局数据结构来记录跨Region的引用关系降低了处理跨代指
针的记忆集维护消耗。
	“连接矩阵”可以理解为一张二维表格，如果Region N 有对象指向了Region M，就在表格的N行M列中打上一个标记，如果Region 5中的对象Baz引
用指向了Region 3 的Foo，Foo又引用了Region 1 的Bar，那“连接矩阵”中的5行3列，3行1列就应该被打上标记。
	图示：Shenandoah收集器的连接矩阵示意图.png
	
收集过程分为9个步骤：图示：Shenandoah收集器工作过程.png
1. 初始标记：标记与GC Roots直接关联的对象。停顿用户线程
2. 并发标记：遍历对象图，标记出全部可达的对象。不停顿用户线程
3. 最终标记：处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集。一小段的暂停
4. 并发清理：清理那些整个区域内连一个存活对象都没有找到的Region
5. 并发回收：**核心差异**。把回收集里面的存活对象先复制一份到其他未被使用的Region之中，并通过读屏障和“Brooks Pointer”的指针来解决对
象引用的问题。此过程取决于回收集的大小
6. 初始引用更新：把堆中所有指向旧对象的 引用修正到复制后的新地址。此过程只是确保所有并发回收阶段中进行的收集线程都分配给他们的
对象任务已完成。
7. 并发引用更新：把旧的引用改成新的引用。与用户线程并发
8. 最终引用更新：修正存在于GC Roots中的引用。停顿用户线程
9. 并发清理：整个回收集中的Region已无存活对选哪个，此过程会回收这些Region空间。
	
	brooker points：类似于句柄的方式，在GC过程中使用，在复制过程中，指向一个新引用

3.6.2 ZGC收集器

	
	
	
163

























