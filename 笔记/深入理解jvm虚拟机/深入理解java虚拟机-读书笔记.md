### 回收方法区 ###
判断一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面三个条件才能算是“无用的类”：
- 该类所有的实例都已经回收，也就是java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。

在大量使用反射、动态代理CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

## 垃圾收集算法 ##
### 标记-清除算法 ###
算法分为“标记”和“清除”两个阶段：
1. 首先标记出所有需要回收的对象。
2. 在标记完成后统一回收所有被标记的对象。

不足主要有两个：
1. 效率问题，标记和清除是两个过程，效率都不高；
2. 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分片较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 复制算法 ###
为解决效率问题，出现了复制算法。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就讲还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂状况，只要一动堆顶指针，按顺序分配内存即可。代价是将内存缩小为了原来的一半。

#### 标记-整理算法 ####
标记过程与“标记-清除”算法一样，但后续不走不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

## HotSpot垃圾收集算法实现 ##
### 枚举根节点 ###
从可达性分析中从GC Roots节点找到引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中。
领另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话，分析结果准确性就无法得到保证。这点事导致GC进行时必须停顿所有java执行线程的一个原因。
在HotSpot中，有一组称为OopMap的数据结构来存放对象的引用。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中那些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。 	

### 安全点 ###
需要考虑一个问题就是如何在GC发生时，让所有线程都“跑”到最近的安全点上停顿下来。有两种方案可供选择：抢先中断式和主动中断式。
抢先中断式不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑到安全点上”。现在几乎没有虚拟机实现采用抢先中断来暂停线程从而响应GC事件。
主动中断式的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真时就自己中断挂起。轮询标志和安全点是重合的，另外再加上创建对象需要分配内存的地方。

### 安全区域 ###
安全区域是指在一段代码中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。可以被看做是扩展的safepoint。

## 垃圾收集器 ##
### Serial收集器 ###
Serial收集器一个单线程的收集器，只会使用一个cpu或者一条线程去完成收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

### ParNew收集器 ###
ParNew收集器就是Serial收集器的多线程版本。

### Parallel Scavenge收集器 ###
Parallel Scavenge收集器是一个新生代收集器。Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)
可以通过设置开关，使不需要设置新生代代销，晋升老年代年龄等参数。称为GC自适应的调节策略。

### Serial Old收集器 ###
Serial Old收集器是Serial收集器的老年代版本。使用“标记-整理算法”

### Parallel Old收集器 ###
Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。

### CMS收集器 ###
CMS收集器是一种以获取最短回收停顿时间为目标的收集器。重视服务器响应速度，希望系统挺短时间最短，可以给用户带来较好的体验。整个过程分为4个步骤，包括：
- 初始标记
- 并发标记
- 重新标记
- 并发清除

初始标记和重新标记，需要停止线程。初始标记只是标记一下GC Roots能直接关联到的对象，速断很快。并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记发生变动那一部分对象的标记记录，这个阶段的挺多时间一般会比初始标记阶段稍长一些，但远比并发表及的时间短。
缺点
1. 占用cpu资源
2. 无法处理浮动垃圾
3. 基于“标记——清除”算法实现，会产生大量空间碎片。

### G1收集器 ###
面向服务端应用的垃圾收集器。与其他收集器相比，G1有如下特：
- 并发与并行
- 分代收集
- 空间整合
- 可预测的停顿

G1收集器将整个java堆划分为多个大小相等的独立区域，虽然保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，他们是一部分region的集合。
G1可以有计划的避免在整个java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据运行的手机时间，有限回收垃圾最大的region。这种使用region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
G1把内存“化整为零”。

在G1收集器中，region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference应用的对象是否处于不同的Regionzhong,如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描，也不会有遗漏。

G1收集器的大致运作可划分为以下几个步骤
1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

因为回收的只是一部分region，时间是可控的。


## 内存分配与回收策略 ##
### 对象优先在Eden分配 ###
大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.

### 大对象直接分配到老年代 ###
大对象指的是需要大量连续内存空间的java对象，最典型的是很长的字符串以及数组（例如byte数组）。

### 长期存活的对象进入老年代 ###
虚拟机给每个对象定义了一个对象年龄（age）计数器。超过一定年龄的进入老年代（默认为15）

### 动态对象年龄判定 ###
如果在survivor空间中相同年龄所有对象大小的综合大于survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代。

### 空间分配担保 ###
在发生minor GC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么minor GC是可以确保安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次minor GC,尽管这次minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许毛线，那这时要改为进行一次Full GC.

# 虚拟机新能监控与故障处理工具 #
## JDK的命令行工具 ##

sun jdk监控和故障处理工具

<table>
	<tr>
		<th>名称</th>
		<th>主要作用</th>
	</tr>
	<tr>
		<th>jps</th>
		<th>JVM Process Status Tool,显示指定系统内所又的HotSpot虚拟机进程</th>
	</tr>
	<tr>
		<th>jstat</th>
		<th>JVM Statistics Monitoring Tool,用于手机HotSpot虚拟机各方面的运行数据</th>
	</tr>
	<tr>
		<th>jinfo</th>
		<th>Configuration Info for Java,显示虚拟机配置信息</th>
	</tr>
	<tr>
		<th>jmap</th>
		<th>Memory Map for Java,生成虚拟机的内存转储快照（heapdump文件）</th>
	</tr>
	<tr>
		<th>jhat</th>
		<th>JVM Heap Dump Browser,用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</th>
	</tr>
	<tr>
		<th>jstack</th>
		<th>Stack Trace for Java,显示虚拟机的线程快照</th>
	</tr>
</table>

### jps：虚拟机进程状况工具 ###

### jstat：虚拟机统计信息监视工具 ###
用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。

### jinfo：java配置信息工具 ###
实时查看和调整虚拟机各项参数。

### jmap：java内存映象工具 ###
用于生成堆转储快照。

### jstack：java堆栈跟踪工具 ###
用于生成虚拟机当前时刻的线程快照。线程快照是当前虚拟机内每一条线程正在执行的方法的堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致长时间等待等都是导致线程长时间停顿的常见原因。


# 虚拟机类加载机制 #
虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。这就是虚拟机的类加载机制。

## 类加载的时机 ##
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备、解析三个部分称为连接。

对于类的初始化，下面5中情况必须立即对类进行初始化。
1. 遇到new、getstatic、putstatic或invokestatic字节码指令时，如果类没有进行初始化，需要首先触发其初始化。常见的java代码场景是：使用new 关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个雷的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
4. 当虚拟机启动时，用户需要制定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类
5. 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法所对应的类没有进行过初始化，则需要先触发其初始化。

## 类加载的过程 ##

### 加载 ###
在加载阶段，虚拟机需要完成：
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区在这个类的各种数据的访问入口。

获取二进制字节流有不通的获取方法
- 从zip包中读取，或者从jar、war包中读取
- 从网络中读取
- 计算机计算生成，使用最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。
- 其他文件生成，例如JSP应用
- 从数据库读取

类加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过自定义的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。

数组类本身不通过类加载器创建，它是由java虚拟机直接创建的。

在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。

#### 验证 ####
验证的目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

验证阶段会完成4个步骤：
1. 文件格式验证。验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
2. 元数据验证。对字节码描述的信息进行语义分析，以保证描述的信息符合java语言规范的要求。保证不存在不符合java语言规范的元数据信息。
3. 字节码验证。主要目的是通过数据流和控制流分析，确定程序语义是合法的的，符合逻辑的。保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
4. 符号引用。可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。

### 准备 ###
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
这时候进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。并且初始值“通常情况”下是数据类型的零值。例如：
````
public static int value = 123;
````
那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令时程序被编译后，存放于类构造器<clint>()方法中，所以把value赋值为123的动作将会在初始化阶段才会执行。
如果定义了final关键字。例如：
````
public static final int value = 123;
````
编译时value生成ConstantValue属性，在准备阶段虚拟机就会把value赋值为123。

### 解析 ###
解析阶段是虚拟机将常量池内的符号引用替换为直接应用的过程。

符号引用：符号引用是以一组符号来描述所引用的目标。
直接引用：直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定7个符号引用进行。

1. 类或接口的解析。主要分为3个步骤。假设当前代码所处的类为D，如果要把一个从未解析过的符号应用N解析为一个类或接口C的直接引用，主要需要一下3个步骤。
	1. 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证，字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载古城出现了任何异常，解析过程就宣告失败。
	2. 如果C是一个数组类型，并且数组的元素类型为对象，那将会按照1的规则加载数组元素类型。接着由虚拟机生成一个代表此数组维度和元素的数组对象。
	3. 解析完成之后还要进行符号引用验证，确认D是否具备对C的访问权限。
2. 字段解析。首先解析字段所属的类或接口的符号引用。


### 初始化 ###
根据程序员通过程序制定的主管计划去初始化类变量和其他资源。



## 类加载器 ##
通过一个类的全限定名来获取描述此类的二进制字节流

````
public class ClassLoaderTest {
	public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
	    ClassLoaderTest loaderTest = new ClassLoaderTest();
		ClassLoader myLoader = new ClassLoader(){
			@Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
				try {
					String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class";
					InputStream is = getClass().getResourceAsStream(fileName);
					if (is == null) {
						return super.loadClass(name);
					}
					byte[] b = new byte[is.available()];
					is.read(b);
					return defineClass(name,b,0,b.length);
				} catch (IOException e) {
					throw new ClassNotFoundException(name);
				}
			}
		};
		Object obj = myLoader.loadClass("com.test.abc.ClassLoaderTest").newInstance();
		System.out.println(obj.getClass());
		System.out.println(obj instanceof com.test.abc.ClassLoaderTest);
		System.out.println(loaderTest instanceof com.test.abc.ClassLoaderTest);
	}
}

````
输出结果：
````
class com.test.abc.ClassLoaderTest
false
true
````
从第一句输出可以看出，对象是com.test.abc.ClassLoaderTest实例化出来的对象。
第二句false是因为虚拟机中存在两个ClassLoaderTest类，一个是由系统应用程序加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都是同一个Class文件，但依然是两个独立的类。
第三句true是因为系统程序加载器加载的，是同一个对象，所以为true。

### 双亲委派模型 ###
从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader）,是虚拟机自身的一部分；另外一种就是其他的类加载器，这些类加载器都是由java语言实现，独立于虚拟机外部，且全部都继承自抽象类java.lang.ClassLoader.
从java程序员来说，有三种系统提供的类加载器。
1. 启动类加载器（Bootstrap ClassLoader）:启动类加载器无法被java程序直接引用，负责加载\lib目录中的类库加载到虚拟机内存中。用户在编写自动以加载器时，如果需要把加载请求委派给引导类加载器，直接用null代替。
2. 扩展类加载器（Extension ClassLoader）:这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载\lib\ext目录中的所有类库
3. 应用程序类加载器（Application ClassLoader）:这个类加载器由sun.misc.Launcher$AppClassLoader实现。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。

双亲委派魔心要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是使用组合关系来复用父加载的代码

工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围没有找打所需的类）时，子加载器才会尝试自己去加载。


好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种累加载器环境都是同一个类。

# 虚拟机字节码执行引擎 #
## 运行时栈帧结构 ##
栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法放回地址等信息。每个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
每一个栈帧都包括了局部变量表、操作数栈、动态链接和方法放回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定，并且写入到方法表的code属性中。因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

### 局部变量表 ###
局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

### 操作数栈 ###
操作数栈，是一个后入先出栈。当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取。或者在调用其他方法的时候是通过操作数栈来进行参数传递的。

### 动态链接 ###
运行期转化的符号引用

### 方法返回地址 ###
当一个方法开始执行后，只有两种方法可以退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令，有可能会有返回值传递给上层的方法调用者。另一种是遇到了异常，只要本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。

退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压如调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令

## 方法调用 ##
方法调用不等同于方法执行，方法调用节点唯一的任务就是确定被调用方法的版本（即调用哪个方法），暂时还不设计方法内部的具体运行过程。

### 解析 ###
所有方法调用中的目标方法在class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。

### 分派 ###
在方法调用过程中多态特性的体现。

#### 静态分派 ####
这个分派体现了重载。
编译器在运行前只知道一个对象的静态类型，并不知道对象的实际类型。
虚拟机方法调用时，他会直接使用静态类型进行匹配，也就是说：重载时是通过参数的静态类型而不是实际类型作为判定依据。并且静态类型是在编译期可知的，因此在编译阶段，javac编译器就可以根据参数类型确定具体使用哪个重载版本。
- 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。
- 静态分派的典型应用就是方法重载。
- 静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。

#### 动态分派 ####
这个分派体现了重写
主要和invokevirtual方法调用字节码有关，运行过程如下：
1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C；
2. 在C中寻找与常量中的描述符合简单名都一直的方法，进行权限校验，如通过则返回这个方法的直接引用，查找结束；如果不通过，返回异常。
3. 否则，按照继承关系从下往上依次对C的各个父类进行第二部搜索和验证。
4. 如果始终没有找到合适的方法，则抛出异常。




123