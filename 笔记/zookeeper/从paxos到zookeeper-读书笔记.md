#### 一致性级别 ####
**强一致性**  
这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验最好，但实现起来往往对系统的性能影响比较大。

**弱一致性**  
这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不具体承诺多久之后数据能够达到一致状态。弱一致性还可以进行细分：

- 会话一致性:该一致性级别只保证对于写入的值，在同一个客户端会话中可以读到一致的值，但其他的会话不能保证。
- 用户一致性:该一致性级别只保证对于写入的值，在同一个用户中可以读到一致的值，但其他用户不能保证。

**最终一致性**  
最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为他是弱一致性中非常重要的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型。

#### 事务隔离级别 ####
事务隔离级别对比
<table>
	<tr>
		<th>隔离级别</th>
		<th>脏读</th>
		<th>可重复读</th>
		<th>幻读</th>
	</tr>
	<tr>
		<td>读取未提交</td>
		<td>存在</td>
		<td>不可以</td>
		<td>存在</td>
	</tr>
	<tr>
		<td>可重复读</td>
		<td>不存在</td>
		<td>可以</td>
		<td>存在</td>
	</tr>
	<tr>
		<td>串行化</td>
		<td>不存在</td>
		<td>可以</td>
		<td>不存在</td>
	</tr>
</table>

#### CAP定理 ####
一个分布式系统不可能同时满足一致性（C:consistency）、可用性（A:Availability）和分区容错性（P：partition tolerance）这三个基本需求，最多只能同时满足其中的两项。  
**一致性**  
在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性。在一致性需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。  
**可用性**  
可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。  
“有限的时间”是指对于用户的一个操作请求，系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。另外，“有限的时间内”是在一个系统设计之初就设定好的系统运行指标，通常不同的系统之间会有很大的不同。  
“返回结果”是可用性的另外一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确的反映出对请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。  
**分区容错性**  
分区容错性约束了一个分布式系统需要有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性的可用性的服务，除非是整个网络环境都发生了故障。  
网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络等）中，由于一些特殊的原因导致这些子网络之间出现网络不联通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。

#### CAP定理应用 ####
<table>
	<tr>
		<th>放弃CAP定理</th>
		<th>说明</th>
	</tr>
	<tr>
		<td>放弃P</td>
		<td>如果希望能够避免系统出现分区容错性问题，一种较为简单的做法是将所有的锁具（或者仅仅是与实务相关的数据）都放在一个分布式节点上。这样的做法虽然无法100%地保证系统不会出错，但至少不会碰到由于网络分区带来的负面影响。但同时需要注意的是，放弃P的同时也就意味着放弃了系统的可扩展性</td>
	</tr>
	<tr>
		<td>放弃A</td>
		<td>相对于放弃“分区容错性”来说，放弃可用性则正好相反，其做法是一旦系统遇到网络分区或其他故障时，那么收到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供正常的服务，即不可用</td>
	</tr>
	<tr>
		<td>放弃C</td>
		<td>这里所说的放弃一致性，并不是完全不需要数据一致性，如果真是这样的话，那么系统的数据都是没有意义的，整个系统也是没有价值的。事实上，放弃一致性指的是放弃数据的强一致性，而保留数据的最终一致性。这样的系统无法保证数据保持实时的一致性，但是能够承诺的是，数据最终会达到一个一致的状态。这就引入了一个时间窗口的概念，具体多久能够达到数据一致取决于系统的设计，抓药包括数据副本在不同节点之间的复制时间长短</td>
	</tr>
</table>

#### BASE ####
BASE是对CAP中一致性和可用性权衡的结果，是依据CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

**基本可用**  
基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但这绝不等价于系统不可用。

- 响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到1~2秒
- 功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。  

**弱状态**  
弱状态也被称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。

**最终一致性**  
最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。

#### 2PC ####
二阶段提交，使基于分布式系统架构下的所有节点在进行实物处理过程中能够保持原子性和一致性而设计的一种算法。

其执行流程如下：  

**阶段一：提交事务请求**  

1. 事务询问：协调者想所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。  
2. 执行事务：由参与者节点执行事务操作，并将undo和redo信息记入事务日志中。
3. 各参与者想协调者反馈事务询问的响应。如果参与者成功执行了事务操作，那么久反馈给协调者yes响应，表示事务可以执行；如果参与者没有成功执行事务，那么久反馈给协调者no响应，表示事务不可以执行。

这一阶段也被称为投票阶段，即各参与者投票表面是否要继续执行接下去的事务提交操作。

**阶段二：执行事务提交**  

在阶段二中，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，包含两种情况。  

**执行事务提交**  
如果协调者的参与者获得的反馈都是yes，那么就会执行事务提交    

1. 发送请求：协调者想所有参与者节点发出commit请求
2. 事务提交：参与者接收到commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。
3. 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送ack消息
4. 完成事务：协调者接收到所有参与者反馈的ACK消息后，完成事务。

**中断事务**
加入任何一个参与者向协调者反馈了no响应，或者在等待超时之后，协调者无法接收到所有参与者的反馈响应，那么就会中断事务。

1. 发送回滚请求：协调者向所有参与者节点发送rollback请求。
2. 事务回滚：参与者接收到rollback请求后，会利用其在阶段一种记录的undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。
3. 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送ack消息。
4. 中断事务：协调者接收到所有参与者反馈的ack消息后，完成事务中断。

**优缺点**  
优点：原理简单，实现方便  
缺点：同步阻塞、单点问题、脑裂、太保守

**同步阻塞**  
在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态。  

**单点问题**  
协调者的角色在整个提交过程中有非常重要的作用，如果出了问题，那么在阶段二中参与者将会一直处于锁定事务资源的状态，无法继续完成事务操作。

**数据不一致**  
在阶段二中，提交事务的时候，当协调者发送commit请求之后，发生局部网络异常，或者协调者在尚未发送完commit请求之前自身发生了崩溃，导致最终只有部分参与者收到commit请求，于是这部分收到了commit请求的参与者就会进行事务的提交，而其他没有收到commit请求的参与者无法进行事务提交，整个分布式系统便会出现数据不一致现象。

**太过保守**  
二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。

#### 3PC ####
2PC的改进版，将二阶段提交协议的“提交事务请求”过程一分为二，形成CanCommit,PreCommit和DoCommit三个阶段组成的事务处理协议。

**阶段一：CanCommit**  

1. 事务询问：协调者像所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。
2. 各参与者向协调者反馈事务询问的响应：参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，会反馈yes响应，并进入预备状态，否则反馈no

**阶段二：PreCommit**  

正常情况下，包含两种可能  
**执行事务预提交**  
所有参与者都反馈yes，就会执行事务预提交。
  
1. 发送预提交请求。协调者想所有参与者节点发出PreCommit请求，并进入Prepared阶段
2. 事务预提交。参与者接收到PreCommit请求后，会执行实务操作，并将Undo和Redo信息记录到事务日志中
3. 各参与者向协调者反馈事务执行的响应。如果参与者成功执行了事务操作，那么就会反馈给协调者ACK响应，同时等待最终的指令：提交（commit）或终止（abort）

**中断事务**  
如果任何一个参与者反馈no响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，就会中断事务。

1. 发送中断请求。协调者向所有参与者节点发出abort请求。
2. 中断事务。无论是收到协调者的abort请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务。

**阶段三：doCommit**  
此阶段将进行真正的事务提交，会存在以下两种可能。  

**执行提交**
  
1. 发送提交请求。协调者接收到了来自所有参与者的ACK响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发送doCommit请求。
2. 事务提交。参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。
3. 反馈事务提交结果。完成事务提交后，向协调者发送ACK消息
4. 完成事务。协调者接受反馈的ACK，完成事务

**中断事务**  

1. 发送中断请求。协调者向所有参与则节点发送abort请求
2. 事务回滚。参与者接收到abort请求后，会利用其在阶段二中记录的undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。
3. 反馈事务回滚结果。完成回滚后，向协调者发送ACK消息
4. 中断事务。协调者接收ACK后，中断事务。

**优缺点**  
优点：相较于二阶段提交协议，三阶段提交协议最大的优点是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。  
缺点：参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，必然出现数据的不一致性。

### Paxos算法 ###
Paxos算法需要解决的问题就是如何在一个可能发生异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生任何情况都不会破坏系统的一致性。

参考：https://www.jdon.com/artichect/paxos.html


### Chubby ###

Chubb的整个系统结构主要由服务端和客户端两部分组成，客户端通过RPC调用与服务端进行通讯。  
服务器通过paxos协议，通过投票的方式选举产生一个通过半投票的服务器作为master。一旦某台服务器成为了master，chubby就会保证在一段时间期内不会再有其他服务器称为master——这段时期被称为master租期。在运行过程中，master服务器会通过不断续租的方式来延长租期，如果master服务器出现故障，那么余下的服务器就会进行新一轮的master选举，最终产生新的master服务器。

集群中的每个服务器都维护着一份服务端数据库的副本，但在实际运行过程中，只有master服务器才能对数据库进行写操作，而其他服务器都是使用paxos协议从master服务器上同步数据库数据的更新。

**Chubby客户端是如何定位到master服务器的。**chubby客户端通过向极路由chubby的服务端机器列表的dns来请求获取所有的chubby服务器列表，然后逐个发起请求询问该服务器是否是master。在这个询问过程中，那些非master的服务器，会将当前master所在的服务器标识反馈给客户端。

确定了master服务器之后，所有请求都发送到master服务器上。对于写请求，master会采用一致性协议广播给几区所有服务器，并且在过半的服务器接受了些请求之后，再响应给客户端正确的应答。

chubby上的每个数据节点都分为持久节点和临时节点两大类，持久节点需要显式调用接口api来进行删除，临时节点则在其对应的客户端会话失效后被自动删除。

## zookeeper ##
zookeeper没有直接采用paxos算法，而是采用ZAB(Zookeeper Atomic Braodcast)的一致性协议。  
zookeeper是分布式数据一致性的解决方案，分布式应用可以基于它实现发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、master选举、分布式锁和分布式队列等功能。 

### zookeeper设计目标 ###
#### 一、简单的数据模型 ####
zookeeper使得分布式程序能够通过一个共享的树形结构的命名空间来进行相互协调。树形空间是指zookeeper服务器内存中的一个数据模型，由一系列的ZNood的数据节点组成。

#### 二、可以构建集群 ####
组成zookeeper集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都能保持通信，只要集群中存在超过一半的机器能够正常工作，整个集群就能正常对外提供服务。  
zookeeper的客户端程序会选择和集群中任意一台机器共同创建一个TCP连接，一旦客户端某台zookeeper服务器之间的连接断开后，客户端会自动连接到集群中的其他机器。

#### 三、顺序访问 ####
对于来自客户端的每个更新请求，zookeeper都会分片一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用zookeeper的这个特性来实现更高层次的同步原语。

#### 四、高性能 ####
由于zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此适用于以读操作为主的应用场景。

### zookeeper基本概念 ###
#### 集群角色 ####
有三种角色Leader、Follower和Observer三种角色。zookeeper集群中的所有机器通过一个Leader选举过程来选定一台名为leader的机器，leader服务器为客户端提供读和写服务。Follower和Observer都能够提供读服务，唯一的区别在于，Observer机器不能参与leader选举，也不参与写操作的“过半成功策略”，因此Observer可以在不影响写性能的情况下提升集群的读性能。observer类似于follower

#### 会话（session） ####
在zookeeper中，一个客户端连接是指在客户端和服务器之间的一个TCP长连接。客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的watch事件通知。Session和sessionTimeout值用来设置一个客户端会话的超时时间。如果客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上急群众任意一台服务器，那么之前创建的会话仍然有效。

#### 数据节点（Znode） ####
节点分为两类，第一类是指构成几区的机器，称为机器节点；第二类是指数据模型中的数据单元，称为——ZNode。  
在zookeeper中ZNode可以分为持久节点和临时节点两类。持久及节点是指一旦ZNode被创建了，除非主动进行ZNode的移除操作，否则将一直保存在zookeeper上。临时节点的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。

#### 版本 ####
每个ZNode，zookeeper都会为其维护一个叫做stat的数据结构，stat中记录了这个ZNode的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和aversion（当前ZNode的acl版本）。

#### watcher ####
zookeeper运行用户在指定节点上注册一些watcher，并且在一些特定事件触发的时候，zookeeper服务端会将事件通知到感兴趣的客户端上，

#### ACL ####
zookeeper采用ACL（Access Control Lists）策略来进行权限控制。zookeeper定义了5种权限。

- CREATE:创建子节点的权限
- READ:获取节点数据和子节点列表权限
- WRITE:更新节点数据
- DELETE:删除子节点
- ADMIN:设置节点ACL权限

### ZAB协议 ###
zookeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体的，zookeeper使用单一的主进程接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以proposal的形式广播到所有副本进程上去。ZAB协议的这个主备模型架构保证了同一时刻集群中只能有一个主进程来广播服务器的状态变更，顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更。例如变更C需要依赖变更A和变更B。这样的变更需要ZAB协议：必须保证一个全局的变更序列被顺序应用，也就是说，ZAB协议需要保证如果一个状态变更已经被处理了，那么所有其依赖的状态变更都应该已经被提前处理掉了。考虑到主进程在任何时候都有可能出现崩溃退出或重启现象，ZAB协议还需要做到在当前主进程出现上述异常情况的时候依旧能正常工作。

**理解：**  
所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，而余下的其他服务器则称为Follower服务器。Leader服务器负责将一个客户端事务请求转换成一个事务Propasol(提议)，并将该proposal分发给集群中所有的Follower服务器。之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈之后，那么Leader就会再次向所有的Follwer服务器分发commit消息，要求其将前一个proposal进行提交。

### 协议介绍 ###
ZAB协议包括两种基本模式，分别是崩溃恢复和消息广播。当整个服务框架在启动过程中，就是当leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。当选举产生了新的Leader服务器，同时汲取中已经有过半的机器与该leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。

当集群中已经有过半的follower服务器完成了和Leader服务器的状态同步，整个服务框架就可以进入消息广播模式。

zookeeper集群只允许一个Leader服务器来进行事务请求的处理。leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，这些非leader服务器会首先将这个事务请求转发给leader服务器。

当leader服务器出现崩溃退出或机器重启，或集群中已经不存在过半的服务器与该leader服务器保持正常通信时，那么在重新开始一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此达到一个一致的状态，于是整个ZAB流程就会从消息广播模式进入到崩溃恢复模式。进入崩溃恢复模式后，只要急群众存在过半的服务器能够彼此进行正常通信，那么就可以产生一个新的leader并再次进入消息广播模式。

#### 消息广播 ####
ZAB协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交过程。但是不需要所有的follower都返回ack，只需要一半以上反馈，就可以进行事务的提交。

leader服务器会为每个事务请求产生对应的proposal来进行广播，并且在广播事务proposal之前，leader服务器会首先为这个proposal分配一个全局单调递增的唯一ID。由于ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务proposal按照id的先后顺序来进行排序与处理。

**具体过程：**  
在消息广播过程中，leader服务器会为每一个follower服务器都分配一个单独的对垒，然后将需要广播的事务proposal依次放入这些队列中去，并且根据FIFO策略进行消息发送。每个follower服务器在接收到这个事务proposal之后，会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给leader服务器一个ack。当leader服务器接收到超过半数follower的ack后，就会广播一个commit消息给所有的follower服务器以通知其进行事务提交，同时leader自身也会完成对事务的提交，而每一个follower服务器在接收到commit消息后，也会完成对事务的提交。

#### 崩溃恢复 ####
首先选举leader，然后同步各服务器之间的数据。然后对外提供服务。当崩溃的服务重新恢复的时候，会把当前系统的数据和恢复的服务器中的事务进行对比，如果恢复的服务器中的事务和当前系统中的事务不同步，会把恢复服务器中多出来的事务抛弃掉。

#### 进程生命周期 ####
主要分为发现（discovery）、同步（synchronization）和广播（broadcast）三个阶段。

**阶段一：发现**  
主要是leader选举的过程。

**阶段二：同步**  
在完成发现流程之后，就进入同步阶段。

**阶段三：发现**  
完成同步阶段之后，ZAB协议就可以正式开始接收客户端新的事务请求，并进行消息广播流程。


### zookeeper客户端 ###
Curator：  
包括连接重连、反复注册watch和NodeExistException异常。还提供了zookeeper各种应用场景（recipe，如共享锁服务、master选举机制和分布式计算器等抽象封装）


### 系统模型 ###
#### 节点 ####
在zookeeper中，节点可分为持久节点（PERSISTENT）、临时节点（EPHEMERAL）、和顺序节点（SEQUENTIAL）三种。在具体创建节点过程中，通过组合使用可以生成四种节点类型:  

- 持久节点
- 持久顺序节点：比持久节点多一个顺序特性
- 临时节点：临时节点和会话绑定在一起，而不是和tcp连接绑定在一起
- 临时顺序节点：

#### 版本 ####
zookeeper中的每个数据节点都巨友三种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。

在进行一次setDateRequest请求处理时，首先进行了版本检查：zookeeper会从setDataRequest请求中获取当前请求的版本version。如果version为“-1”，那么说明客户端并不要求使用乐观锁，可以忽略版本对比；如果version不是“-1”，那么就对比version和currentVersion如果两个版本不匹配，则会抛出BadVersionException。


#### watcher——数据变更的通知 ####
zookeeper允许客户端向服务端注册一个watcher监听，当服务端的一些指定时间触发了这个watcher，那么就会向指定客户端发送一个事件通知来实现分布式的功能。

zookeeper的watcher机制主要包括客户端线程，客户端watchManager和zookeeper服务器。工作流程：客户端在向zookeeper服务器注册watcher的同时，会将watcher对象存储在客户端的watcherManager中。当zookeeper服务器端触发watcher事件后，会向客户端发送通知，客户端线程从watcherManager中取出对应的wathcer对象来执行回调逻辑。

WathcerManager主要存储的是事件的回调逻辑。

#### 客户端注册watcher ####
zookeeper客户端对象实例时，可以向构造方法中传入一个默认的watcher，这个watcher将作为整个zookeeper会话期间默认的watcher，会一直保存在客户端ZAWatchManager的defaultWatcher中。另外，Zookeeper客户端也可以通过getDate,getChildren和exist三个接口来向zookeeper服务器注册watcher，无论使用哪种方式，注册watcher的工作原理都是一致的。

在向getData接口注册watcher后，客户端首先会对当前客户端请求request进行标记，将其设置为“使用watcher监听”，同时会封装一个watcher的注册信息WatchRegistration对象，用于暂时保存数据节点的路径和watcher的对应关系。

在zookeeper中,Packet可以被看做一个最小的通信协议单元，用于进行客户端与服务端之间的网络传输，任何需要传输的对象都需要包装成一个Packet对象。因此WatchRegistration会被封装到Packet中去，然后放入发送队列中等待客户端发送。

随后zookeeper客户端就会向服务端发送这个请求，同时等待请求的返回。完成请求发送后，会由客户端SendThread线程的readResponse方法负责接收来自客户端的响应。

在register方法中，客户端会将之前暂时保存的watcher对象转交给ZKWatcherManager，并最终保存到dataWatches中去。


#### 服务端处理watcher ####
对于标记了watcher注册的请求，zookeeper会将其对应的ServerCnxn存储到WatchManager中。

对指定节点进行数据更新后，通过调用WatchManager的triggerWatch方法来触发相关的事件。

无论是dataWatches还是childWatches管理器，watcher的触发逻辑都是一致的。

1. 封装WatchedEvent:首先将通知状态（KeeperState）、事件类型（EventType）以及节点路径（Path）封装成一个WatchedEvent对象。
2. 查询Watcher：根据数据节点节点路径从watchTable中取出对应的Watcher。如果没有找到Watcher，说明没有任何客户端在该数据节点上注册过Watcher，直接退出。而如果找到了这个Watcher,会将其提取出来，同时会直接从watchTable和watch2Paths中将其删除。（watcher在服务端是一次性的，触发一次就失效了）
3. 调用process方法来触发watcher。在这一步中会逐个依次调用步骤2中找出的所有watcher的process方法。

#### 客户端回调watcher ####
服务端通过使用ServerCnxn对应的TCP连接来向客户端发送一个WatcherEvent事件。

**SendThread接收事件通知**  

1. 反序列化。zookeeper客户端接收到请求后，首先会将字节流转换成WatcherEvent对象。
2. 处理chrootPath
3. 还原watchedEvent
4. 回调watcher

**EventThread处理事件通知**  
queueEvent方法首先会根据该通知事件，从ZKWatchManager中取出所有相关的Watcher，并逐个remove。（客户端的watcher机制同样也是一次性的，即一旦被触发后，该watcher就失效了）。获取到相关的所有watcher之后，会将其放入waitingEvents这个队列中去。EventThread的run方法会不断对该队列进行串行同步处理。调用其process方法就可以实现watcher的回调。

#### 总结 ####

**一次性**：无论是服务端还是客户端，一旦一个watcher被触发，zookeeper都会将其从对应的存储中移除。在watcher的使用上需要反复注册。这样的设计有效的减轻了服务端的压力。  
**客户端串行执行**：客户端watcher的回调过程是一个串行同步的过程，这为我们保证了顺序，同时，不要因为一个watcher的处理逻辑影响整个客户端的watcher回调。  
**轻量**：WatchedEvent是zookeeper整个watcher通知机制的最小通知单元，这个数据结构中只包含三部分内容：通知状态、时间类型和节点路径。watcher通知非常简单，只会告诉客户端发生了事件，不会说明事件的具体内容。

#### ACL ####
类似于linux的文件系统控制方式——UGO(user,group和others)
**权限模式：scheme**  
ip：ip模式通过ip地址粒度来进行权限控制。  
digest：类似于“username:password”
world：开放模式，所有用户可见  
super：超级用户

**授权对象：id**  
权限对象指的是权限赋予的用户或一个指定实体，如IP地址或是机器等。

**权限：permission**  
操作权限分为五类：  
- CREATE:创建权限，允许在该数据节点下创建子节点
- DELETE:删除权限，允许删除该数据节点下的子节点
- READ:读取权限，允许访问该节点并读取其数据内容或自己节点列表
- WRITE:更新权限，允许对该数据节点进行更新操作
- ADMIN:管理权限，允许对该数据节点进行ACL相关设置操作。

#### 权限扩展体系 ####
允许开发人员通过指定方式对zookeeper的权限进行扩展


### 序列化与协议 ###
使用jute组件序列化。

#### 通信协议 ####
基于TCP/IP协议。


### 客户端 ###
zookeeper的客户端主要由以下几个核心组件组成。

- zookeeper实例：客户端的入口
- ClientWatchManager:客户端Watcher管理器
- HostProvider:客户端地址列表管理器
- ClientCnxn:客户端核心线程，其内部包含两个线程，即SendThread和EventThread。前者是一个I/O线程，主要负责zookeeper客户端和服务端之间的网络I/O通信；后者是一个事件线程，主要负责服务端事件进行处理。

#### 一次会话的创建过程 ####
**初始化阶段：**  

1. 初始化zookeeper对象。通过调用zookeeper的构造方法来实例化一个zookeeper对象，在初始化过程中，会创建一个客户端的watcher管理器：ClientWatchManager
2. 设置会话默认watcher。如果在构造方法中传入了一个watcher对象，那么客户端会将这个对象作为默认watcher保存在ClientWatchManager中。
3. 构造zookeeper服务器地址列表管理器：HostProvider。构造方法中传入的服务器地址，客户端会将其存放在服务器地址列表管理器HostProvider中
4. 创建并初始化客户端网络连接器：ClientCnxn。zookeeper客户端首先会创建一个网络连接起ClientCnxn，用来管理客户端与服务器的网络交互。并会初始化两个核心队列outgoingQueue和pendingQueue，分别作为客户端的请求发送队列和服务端响应的等待队列。ClientCnxn的底层连接器是ClientCnxnSocket，在这步中同时会创建ClientCnxnSocket连接器。
5. 初始化SendThread和EventThread

**会话创建阶段：**

6. 启动SendThread和EventThread
7. 获取一个服务器地址。
8. 创建TCP连接
9. 构造ConnectRequest请求
10. 发送请求

**响应处理阶段**

11. 接收服务端响应。
12. 处理response。主要是sessionId
13. 连接成功
14. 生成事件：SyncConnected-None.该事件传递给EventThread线程表示会话创建成功。
15. 查询watcher
16. 处理事件。主要是watcher事件



### Leader选举 ###
最少需要两台服务器，并且能够正常通信，才能进行选举。

#### 启动时期的选举 ####
1. 没法server会发出一个投票投票格式为（myid，ZXID）。每个服务器都会投票给自己。
2. 接收来自各个服务器的投票。
3. 处理投票。在接收到其他服务器的投票后，针对每一个投票，服务器都需要将别人的投票和自己的投票进行pk，规则为，1.ZXID大的；2.myid大的作为服务器
4. 统计投票。每次投票后，服务器都会统计所有投票，当过半机器收到投票信息后，即确认已经选出了leader。
5. 改变服务器状态。

#### 运行期间的Leader选举 ####
1. 变更状态
2. 每个server发出一个投票
3. 接收来自各个服务器的投票
4. 处理投票。和上面的过程一样
5. 统计投票
6. 改变服务器状态
