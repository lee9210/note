开销
当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。
这种切换称为“上下文切换”。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。

线程的创建还需要申请内存，即使什么都不做，这些内存在线程运行结束之前，都不会释放。

一. 并发编程模型
1. 并行工作者：传入的作业会被分配到不同的工作者上，每个工作者完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的CPU上。
图示：concurrency-models-1.png

如果在某个汽车厂里实现了并行工作者模型，每台车都会由一个工人来生产。工人们将拿到汽车的生产规格，并且从头到尾负责所有工作。

优点:你只需添加更多的工作者来提高系统的并行度。
缺点：
1). 共享状态可能会很复杂。共享的工作者经常需要访问一些共享数据，无论是内存中的或者共享的数据库中的。图示：concurrency-models-2.png
	一旦共享状态潜入到并行工作者模型中，将会使情况变得复杂起来。线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）。
	线程需要避免竟态，死锁以及很多其他共享状态的并发性问题。
	在执行一些高竞争任务时会导致一定程度的串行化
2). 无状态的工作者。共享状态能够被系统中的其他线程修改，所以工作者在每次需要的时候必须重读状态，以确保每次都能访问到最新副本。这会导致速度变慢，特别是状态保存在外部数据库中的时候
3). 任务顺序是不确定的。

2. 流水线模式。图示：concurrency-models-3.png
每个工作者在自己的线程中雨欣，并且不会和其他工作者共享状态。也可称为无共享并行模型。非阻塞IO就是一种。
此模型也被称为反应器系统或事件驱动系统。系统内的工作者对系统内出现的事件做出反应，这些事件也有可能来自于外部事件或者其他工作者，例如http请求，

actor(反应器)模型：concurrency-models-7.png
channel(事件驱动)模型:concurrency-models-8.png

优点
1). 无需共享状态。工作者之间无需共享状态，即实现的时候无需考虑所有因为并发访问共享对象而产生的并发性问题。
2). 有状态的工作者。当工作者知道了没有其他线程可以修改他们的数据，工作者可以变成有状态的。即他们可以在内存中保存他们的数据，在最后写回到外部存储系统个。
3). 较好的硬件整合。
4). 合理的作业顺序

缺点：
作业执行往往分布到多个工作者上，并因此分布到项目中的多个类上。在追踪时某个作业时，变得困难。
也加大了代码编写的难度，有时会将工作者的代码写成回调处理的形式。

tip：流水线最好是一个线程一个资源，不要出现多个线程争抢一个资源的情况。

3. 函数式并行
采用函数调用实现程序。函数可以看成是“代理人(agent)”或者“actor”，函数之间可以像流水线模型那样互相发送消息。某个函数调用另一个函数，这个过程类似于消息发送
函数都是通过拷贝来传递参数的，所以除了接收函数外，没有实体可以操作数据。
类似于java8 streams。但这个工作但愿需要达到某个大小以弥补这个开销，否则可能比单线程还慢。

二. 竞态条件与临界区
同一个程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如：同一个内存区（变量、数组、对象）、系统（数据库、web services）或文件。
实际上只有对这些资源做了写操作才可能方法，只要资源没变化，多个线程读取相同的资源就是安全的。
例如：
````
public class Counter {
	protected long count = 0;
	public void add(long value){
		this.count = this.count + value;   
	}
}
````
将按照下面的顺序执行：
1. 从内存获取 this.count 的值放到寄存器
2. 将寄存器中的值增加value
3. 将寄存器中的值写回内存

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就成为存在竞态条件。
导致竞态条件发生的代码区称为临界区。

三. 线程安全与共享资源
允许被多个线程同时执行的代码被称为安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时，会引发竞态条件。

1. 局部变量
局部变量存储在线程自己的栈中。即永远不会被多个线程共享

2. 局部的对象引用
尽管引用本身没有被共享，但引用所指的对象并没存储在线程的栈内。所有的对象都存在共享堆中。

3. 对象成员
对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就是不安全的。

线程控制逃逸规则
如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。

如果对象本身是安全的，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不在是线程安全的了。

四. 线程安全及不可变性
不可变对象：可以通过去掉实例的set函数，或者在需要对实例的某个值进行修改的时候，可以返回一个新的对象，来代替原来的对象。



