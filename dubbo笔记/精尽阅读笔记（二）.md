
# 20 服务调用（一）之本地调用（Injvm） #
本地调用，在 dubbo-rpc-injvm 模块实现。	

## 20.1 顺序图 ##

消费者调用服务的顺序图：

![](/picture/dubbo-consumer-function-flow.png)

提供者提供服务的顺序图：
![](/picture/dubbo-provider-function-flow.png)

## 20.2 消费者调用服务 ##

### 20.2.1 Proxy ###
通过动态代理生成远程服务的引用。

### 20.2.2 ProtocolFilterWrapper ###
对应消费者调用服务的第5步。

ProtocolFilterWrapper 的带有过滤链的 Invoker ，整个调用过程和 J2EE FilterChain 是一致的。

invoke(invocation) 方法中，调用 Filter#(invoker, invocation) 方法，不断执行过滤逻辑。而在 Filter 中，又不断调用 Invoker#invoker(invocation) 方法，最终最后一个 Filter ，会调用 InjvmInvoker#invoke(invocation) 方法，继续执行逻辑。

### 20.2.3 ListenerInvokerWrapper ###
对应消费者调用服务的第6步。

ListenerInvokerWrapper 类，主要目的是为了 InvokerListener 的触发，目前该监听器只有 #referred(invoker) #destroyed(invoker) 两个接口方法，并未对 #invoke(invocation) 的过程，实现监听。因此，ListenerInvokerWrapper 的 #invoke(invocation) 的实现基本等于零。

### 20.2.4 AbstractInvoker ###
对应消费者调用服务的第7步。

AbstractInvoker ，在 #invoke(invocation) 方法中，实现了公用逻辑，同时抽象了 #doInvoke(invocation) 方法，子类实现自定义逻辑。

基本流程如下：
1. 设置 invocation 的属性。
	1. 设置 invoker 属性为自己。在上面，我们已经看到 Invoker 是层层嵌套，只要到了这里才是真正的 Invoker 对象。
	2. 添加公用的的隐式传参。例如，path interface 等等。所有见 RpcInvocation 构造方法。从 Invocation#addAttachmentsIfAbsent(context) 方法，不存在才添加，因此业务上隐式传参的 KEY 不能冲突到这几个。
	3. 添加自定义的隐式传参，从 RpcContext.attachments 中。使用 RpcContext 隐式传参需要注意：
		- RpcContext 是一个临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。
		- A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。
	4. 异步方法，相关的处理
2. 调用 #doInvoke(invocation) 抽象方法，实现不同协议自定义的调用实现。

Dubbo RPC 抽象模型：

![](/picture/dubbo-rpc-abstract-model.png)

### 20.2.5 InjvmInvoker ###
对应消费者调用服务的第8步。

doInvoke(invocation) 实现方法，基本流程如下：

1. 调用 InjvmProtocol#getExporter(exporterMap, url) 方法，获得对应的 Exporter 对象。在exporterMap 属性，就是从 InjvmProtocol 的 exporterMap 属性。
2. 设置服务提供者地址为本地。
3. 获得到 Exporter 对象，里面就有服务提供者的 Invoker 对象。调用 Invoker#invoke(invocation) 方法，调用服务。

## 20.3 提供者提供服务 ##

### 20.3.1 InjvmInvoker ###

对应提供者提供服务的顺序图图中1.2

### 20.3.2 ProtocolFilterWrapper ###

对应提供者提供服务的顺序图图中3.4

### 20.3.3 DelegateProviderMetaDataInvoker ###
对应提供者提供服务的顺序图图中5
DelegateProviderMetaDataInvoker ，带有服务提供者配置 ServiceConfig 的 Invoker 对象。

------

# 21 服务调用（二）之远程调用（Dubbo）【1】通信实现 #

## 21.1 Server ##
Server 实现类是 HeaderExchangeServer 。

## 21.2 Client ##
Client 实现类是 ReferenceCountExchangeClient 和 LazyConnectExchangeClient 。

## 21.3 ExchangeHandler ##
在 DubboProtocol 中，实现了 ExchangeHandler。
这个处理器，负责将请求，转发到对应的 Invoker 对象，执行逻辑，返回结果。

## 21.4 Codec ##
在 ExchangeCodec 中，我们看到对 Request 和 Response 的通用解析。但是它是不满足在 dubbo:// 协议中，对 RpcInvocation 和 RpcResult 作为 内容体( Body ) 的编解码的需要的。
另外，在 dubbo:// 协议中，支持 参数回调 的特性，也是需要在编解码做一些特殊逻辑。

### 21.4.1 DubboCountCodec ###
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec ，实现 Codec2 接口，支持多消息的编解码器。

#### 21.4.1.1 构造方法 ####
在 Dubbo Client 和 Server 创建的过程，我们看到设置了编解码器为 "dubbo" ，从而通过 Dubbo SPI 机制，加载到 DubboCountCodec 。
````
private DubboCodec codec = new DubboCodec();
````
#### 21.4.1.2 编码 ####
调用
````
codec.encode(channel, buffer, msg);
````
#### 21.4.1.3 解码 ####
包含两块逻辑：1）多消息解析的支持。2）记录每条消息的长度，用于 MonitorFilter 监控。

基本流程如下：
1. 记录当前读位置，用于下面计算每条消息的长度。
2. 创建 MultiMessage 对象。MultiMessageHandler 支持对它的处理分发。
3. 循环解析消息，直到结束。
4. 调用 DubboCodec#decode(channel, buffer) 方法，解码。
5. 字节数组不够，重置读进度，结束解析。
6. 解析到消息，添加到 result 。
7. 调用 #logMessageLength(obj, length) 方法，记录消息长度到隐式参数集合，用于 MonitorFilter 监控。
8. 记录当前读位置，用于计算下一条消息的长度。
9. 返回结果。

### 21.4.2 DubboCodec ###
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec ，实现 Codec2 接口，继承 ExchangeCodec 类，Dubbo 编解码器实现类。

#### 21.4.2.1 编码内容体 ####

##### 21.4.2.1.1 请求 #####

基本流程如下：
1. 编码 RpcInvocation 对象，写入需要编码的字段。
2. 对应的解码，在 DecodeableRpcInvocation 中。
3. 调用 CallbackServiceCodec#encodeInvocationArgument(...) 方法，编码参数。主要用于 参数回调 功能。

##### 21.4.2.1.2 响应 #####

编码 Result 对象，写入需要编码的字段。
对应的解码，在 DecodeableRpcResult 中。


#### 21.4.2.2 解码内容体 ####

基本流程如下：
1. 调用 CodeSupport#getSerialization(url, proto) 方法，获得 Serialization 对象，用于下面反序列化内容体的每个字段。
2. 获得请求或响应的编号。
3. 解析响应( Response )。
4. 解析请求( Request )。

##### 21.4.2.2.1 请求 #####
解码普通响应。
相同点，使用 DecodeableRpcResult 解码。前者，比较好理解；后者，在 DecodeHandler 中，才最终调用 DecodeableRpcResult#decode() 方法。
差异点，使用哪个线程解码。前者，还是比较好理解，当前线程，即通信框架（例如，Netty）的 IO 线程。后者，Dubbo ThreadPool 线程中。
decode.in.io 配置项，目前在 Dubbo 文档中，并未说明，应该是性能调优

##### 21.4.2.2.2 响应 #####
和请求类似，差异点在使用 DecodeableRpcInvocation 。

### 21.4.3 DecodeableRpcInvocation ###
com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation ，实现 Codec 和 Decodeable 接口，继承 RpcInvocation 类，可解码的 RpcInvocation 实现类。
当服务消费者，调用服务提供者，前者编码的 RpcInvocation 对象，后者解码成 DecodeableRpcInvocation 对象。
从目前的代码实现来看，Codec 接口，可不实现。

### 21.4.4 DecodeableRpcResult ###

和 DecodeableRpcInvocation 一致。

------

# 22 服务调用（二）之远程调用（Dubbo）【2】同步调用 #

## 22.1 消费者调用服务 ##

调用 DubboInvoker#invoke(Invocation) 方法，调用服务。基本流程如下

1. 调用 RpcUtils#getMethodName() 方法，获得方法名。
2. 获得 path( 服务名 )、version 。
3. 顺序，获得 ExchangeClient 对象。
4. 调用 RpcUtils#isAsync(url, invocation) 方法，判断是否异步调用。
	- 获得是否异步。服务引用或方法，任一配置 async = true ，即为异步。
5. 调用 RpcUtils#isOneway(url, invocation) 方法，判断是否异步调用。
	- 获得是否单向。方法配置 return = true ，即为单向。
6. 调用 URL#getMethodParameter(method, key, defaultValue) 方法，获得远程调用超时时间，单位：毫秒。
7. oneway 单向调用。
	1. 注意，调用的是 ExchangeClient#send(invocation, sent) 方法，发送消息，而不是请求。
	2. 设置 RpcContext.future = null ，无需 FutureFilter ，异步回调。
	3. 创建 RpcResult 对象，空返回。
8. async 异步调用。
	1. 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求。
	2. 调用 RpcContext#setFuture(future) 方法，在 FutureFitler 中，异步回调。
	3. 创建 RpcResult 对象，空返回。
9. sync 同步调用。
	1. 设置 RpcContext.future = null ，无需 FutureFilter ，异步回调。
	2. 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求。
	3. 调用 ResponseFuture#get() 方法，阻塞等待，返回结果。

## 22.2 提供者提供服务 ##
在 DubboProtocol 类中，实现了自己的 ExchangeHandler 对象，处理请求、消息、连接、断开连接等事件。对于服务消费者的远程调用，通过 #reply(ExchangeChannel channel, Object message) 和 #reply(Channel channel, Object message) 方法来处理。

### 22.2.1 reply ###
用于处理服务消费者的同步调用和异步调用的请求。

基本流程如下：
1. 调用 #getInvoker(channel, invocation) 方法，获得请求对应的 Invoker 对象。
	1. 如果是参数回调，获得真正的服务名 path 。
	2. 调用 #serviceKey(port, path, version) 方法，获得服务键。
	3. 从 exporterMap 集合中，获得 Exporter 对象。
	4. 获得 Invoker 对象。
2. 如果是参数回调，校验服务消费者实际存在对应的回调方法，通过方法名判断。
3. 设置调用方的地址。
4. 调用 Invoker#invoke(invocation) 方法，执行调用，并返回结果。

### 22.2.2 received ###
用于处理服务消费者的单次调用的消息，通过判断消息类型是不是 Invocation 。

### 22.2.3 connected && disconnected ###
在服务提供者上，有 "onconnect" 和 "ondisconnect" 配置项，在服务提供者连接或断开连接时，调用 Service 对应的方法。目前这个配置项，在 Dubbo 文档里，暂未提及。当然，这个在实际场景下，基本没用过。

调用 #invoke(channel, methodKey) 方法，执行对应的方法。

------

# 23 服务调用（三）之远程调用（Dubbo）【3】异步调用 #

## 23.1 FutureAdapter ##
com.alibaba.dubbo.rpc.protocol.dubbo.FutureAdapter ，实现 Future 接口，适配 ResponseFuture 。通过这样的方式，对上层调用方，透明化 ResponseFuture 的存在。

## 23.2 FutureFilter ##
com.alibaba.dubbo.rpc.protocol.dubbo.filte.FutureFilter ，实现 Filter 接口，事件通知过滤器。

@Activate(group = Constants.CONSUMER) 注解，基于 Dubbo SPI Activate 机制，只有服务消费者才生效该过滤器。

基本流程如下：
1. 调用 RpcUtils#isAsync(url, invocation) 方法，判断是否异步调用。
2. 调用 #fireInvokeCallback(invoker, invocation) 方法，触发前置方法。
3. 调用 invoker#invoke(invocation) 方法，调用服务提供者，即 Dubbo RPC 。
4. 触发回调方法。
	1. 若是异步调用，调用 #asyncCallback(invoker, invocation) 方法，执行异步回调。
	2. 若非异步调用，调用 #syncCallback(invoker, invocation) 方法，执行同步回调。
5. 返回结果。如果是异步调用或单向调用，所以返回结果是空的。

### 23.2.1 fireInvokeCallback ###

基本流程如下：
1. 获得前置方法和对象。
2. 反射调用前置方法。


### 23.2.2 syncCallback ###
fireThrowCallback(invoker, invocation, exception) 方法，触发异常回调方法

fireReturnCallback(invoker, invocation, result) 方法，触发正常回调方法

### 23.2.3 asyncCallback ###
异步回调：设置正常回调和异常回调的方法。

----

# 24 服务调用（三）之远程调用（HTTP） #
http:// 协议的远程调用，主要分成三个部分：

- 服务暴露
- 服务引用
- 服务调用

对应项目为 dubbo-rpc-http 。
基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现

## 24.1 AbstractProxyProtocol ##
com.alibaba.dubbo.rpc.protocol.AbstractProxyProtocol ，实现 AbstractProtocol 抽象类，Proxy 协议抽象类。为 HttpProtocol 、RestProtocol 等子类，提供公用的服务暴露、服务引用的公用方法，同时定义了如下抽象方法，用于不同子类协议实现类的自定义的逻辑：

````
/**
 * 执行暴露，并返回取消暴露的回调 Runnable
 *
 * @param impl 服务 Proxy 对象
 * @param type 服务接口
 * @param url URL
 * @param <T> 服务接口
 * @return 消暴露的回调 Runnable
 * @throws RpcException 当发生异常
 */
protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;

/**
 * 执行引用，并返回调用远程服务的 Service 对象
 *
 * @param type 服务接口
 * @param url URL
 * @param <T> 服务接口
 * @return 调用远程服务的 Service 对象
 * @throws RpcException 当发生异常
 */
protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;
````
### 24.1.1 构造方法 ###
rpcExceptions 属性，不同协议的远程调用，会抛出的异常是不同的。在 #refer(Class, URL) 方法中，我们会看到对这个属性的使用，理解会更清晰一些。

### 24.1.2 export ###

暴露服务，基本流程如下：
1. 调用 #serviceKey(url) 方法，获得服务键。
2. 从 exporterMap 中，获得 Exporter 对象。若已经暴露，直接返回。
3. 调用 ProxyFactory#getProxy(invoker) 方法，获得 Service Proxy 对象。
4. 调用 #doExport(impl, type, url) 抽象方法，执行子类实现的暴露服务。
5. 创建 Exporter 对象。基于 AbstractExporter 抽象类实现，覆写 #unexport() 方法
	1. 取消暴露。
	2. 调用 Runnable#run() 方法，执行取消暴露的回调方法。
3. 添加到 Exporter 集合。

### 24.1.3 refer ###
Invoker 集合

基本流程：
1. 调用 #doRefer(type, url) 抽象方法，执行子类实现的引用服务。
2. 调用 ProxyFactory#getInvoker(proxy, type, url) 方法，获得 Invoker 对象。
3. 创建 Invoker 对象。基于 AbstractExporter 抽象类实现，覆写 #doInvoke(invocation) 方法
	1. 调用 Invoker#invoke(invocation) 方法，执行 RPC 调用。
	2. 若返回结果带有异常，并且需要抛出( 异常在 rpcExceptions 中)，则抛出异常。
	3. 返回调用结果。
	4. 若捕捉到 RpcException 异常，调用 #getErrorCode(Throwable) 方法，获得异常对应的错误码。
		- 子类协议实现类，一般会覆写这个方法，实现自己异常的翻译。
	5. 若捕捉到 Throwable 异常，调用 #getRpcException(type, url, invocation, e) 方法，包装成 RpcException 异常，
4. 添加到 Invoker 集合。

## 24.2 HttpProtocol ##
com.alibaba.dubbo.rpc.protocol.http.HttpProtocol ，实现 AbstractProxyProtocol 抽象类，dubbo:// 协议实现类。

- serverMap 属性，HttpServer 集合。键为 ip:port ，通过 #getAddr(url) 方法，计算
- skeletonMap 属性，Spring HttpInvokerServiceExporter 集合。请求处理过程为 HttpServer => DispatcherServlet => InternalHandler => HttpInvokerServiceExporter 。
- httpBinder 属性，HttpBinder$Adaptive 对象，通过 #setHttpBinder(httpBinder) 方法，Dubbo SPI 调用设置。

### 24.2.1 doExport ###
基于 dubbo-remoting-http 项目，作为通信服务器。基本流程如下：
1. 调用 #getAddr(url) 方法，获得服务器地址。
2. 从 serverMap 中，获得 HttpServer 对象。若不存在，调用 HttpBinder#bind(url, handler) 方法，创建 HttpServer 对象。此处使用的 InternalHandler
3. 创建 HttpInvokerServiceExporter 对象。
4. 添加到 skeletonMap 集合中。
5. 返回取消暴露的回调 Runnable 对象。

# 25 服务调用（四）之远程调用（Hessian） #

定义如下：
Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。

Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：

- 提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用
- 或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。

整体实现和 dubbo-rpc-http 一致

## 25.1 HttpClientConnection ##
com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnection ，实现 HessianConnection 接口，HttpClient 连接器实现类。

基于 Apache HttpClient 封装。

### 25.1.1 HttpClientConnectionFactory ###

com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory ，实现 HessianConnectionFactory 接口，创建 HttpClientConnection 的工厂

## 25.2 HessianProtocol ##
com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol ，实现 AbstractProxyProtocol 抽象类，hessian:// 协议实现类。

### 25.2.1 构造方法 ###

````
/**
 * Http 服务器集合
 * serverMap 属性，HttpServer 集合。键为 ip:port ，通过 #getAddr(url) 方法，计算
 * key：ip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * Spring HttpInvokerServiceExporter 集合
 * skeletonMap 属性，com.caucho.hessian.server.HessianSkeleton 集合。请求处理过程为 HttpServer => DispatcherServlet => HessianHandler => HessianSkeleton 。
 * key：path 服务名
 */
private final Map<String, HessianSkeleton> skeletonMap = new ConcurrentHashMap<String, HessianSkeleton>();
/**
 * httpBinder 属性，HttpBinder$Adaptive 对象，通过 #setHttpBinder(httpBinder) 方法，Dubbo SPI 调用设置。
 * HttpBinder$Adaptive 对象
 */
private HttpBinder httpBinder;

public HessianProtocol() {
    super(HessianException.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
````

### 25.2.2 doExport ###
基于 dubbo-remoting-http 项目，作为通信服务器。

基本流程如下：
1. 调用 #getAddr(url) 方法，获得服务器地址。
2. 从 serverMap 中，获得 HttpServer 对象。若不存在，调用 HttpBinder#bind(url, handler) 方法，创建 HttpServer 对象。此处使用的 HessianHandler ，下文详细解析。
3. 创建 HessianSkeleton 对象，添加到 skeletonMap 集合中。
4. 返回取消暴露的回调 Runnable 对象。

#### 25.2.2.1 HessianHandler ####
基本流程如下：
1. 获得 HessianSkeleton 对象
2. 必须是 POST 请求
3. 执行调用

### 25.2.3 doRefer ###
基于 HttpClient ，作为通信客户端。

基本流程如下：
1. 创建 com.caucho.hessian.client.HessianProxyFactory 对象。
2. 创建连接器工厂为 com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory 。
3. 设置超时时间。
4. 调用 HessianProxyFactory#create(Class<?> api, URL url, ClassLoader loader) 方法，生成 Service Proxy 对象。

















123