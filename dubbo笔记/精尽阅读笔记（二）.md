
# 20 服务调用（一）之本地调用（Injvm） #
本地调用，在 dubbo-rpc-injvm 模块实现。	

## 20.1 顺序图 ##

消费者调用服务的顺序图：

![](/picture/dubbo-consumer-function-flow.png)

提供者提供服务的顺序图：
![](/picture/dubbo-provider-function-flow.png)

## 20.2 消费者调用服务 ##

### 20.2.1 Proxy ###
通过动态代理生成远程服务的引用。

### 20.2.2 ProtocolFilterWrapper ###
对应消费者调用服务的第5步。

ProtocolFilterWrapper 的带有过滤链的 Invoker ，整个调用过程和 J2EE FilterChain 是一致的。

invoke(invocation) 方法中，调用 Filter#(invoker, invocation) 方法，不断执行过滤逻辑。而在 Filter 中，又不断调用 Invoker#invoker(invocation) 方法，最终最后一个 Filter ，会调用 InjvmInvoker#invoke(invocation) 方法，继续执行逻辑。

### 20.2.3 ListenerInvokerWrapper ###
对应消费者调用服务的第6步。

ListenerInvokerWrapper 类，主要目的是为了 InvokerListener 的触发，目前该监听器只有 #referred(invoker) #destroyed(invoker) 两个接口方法，并未对 #invoke(invocation) 的过程，实现监听。因此，ListenerInvokerWrapper 的 #invoke(invocation) 的实现基本等于零。

### 20.2.4 AbstractInvoker ###
对应消费者调用服务的第7步。

AbstractInvoker ，在 #invoke(invocation) 方法中，实现了公用逻辑，同时抽象了 #doInvoke(invocation) 方法，子类实现自定义逻辑。

基本流程如下：
1. 设置 invocation 的属性。
	1. 设置 invoker 属性为自己。在上面，我们已经看到 Invoker 是层层嵌套，只要到了这里才是真正的 Invoker 对象。
	2. 添加公用的的隐式传参。例如，path interface 等等。所有见 RpcInvocation 构造方法。从 Invocation#addAttachmentsIfAbsent(context) 方法，不存在才添加，因此业务上隐式传参的 KEY 不能冲突到这几个。
	3. 添加自定义的隐式传参，从 RpcContext.attachments 中。使用 RpcContext 隐式传参需要注意：
		- RpcContext 是一个临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。
		- A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。
	4. 异步方法，相关的处理
2. 调用 #doInvoke(invocation) 抽象方法，实现不同协议自定义的调用实现。

Dubbo RPC 抽象模型：

![](/picture/dubbo-rpc-abstract-model.png)

### 20.2.5 InjvmInvoker ###
对应消费者调用服务的第8步。

doInvoke(invocation) 实现方法，基本流程如下：

1. 调用 InjvmProtocol#getExporter(exporterMap, url) 方法，获得对应的 Exporter 对象。在exporterMap 属性，就是从 InjvmProtocol 的 exporterMap 属性。
2. 设置服务提供者地址为本地。
3. 获得到 Exporter 对象，里面就有服务提供者的 Invoker 对象。调用 Invoker#invoke(invocation) 方法，调用服务。

## 20.3 提供者提供服务 ##

### 20.3.1 InjvmInvoker ###

对应提供者提供服务的顺序图图中1.2

### 20.3.2 ProtocolFilterWrapper ###

对应提供者提供服务的顺序图图中3.4

### 20.3.3 DelegateProviderMetaDataInvoker ###
对应提供者提供服务的顺序图图中5
DelegateProviderMetaDataInvoker ，带有服务提供者配置 ServiceConfig 的 Invoker 对象。

------

# 21 服务调用（二）之远程调用（Dubbo）【1】通信实现 #

## 21.1 Server ##
Server 实现类是 HeaderExchangeServer 。

## 21.2 Client ##
Client 实现类是 ReferenceCountExchangeClient 和 LazyConnectExchangeClient 。

## 21.3 ExchangeHandler ##
在 DubboProtocol 中，实现了 ExchangeHandler。
这个处理器，负责将请求，转发到对应的 Invoker 对象，执行逻辑，返回结果。

## 21.4 Codec ##
在 ExchangeCodec 中，我们看到对 Request 和 Response 的通用解析。但是它是不满足在 dubbo:// 协议中，对 RpcInvocation 和 RpcResult 作为 内容体( Body ) 的编解码的需要的。
另外，在 dubbo:// 协议中，支持 参数回调 的特性，也是需要在编解码做一些特殊逻辑。

### 21.4.1 DubboCountCodec ###
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec ，实现 Codec2 接口，支持多消息的编解码器。

#### 21.4.1.1 构造方法 ####
在 Dubbo Client 和 Server 创建的过程，我们看到设置了编解码器为 "dubbo" ，从而通过 Dubbo SPI 机制，加载到 DubboCountCodec 。
````
private DubboCodec codec = new DubboCodec();
````
#### 21.4.1.2 编码 ####
调用
````
codec.encode(channel, buffer, msg);
````
#### 21.4.1.3 解码 ####
包含两块逻辑：1）多消息解析的支持。2）记录每条消息的长度，用于 MonitorFilter 监控。

基本流程如下：
1. 记录当前读位置，用于下面计算每条消息的长度。
2. 创建 MultiMessage 对象。MultiMessageHandler 支持对它的处理分发。
3. 循环解析消息，直到结束。
4. 调用 DubboCodec#decode(channel, buffer) 方法，解码。
5. 字节数组不够，重置读进度，结束解析。
6. 解析到消息，添加到 result 。
7. 调用 #logMessageLength(obj, length) 方法，记录消息长度到隐式参数集合，用于 MonitorFilter 监控。
8. 记录当前读位置，用于计算下一条消息的长度。
9. 返回结果。

### 21.4.2 DubboCodec ###
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec ，实现 Codec2 接口，继承 ExchangeCodec 类，Dubbo 编解码器实现类。

#### 21.4.2.1 编码内容体 ####

##### 21.4.2.1.1 请求 #####

基本流程如下：
1. 编码 RpcInvocation 对象，写入需要编码的字段。
2. 对应的解码，在 DecodeableRpcInvocation 中。
3. 调用 CallbackServiceCodec#encodeInvocationArgument(...) 方法，编码参数。主要用于 参数回调 功能。

##### 21.4.2.1.2 响应 #####

编码 Result 对象，写入需要编码的字段。
对应的解码，在 DecodeableRpcResult 中。


#### 21.4.2.2 解码内容体 ####

基本流程如下：
1. 调用 CodeSupport#getSerialization(url, proto) 方法，获得 Serialization 对象，用于下面反序列化内容体的每个字段。
2. 获得请求或响应的编号。
3. 解析响应( Response )。
4. 解析请求( Request )。

##### 21.4.2.2.1 请求 #####
解码普通响应。
相同点，使用 DecodeableRpcResult 解码。前者，比较好理解；后者，在 DecodeHandler 中，才最终调用 DecodeableRpcResult#decode() 方法。
差异点，使用哪个线程解码。前者，还是比较好理解，当前线程，即通信框架（例如，Netty）的 IO 线程。后者，Dubbo ThreadPool 线程中。
decode.in.io 配置项，目前在 Dubbo 文档中，并未说明，应该是性能调优

##### 21.4.2.2.2 响应 #####
和请求类似，差异点在使用 DecodeableRpcInvocation 。

### 21.4.3 DecodeableRpcInvocation ###
com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation ，实现 Codec 和 Decodeable 接口，继承 RpcInvocation 类，可解码的 RpcInvocation 实现类。
当服务消费者，调用服务提供者，前者编码的 RpcInvocation 对象，后者解码成 DecodeableRpcInvocation 对象。
从目前的代码实现来看，Codec 接口，可不实现。

### 21.4.4 DecodeableRpcResult ###

和 DecodeableRpcInvocation 一致。

------

# 22 服务调用（二）之远程调用（Dubbo）【2】同步调用 #

## 22.1 消费者调用服务 ##

调用 DubboInvoker#invoke(Invocation) 方法，调用服务。基本流程如下

1. 调用 RpcUtils#getMethodName() 方法，获得方法名。
2. 获得 path( 服务名 )、version 。
3. 顺序，获得 ExchangeClient 对象。
4. 调用 RpcUtils#isAsync(url, invocation) 方法，判断是否异步调用。
	- 获得是否异步。服务引用或方法，任一配置 async = true ，即为异步。
5. 调用 RpcUtils#isOneway(url, invocation) 方法，判断是否异步调用。
	- 获得是否单向。方法配置 return = true ，即为单向。
6. 调用 URL#getMethodParameter(method, key, defaultValue) 方法，获得远程调用超时时间，单位：毫秒。
7. oneway 单向调用。
	1. 注意，调用的是 ExchangeClient#send(invocation, sent) 方法，发送消息，而不是请求。
	2. 设置 RpcContext.future = null ，无需 FutureFilter ，异步回调。
	3. 创建 RpcResult 对象，空返回。
8. async 异步调用。
	1. 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求。
	2. 调用 RpcContext#setFuture(future) 方法，在 FutureFitler 中，异步回调。
	3. 创建 RpcResult 对象，空返回。
9. sync 同步调用。
	1. 设置 RpcContext.future = null ，无需 FutureFilter ，异步回调。
	2. 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求。
	3. 调用 ResponseFuture#get() 方法，阻塞等待，返回结果。

## 22.2 提供者提供服务 ##
在 DubboProtocol 类中，实现了自己的 ExchangeHandler 对象，处理请求、消息、连接、断开连接等事件。对于服务消费者的远程调用，通过 #reply(ExchangeChannel channel, Object message) 和 #reply(Channel channel, Object message) 方法来处理。

### 22.2.1 reply ###
用于处理服务消费者的同步调用和异步调用的请求。

基本流程如下：
1. 调用 #getInvoker(channel, invocation) 方法，获得请求对应的 Invoker 对象。
	1. 如果是参数回调，获得真正的服务名 path 。
	2. 调用 #serviceKey(port, path, version) 方法，获得服务键。
	3. 从 exporterMap 集合中，获得 Exporter 对象。
	4. 获得 Invoker 对象。
2. 如果是参数回调，校验服务消费者实际存在对应的回调方法，通过方法名判断。
3. 设置调用方的地址。
4. 调用 Invoker#invoke(invocation) 方法，执行调用，并返回结果。

### 22.2.2 received ###
用于处理服务消费者的单次调用的消息，通过判断消息类型是不是 Invocation 。

### 22.2.3 connected && disconnected ###
在服务提供者上，有 "onconnect" 和 "ondisconnect" 配置项，在服务提供者连接或断开连接时，调用 Service 对应的方法。目前这个配置项，在 Dubbo 文档里，暂未提及。当然，这个在实际场景下，基本没用过。

调用 #invoke(channel, methodKey) 方法，执行对应的方法。

------

# 23 服务调用（三）之远程调用（Dubbo）【3】异步调用 #

## 23.1 FutureAdapter ##
com.alibaba.dubbo.rpc.protocol.dubbo.FutureAdapter ，实现 Future 接口，适配 ResponseFuture 。通过这样的方式，对上层调用方，透明化 ResponseFuture 的存在。

## 23.2 FutureFilter ##
com.alibaba.dubbo.rpc.protocol.dubbo.filte.FutureFilter ，实现 Filter 接口，事件通知过滤器。

@Activate(group = Constants.CONSUMER) 注解，基于 Dubbo SPI Activate 机制，只有服务消费者才生效该过滤器。

基本流程如下：
1. 调用 RpcUtils#isAsync(url, invocation) 方法，判断是否异步调用。
2. 调用 #fireInvokeCallback(invoker, invocation) 方法，触发前置方法。
3. 调用 invoker#invoke(invocation) 方法，调用服务提供者，即 Dubbo RPC 。
4. 触发回调方法。
	1. 若是异步调用，调用 #asyncCallback(invoker, invocation) 方法，执行异步回调。
	2. 若非异步调用，调用 #syncCallback(invoker, invocation) 方法，执行同步回调。
5. 返回结果。如果是异步调用或单向调用，所以返回结果是空的。

### 23.2.1 fireInvokeCallback ###

基本流程如下：
1. 获得前置方法和对象。
2. 反射调用前置方法。


### 23.2.2 syncCallback ###
fireThrowCallback(invoker, invocation, exception) 方法，触发异常回调方法

fireReturnCallback(invoker, invocation, result) 方法，触发正常回调方法

### 23.2.3 asyncCallback ###
异步回调：设置正常回调和异常回调的方法。

----

# 24 服务调用（三）之远程调用（HTTP） #
http:// 协议的远程调用，主要分成三个部分：

- 服务暴露
- 服务引用
- 服务调用

对应项目为 dubbo-rpc-http 。
基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现

## 24.1 AbstractProxyProtocol ##
com.alibaba.dubbo.rpc.protocol.AbstractProxyProtocol ，实现 AbstractProtocol 抽象类，Proxy 协议抽象类。为 HttpProtocol 、RestProtocol 等子类，提供公用的服务暴露、服务引用的公用方法，同时定义了如下抽象方法，用于不同子类协议实现类的自定义的逻辑：

````
/**
 * 执行暴露，并返回取消暴露的回调 Runnable
 *
 * @param impl 服务 Proxy 对象
 * @param type 服务接口
 * @param url URL
 * @param <T> 服务接口
 * @return 消暴露的回调 Runnable
 * @throws RpcException 当发生异常
 */
protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;

/**
 * 执行引用，并返回调用远程服务的 Service 对象
 *
 * @param type 服务接口
 * @param url URL
 * @param <T> 服务接口
 * @return 调用远程服务的 Service 对象
 * @throws RpcException 当发生异常
 */
protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;
````
### 24.1.1 构造方法 ###
rpcExceptions 属性，不同协议的远程调用，会抛出的异常是不同的。在 #refer(Class, URL) 方法中，我们会看到对这个属性的使用，理解会更清晰一些。

### 24.1.2 export ###

暴露服务，基本流程如下：
1. 调用 #serviceKey(url) 方法，获得服务键。
2. 从 exporterMap 中，获得 Exporter 对象。若已经暴露，直接返回。
3. 调用 ProxyFactory#getProxy(invoker) 方法，获得 Service Proxy 对象。
4. 调用 #doExport(impl, type, url) 抽象方法，执行子类实现的暴露服务。
5. 创建 Exporter 对象。基于 AbstractExporter 抽象类实现，覆写 #unexport() 方法
	1. 取消暴露。
	2. 调用 Runnable#run() 方法，执行取消暴露的回调方法。
3. 添加到 Exporter 集合。

### 24.1.3 refer ###
Invoker 集合

基本流程：
1. 调用 #doRefer(type, url) 抽象方法，执行子类实现的引用服务。
2. 调用 ProxyFactory#getInvoker(proxy, type, url) 方法，获得 Invoker 对象。
3. 创建 Invoker 对象。基于 AbstractExporter 抽象类实现，覆写 #doInvoke(invocation) 方法
	1. 调用 Invoker#invoke(invocation) 方法，执行 RPC 调用。
	2. 若返回结果带有异常，并且需要抛出( 异常在 rpcExceptions 中)，则抛出异常。
	3. 返回调用结果。
	4. 若捕捉到 RpcException 异常，调用 #getErrorCode(Throwable) 方法，获得异常对应的错误码。
		- 子类协议实现类，一般会覆写这个方法，实现自己异常的翻译。
	5. 若捕捉到 Throwable 异常，调用 #getRpcException(type, url, invocation, e) 方法，包装成 RpcException 异常，
4. 添加到 Invoker 集合。

## 24.2 HttpProtocol ##
com.alibaba.dubbo.rpc.protocol.http.HttpProtocol ，实现 AbstractProxyProtocol 抽象类，dubbo:// 协议实现类。

- serverMap 属性，HttpServer 集合。键为 ip:port ，通过 #getAddr(url) 方法，计算
- skeletonMap 属性，Spring HttpInvokerServiceExporter 集合。请求处理过程为 HttpServer => DispatcherServlet => InternalHandler => HttpInvokerServiceExporter 。
- httpBinder 属性，HttpBinder$Adaptive 对象，通过 #setHttpBinder(httpBinder) 方法，Dubbo SPI 调用设置。

### 24.2.1 doExport ###
基于 dubbo-remoting-http 项目，作为通信服务器。基本流程如下：
1. 调用 #getAddr(url) 方法，获得服务器地址。
2. 从 serverMap 中，获得 HttpServer 对象。若不存在，调用 HttpBinder#bind(url, handler) 方法，创建 HttpServer 对象。此处使用的 InternalHandler
3. 创建 HttpInvokerServiceExporter 对象。
4. 添加到 skeletonMap 集合中。
5. 返回取消暴露的回调 Runnable 对象。

# 25 服务调用（四）之远程调用（Hessian） #

定义如下：
Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。

Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：

- 提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用
- 或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。

整体实现和 dubbo-rpc-http 一致

## 25.1 HttpClientConnection ##
com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnection ，实现 HessianConnection 接口，HttpClient 连接器实现类。

基于 Apache HttpClient 封装。

### 25.1.1 HttpClientConnectionFactory ###

com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory ，实现 HessianConnectionFactory 接口，创建 HttpClientConnection 的工厂

## 25.2 HessianProtocol ##
com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol ，实现 AbstractProxyProtocol 抽象类，hessian:// 协议实现类。

### 25.2.1 构造方法 ###

````
/**
 * Http 服务器集合
 * serverMap 属性，HttpServer 集合。键为 ip:port ，通过 #getAddr(url) 方法，计算
 * key：ip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * Spring HttpInvokerServiceExporter 集合
 * skeletonMap 属性，com.caucho.hessian.server.HessianSkeleton 集合。请求处理过程为 HttpServer => DispatcherServlet => HessianHandler => HessianSkeleton 。
 * key：path 服务名
 */
private final Map<String, HessianSkeleton> skeletonMap = new ConcurrentHashMap<String, HessianSkeleton>();
/**
 * httpBinder 属性，HttpBinder$Adaptive 对象，通过 #setHttpBinder(httpBinder) 方法，Dubbo SPI 调用设置。
 * HttpBinder$Adaptive 对象
 */
private HttpBinder httpBinder;

public HessianProtocol() {
    super(HessianException.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
````

### 25.2.2 doExport ###
基于 dubbo-remoting-http 项目，作为通信服务器。

基本流程如下：
1. 调用 #getAddr(url) 方法，获得服务器地址。
2. 从 serverMap 中，获得 HttpServer 对象。若不存在，调用 HttpBinder#bind(url, handler) 方法，创建 HttpServer 对象。此处使用的 HessianHandler ，下文详细解析。
3. 创建 HessianSkeleton 对象，添加到 skeletonMap 集合中。
4. 返回取消暴露的回调 Runnable 对象。

#### 25.2.2.1 HessianHandler ####
基本流程如下：
1. 获得 HessianSkeleton 对象
2. 必须是 POST 请求
3. 执行调用

### 25.2.3 doRefer ###
基于 HttpClient ，作为通信客户端。

基本流程如下：
1. 创建 com.caucho.hessian.client.HessianProxyFactory 对象。
2. 创建连接器工厂为 com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory 。
3. 设置超时时间。
4. 调用 HessianProxyFactory#create(Class<?> api, URL url, ClassLoader loader) 方法，生成 Service Proxy 对象。

#### 25.2.3.1 getErrorCode ####
将异常，翻译成 Dubbo 异常码

### 25.2.4 destroy ###
销毁serverMap内保存的HttpServer

----

# 26 服务调用（五）之远程调用（WebService） #
定义如下：

基于 WebService 的远程调用协议，基于 Apache CXF 的 frontend-simple 和 transports-http 实现。
可以和原生 WebService 服务互操作，即：

- 提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用，
- 或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。

整体实现和 dubbo-rpc-http 一致

## 26.1 WebServiceProtocol ##
com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol ，实现 AbstractProxyProtocol 抽象类，webservice:// 协议实现类。


### 26.1.1 构造方法 ###

````
/**
 * 默认服务器端口
 */
public static final int DEFAULT_PORT = 80;
/**
 * Http 服务器集合
 * 属性，HttpServer 集合。键为 ip:port ，通过 #getAddr(url) 方法，计算。
 * key：ip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * 在CXF中，我觉得Bus更像是一个全局配置仓库，你可以向Bus中存放任何你想存放的扩展对象，你也可以从Bus中获取你想要的扩展对象，这个Bus将CXF中的各扩展模块有机地组合在一起了。
 */
private final ExtensionManagerBus bus = new ExtensionManagerBus();
/**
 *
 */
private final HTTPTransportFactory transportFactory = new HTTPTransportFactory();
/**
 * HttpBinder$Adaptive 对象
 * httpBinder 属性，HttpBinder$Adaptive 对象，通过 #setHttpBinder(httpBinder) 方法，Dubbo SPI 调用设置。
 */
private HttpBinder httpBinder;

public WebServiceProtocol() {
    super(Fault.class);
    bus.setExtension(new ServletDestinationFactory(), HttpDestinationFactory.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
````

### 26.1.2 doExport ###
基于 dubbo-remoting-http 项目，作为通信服务器。

基本流程如下：
1. 调用 #getAddr(url) 方法，获得服务器地址。
2. 从 serverMap 中，获得 HttpServer 对象。若不存在，调用 HttpBinder#bind(url, handler) 方法，创建 HttpServer 对象。此处使用的 WebServiceHandler ，下文详细解析。
3. 创建 ServerFactoryBean 对象。
4. 返回取消暴露的回调 Runnable 对象。

#### 26.1.2.1 WebServiceHandler ####
基本流程如下：
1. 创建 ServletController 对象，设置使用 DispatcherServlet 。
2. 设置调用方地址
3. 执行调用

### 26.1.3 doRefer ###
基本流程如下：
1. 创建 ClientProxyFactoryBean 对象。
2. 创建 Service Proxy 对象。
3. 设置超时相关属性。

### 26.1.4 getErrorCode ###
将异常，翻译成 Dubbo 异常码。

----

# 27 服务调用（六）之远程调用（REST） #
对应项目为 dubbo-rpc-rest 。
在 dubbo-rpc-rest 项目中，目前使用使用的是 RedHat 的 Resteasy 。


//  todo 待补充

------

# 28 服务调用（七）之远程调用（WebService） #
//  todo 待补充

------

# 29 服务调用（八）之远程调用（Redis） #
//  todo 待补充

------

# 30 服务调用（九）之远程调用（Memcached） #
//  todo 待补充

------

# 31 调用特性（一）之回声测试 #
回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。

## 31.1 服务消费者 ##

### 31.1.1 EchoService ###
所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。
在 AbstractProxyFactory 中，#getProxy(invoker) 方法，创建服务消费者的 Proxy 对象时，自动实现 EchoService 接口

### 31.1.2 使用示例 ###

Spring 配置：

````
<dubbo:reference id="memberService" interface="com.xxx.MemberService" />
````

代码：

````
// 远程服务引用
MemberService memberService = ctx.getBean("memberService"); 

EchoService echoService = (EchoService) memberService; // 强制转型为EchoService

// 回声测试可用性
String status = echoService.$echo("OK"); 

assert(status.equals("OK"));
````

## 31.2 服务提供者 ##

服务提供者，是不实现 EchoService 接口，而是通过 EchoFilter 实现。

com.alibaba.dubbo.rpc.filter.EchoFilter ，实现 Filter 接口，回声过滤器

- 使用 Dubbo SPI Adaptive 机制，自动加载，仅限服务提供者。
- 如果调用方法是回声调用时，通过方法名( $echo ) 和方法参数数量为 1 ，直接返回方法参数。
- 若果调用方法非回声调用时，调用 Invoker#invoke(invocation) 方法，继续走后面的过滤链。

------

# 32 调用特性（二）之泛化引用 #
泛化接口调用方式主要用于客户端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过 GenericService 调用所有服务实现。

请注意，消费消费者没有 API 接口 及 模型类元。那就是说，Dubbo 在泛化引用中，需要做两件事情：

- 没有 API 接口，所以提供一个泛化服务接口，目前是 com.alibaba.dubbo.rpc.service.GenericService 
	- 一个泛化引用，只对应一个服务实现。
	- 通过 $invoke(method, parameterTypes, args) 方法，可以实现服务的泛化调用。
- 没有 模型类元，所以方法参数和方法返回若是 POJO ( 例如 User 和 Order 等 ) ，需要转换处理：
	- 服务消费者，将 POJO 转成 Map ，然后再调用服务提供者。
	- 服务提供者，接收到 Map ，转换成 POJO ，再调用 Service 方法。若返回值有 POJO ，则转换成 Map 再返回。

整体流程如下：

![](/picture/dubbo-generic-flow.png)

## 32.1 示例 ##

### provider ###
````
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Provider {

    public static void main(String[] args) throws Exception {
        System.setProperty("java.net.preferIPv4Stack", "true");
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{"META-INF/spring/dubbo-demo-provider.xml"});
        context.start();
        System.in.read(); // press any key to exit
    }
}
````
````
import com.alibaba.dubbo.rpc.service.GenericException;
import com.alibaba.dubbo.rpc.service.GenericService;

public class DemoServiceImpl implements GenericService {
    @Override
    public Object $invoke(String method, String[] parameterTypes, Object[] args) throws GenericException {
        if ("sayHello".equals(method)) {
            return "Welcome " + args[0];
        }
        return "unknown method";
    }
}
````
````
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd">
    <dubbo:application name="demo-provider"/>
    <dubbo:provider delay="-1" retries="0"  >
    </dubbo:provider>
    <dubbo:registry address="zookeeper://127.0.0.1:2181" />
    <bean id="demoService" class="com.alibaba.dubbo.demo.provider.DemoServiceImpl"/>
    <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" generic="true" timeout="200000" />
    <dubbo:protocol name="dubbo" port="20880" />
</beans>
````

### consumer ###

````
import com.alibaba.dubbo.demo.DemoService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Consumer {

    public static void main(String[] args) {
        System.setProperty("java.net.preferIPv4Stack", "true");
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{"META-INF/spring/dubbo-demo-consumer.xml"});
        context.start();
        DemoService demoService = (DemoService) context.getBean("demoService"); // get remote service proxy
        while (true) {
            try {
                Thread.sleep(1000);
                Object result = demoService.say01("NIHAO");
                System.out.println("result: " + result);

            } catch (Throwable throwable) {
                throwable.printStackTrace();
            }
        }
    }
}

````
````
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd">
    <dubbo:application name="demo-consumer" />
    <dubbo:registry address="zookeeper://127.0.0.1:2181"/>
    <dubbo:reference id="demoService" check="false" interface="com.alibaba.dubbo.demo.DemoService" timeout="100000">
    </dubbo:reference>
</beans>
````

### 32.1.2 有关泛化类型的进一步解释 ###
假设存在 POJO 如：

````
public class PersonImpl implements Person {
    private String name;
    private String password;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
````

则 POJO 数据：
````
Person person = new PersonImpl(); 
person.setName("xxx"); 
person.setPassword("yyy");
````
【服务消费者】可用下面 Map 表示：

````
Map<String, Object> map = new HashMap<String, Object>(); 
// 注意：如果参数类型是接口，或者List等丢失泛型，可通过class属性指定类型。
map.put("class", "com.xxx.PersonImpl"); 
map.put("name", "xxx"); 
map.put("password", "yyy");
````
- Map 中的 class 属性，在 PojoUtils 中，会根据该属性，将 Map 转换成 POJO 对象。

## 32.2 服务消费者 GenericImplFilter ##
com.alibaba.dubbo.rpc.filter.GenericImplFilter ，实现 Filter 接口，服务消费者的泛化调用过滤器。

- 使用 Dubbo SPI Adaptive 机制，自动加载，仅限服务消费者，并且有 generic 配置项。
	- RegistryDirectory#mergeUrl(providerUrl) 方法，它会将服务消费者的配置( URL )项，覆盖到服务提供者的 URL 。
	- 又因为泛化引用时，我们会在服务消费者的配置 generic = true ，那么服务提供者 URL 自然就有了该配置项，所以便有了 GenericImplFilter 过滤器。

基本流程如下：
1. 获得 generic 配置项。
2. 省略用于调用泛化实现服务的代码
3. 泛化引用的调用，通过方法( 包括方法名、参数 ) + generic 配置项，进行判断。
	1. 根据不同的 generic 配置项，校验方法参数是否已经正确序列化。若不合法，调用 #error(expected, actual) 方法，抛出 RpcException 异常。
	2. 调用 RpcInvocation#setAttachment(key, value) 通过隐式参数，传递 generic 配置项。
4. 调用 Invoker#invoke(invocation) 方法，继续过滤链的调用，最终 RPC 调用。

## 32.3 服务提供者 GenericFilter ##
com.alibaba.dubbo.rpc.filter.GenericFilter ，实现 Filter 接口，服务消费者的泛化调用过滤器

使用 Dubbo SPI Adaptive 机制，自动加载，仅限服务提供者。若是普通调用( 非泛化引用的调用 )，调用 Invoker#invoke(invocation) 方法，继续过滤链的调用，最终调用 Service 服务。 若是泛化引用的调用，通过方法( 包括方法名、参数 )判断

基本流程如下：
1. 调用 ReflectUtils#findMethodByMethodSignature(Class<?> clazz, String methodName, String[] parameterTypes) 方法，通过反射，获得对应的方法 Method 对象。
2. 获得方法参数类型和方法参数数组。
3. 获得 generic 配置项。

【反序列化参数】

1. generic = true ，调用 PojoUtils#realize(Object[] objs, Class<?>[] types, Type[] gtypes) 方法，反序列化参数。注意，在该方法中，只有带有 class 属性的 Map ，需要反序列化成对应的 POJO 对象。
2. generic = nativejava ，调用 NativeJavaSerialization#deserialize(url, input) 方法，反序列化参数，即 byte[] => 方法参数 。
3. generic = bean ，调用 JavaBeanSerializeUtil#deserialize(JavaBeanDescriptor) 方法，反序列化参数，即 JavaBeanDescriptor => 方法参数 。

【方法调用】

1. 创建新的 RpcInvocation 对象。这是非常关键的一步，$invoke 的泛化调用，被转换成具体的普通调用。
2. 调用 Invoker#invoke(invocation) 方法，继续过滤链的调用，最终调用 Service 服务。

【序列化结果】

- 若是异常结果，并且非 GenericException 异常，可能这个异常在服务消费端是没有的，因此需要使用 GenericException 包装后返回。
- generic = nativejava ，调用 NativeJavaSerialization#serialize(url, output) 方法，序列化结果，即 结果 => byte[] 。
- generic = bean ，调用 JavaBeanSerializeUtil#serialize(Object, JavaBeanAccessor) 方法，序列化结果，即 结果 => JavaBeanDescriptor 。
- generic = true ，调用 PojoUtils#generalize(Object) 方法，序列化结果，仅有 POJO => Map 。

# 33 调用特性（三）之泛化实现 #
泛接口实现方式主要用于服务器端没有API接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。
通过前面的例子可以看出，服务调用者和和我们普通的服务消费者，调用服务提供者，一模一样，注意，是一模一样。

## 33.1 服务消费者 GenericImplFilter ##
com.alibaba.dubbo.rpc.filter.GenericImplFilter ，实现 Filter 接口，服务消费者的泛化调用过滤器。

- 整体，和服务提供者的 GenericFilter 有一些类似。
- 使用 Dubbo SPI Adaptive 机制，自动加载，仅限服务消费者，并且有 generic 配置项。
- 若是普通调用( 非泛化引用的调用 )，调用 Invoker#invoke(invocation) 方法，继续过滤链的调用，最终调用 Service 服务。

基本流程如下
1. 判断是泛化实现的调用
2. 获得参数类型数组。

【序列化参数】
- generic = bean ，调用 JavaBeanSerializeUtil#serialize(JavaBeanDescriptor) 方法，序列化参数，即 方法参数 => JavaBeanDescriptor 。
- generic = true ，调用 PojoUtils#generalize(Object[] objs 方法，序列化参数，仅有 POJO => Map 。

【RPC 调用】
- 设置 RpcInvocation 的方法名为 $invoke 。
- 设置 RpcInvocation 的方法参数类型为 GENERIC_PARAMETER_TYPES 。
- 设置 RpcInvocation 的参数数组为 methodName types types 。
- 通过如上的 RpcInvocation 的设置，我们调用 Invoker#invoke(invocation) 方法，就能 RPC 调用到泛化实现的服务。

【反序列化正常结果】
- generic = bean ，调用 JavaBeanSerializeUtil#serialize(JavaBeanDescriptor) 方法，反序列化结果，即 JavaBeanDescriptor => POJO 。
- generic = true ，调用 PojoUtils#realize(pojo, type, genericType) 方法，反序列化结果，仅有 Map => POJO 。
- 注意，反序列完，是会创建新的 RpcResult 。 

【反序列化异常结果】
- 根据 GenericException 异常，创建原始异常 targetException 。
- 设置异常明细到 targetException 。
- 创建新的异常 RpcResult 对象。
- 创建原始异常失败，抛出异常 lastException 。

123