
# 20 服务调用（一）之本地调用（Injvm） #
本地调用，在 dubbo-rpc-injvm 模块实现。	

## 20.1 顺序图 ##

消费者调用服务的顺序图：

![](/picture/dubbo-consumer-function-flow.png)

提供者提供服务的顺序图：
![](/picture/dubbo-provider-function-flow.png)

## 20.2 消费者调用服务 ##

### 20.2.1 Proxy ###
通过动态代理生成远程服务的引用。

### 20.2.2 ProtocolFilterWrapper ###
对应消费者调用服务的第5步。

ProtocolFilterWrapper 的带有过滤链的 Invoker ，整个调用过程和 J2EE FilterChain 是一致的。

invoke(invocation) 方法中，调用 Filter#(invoker, invocation) 方法，不断执行过滤逻辑。而在 Filter 中，又不断调用 Invoker#invoker(invocation) 方法，最终最后一个 Filter ，会调用 InjvmInvoker#invoke(invocation) 方法，继续执行逻辑。

### 20.2.3 ListenerInvokerWrapper ###
对应消费者调用服务的第6步。

ListenerInvokerWrapper 类，主要目的是为了 InvokerListener 的触发，目前该监听器只有 #referred(invoker) #destroyed(invoker) 两个接口方法，并未对 #invoke(invocation) 的过程，实现监听。因此，ListenerInvokerWrapper 的 #invoke(invocation) 的实现基本等于零。

### 20.2.4 AbstractInvoker ###
对应消费者调用服务的第7步。

AbstractInvoker ，在 #invoke(invocation) 方法中，实现了公用逻辑，同时抽象了 #doInvoke(invocation) 方法，子类实现自定义逻辑。

基本流程如下：
1. 设置 invocation 的属性。
	1. 设置 invoker 属性为自己。在上面，我们已经看到 Invoker 是层层嵌套，只要到了这里才是真正的 Invoker 对象。
	2. 添加公用的的隐式传参。例如，path interface 等等。所有见 RpcInvocation 构造方法。从 Invocation#addAttachmentsIfAbsent(context) 方法，不存在才添加，因此业务上隐式传参的 KEY 不能冲突到这几个。
	3. 添加自定义的隐式传参，从 RpcContext.attachments 中。使用 RpcContext 隐式传参需要注意：
		- RpcContext 是一个临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。
		- A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。
	4. 异步方法，相关的处理
2. 调用 #doInvoke(invocation) 抽象方法，实现不同协议自定义的调用实现。

Dubbo RPC 抽象模型：

![](/picture/dubbo-rpc-abstract-model.png)

### 20.2.5 InjvmInvoker ###
对应消费者调用服务的第8步。

doInvoke(invocation) 实现方法，基本流程如下：

1. 调用 InjvmProtocol#getExporter(exporterMap, url) 方法，获得对应的 Exporter 对象。在exporterMap 属性，就是从 InjvmProtocol 的 exporterMap 属性。
2. 设置服务提供者地址为本地。
3. 获得到 Exporter 对象，里面就有服务提供者的 Invoker 对象。调用 Invoker#invoke(invocation) 方法，调用服务。

## 20.3 提供者提供服务 ##

### 20.3.1 InjvmInvoker ###

对应提供者提供服务的顺序图图中1.2

### 20.3.2 ProtocolFilterWrapper ###

对应提供者提供服务的顺序图图中3.4

### 20.3.3 DelegateProviderMetaDataInvoker ###
对应提供者提供服务的顺序图图中5
DelegateProviderMetaDataInvoker ，带有服务提供者配置 ServiceConfig 的 Invoker 对象。

------

# 21 服务调用（二）之远程调用（Dubbo）【1】通信实现 #

## 21.1 Server ##
Server 实现类是 HeaderExchangeServer 。

## 21.2 Client ##
Client 实现类是 ReferenceCountExchangeClient 和 LazyConnectExchangeClient 。

## 21.3 ExchangeHandler ##
在 DubboProtocol 中，实现了 ExchangeHandler。
这个处理器，负责将请求，转发到对应的 Invoker 对象，执行逻辑，返回结果。

## 21.4 Codec ##
在 ExchangeCodec 中，我们看到对 Request 和 Response 的通用解析。但是它是不满足在 dubbo:// 协议中，对 RpcInvocation 和 RpcResult 作为 内容体( Body ) 的编解码的需要的。
另外，在 dubbo:// 协议中，支持 参数回调 的特性，也是需要在编解码做一些特殊逻辑。

### 21.4.1 DubboCountCodec ###
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec ，实现 Codec2 接口，支持多消息的编解码器。

#### 21.4.1.1 构造方法 ####
在 Dubbo Client 和 Server 创建的过程，我们看到设置了编解码器为 "dubbo" ，从而通过 Dubbo SPI 机制，加载到 DubboCountCodec 。
````
private DubboCodec codec = new DubboCodec();
````
#### 21.4.1.2 编码 ####
调用
````
codec.encode(channel, buffer, msg);
````
#### 21.4.1.3 解码 ####
包含两块逻辑：1）多消息解析的支持。2）记录每条消息的长度，用于 MonitorFilter 监控。

基本流程如下：
1. 记录当前读位置，用于下面计算每条消息的长度。
2. 创建 MultiMessage 对象。MultiMessageHandler 支持对它的处理分发。
3. 循环解析消息，直到结束。
4. 调用 DubboCodec#decode(channel, buffer) 方法，解码。
5. 字节数组不够，重置读进度，结束解析。
6. 解析到消息，添加到 result 。
7. 调用 #logMessageLength(obj, length) 方法，记录消息长度到隐式参数集合，用于 MonitorFilter 监控。
8. 记录当前读位置，用于计算下一条消息的长度。
9. 返回结果。

### 21.4.2 DubboCodec ###
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec ，实现 Codec2 接口，继承 ExchangeCodec 类，Dubbo 编解码器实现类。

#### 21.4.2.1 编码内容体 ####

##### 21.4.2.1.1 请求 #####

基本流程如下：
1. 编码 RpcInvocation 对象，写入需要编码的字段。
2. 对应的解码，在 DecodeableRpcInvocation 中。
3. 调用 CallbackServiceCodec#encodeInvocationArgument(...) 方法，编码参数。主要用于 参数回调 功能。

##### 21.4.2.1.2 响应 #####

编码 Result 对象，写入需要编码的字段。
对应的解码，在 DecodeableRpcResult 中。


#### 21.4.2.2 解码内容体 ####

基本流程如下：
1. 调用 CodeSupport#getSerialization(url, proto) 方法，获得 Serialization 对象，用于下面反序列化内容体的每个字段。
2. 获得请求或响应的编号。
3. 解析响应( Response )。
4. 解析请求( Request )。

##### 21.4.2.2.1 请求 #####
解码普通响应。
相同点，使用 DecodeableRpcResult 解码。前者，比较好理解；后者，在 DecodeHandler 中，才最终调用 DecodeableRpcResult#decode() 方法。
差异点，使用哪个线程解码。前者，还是比较好理解，当前线程，即通信框架（例如，Netty）的 IO 线程。后者，Dubbo ThreadPool 线程中。
decode.in.io 配置项，目前在 Dubbo 文档中，并未说明，应该是性能调优

##### 21.4.2.2.2 响应 #####
和请求类似，差异点在使用 DecodeableRpcInvocation 。

### 21.4.3 DecodeableRpcInvocation ###
com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation ，实现 Codec 和 Decodeable 接口，继承 RpcInvocation 类，可解码的 RpcInvocation 实现类。
当服务消费者，调用服务提供者，前者编码的 RpcInvocation 对象，后者解码成 DecodeableRpcInvocation 对象。
从目前的代码实现来看，Codec 接口，可不实现。

### 21.4.4 DecodeableRpcResult ###

和 DecodeableRpcInvocation 一致。

------

# 22 服务调用（二）之远程调用（Dubbo）【2】同步调用 #

## 22.1 消费者调用服务 ##

调用 DubboInvoker#invoke(Invocation) 方法，调用服务。基本流程如下

1. 调用 RpcUtils#getMethodName() 方法，获得方法名。
2. 获得 path( 服务名 )、version 。
3. 顺序，获得 ExchangeClient 对象。
4. 调用 RpcUtils#isAsync(url, invocation) 方法，判断是否异步调用。
	- 获得是否异步。服务引用或方法，任一配置 async = true ，即为异步。
5. 调用 RpcUtils#isOneway(url, invocation) 方法，判断是否异步调用。
	- 获得是否单向。方法配置 return = true ，即为单向。
6. 调用 URL#getMethodParameter(method, key, defaultValue) 方法，获得远程调用超时时间，单位：毫秒。
7. oneway 单向调用。
	1. 注意，调用的是 ExchangeClient#send(invocation, sent) 方法，发送消息，而不是请求。
	2. 设置 RpcContext.future = null ，无需 FutureFilter ，异步回调。
	3. 创建 RpcResult 对象，空返回。
8. async 异步调用。
	1. 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求。
	2. 调用 RpcContext#setFuture(future) 方法，在 FutureFitler 中，异步回调。
	3. 创建 RpcResult 对象，空返回。
9. sync 同步调用。
	1. 设置 RpcContext.future = null ，无需 FutureFilter ，异步回调。
	2. 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求。
	3. 调用 ResponseFuture#get() 方法，阻塞等待，返回结果。

## 22.2 提供者提供服务 ##
在 DubboProtocol 类中，实现了自己的 ExchangeHandler 对象，处理请求、消息、连接、断开连接等事件。对于服务消费者的远程调用，通过 #reply(ExchangeChannel channel, Object message) 和 #reply(Channel channel, Object message) 方法来处理。

### 22.2.1 reply ###
用于处理服务消费者的同步调用和异步调用的请求。

基本流程如下：
1. 调用 #getInvoker(channel, invocation) 方法，获得请求对应的 Invoker 对象。
	1. 如果是参数回调，获得真正的服务名 path 。
	2. 调用 #serviceKey(port, path, version) 方法，获得服务键。
	3. 从 exporterMap 集合中，获得 Exporter 对象。
	4. 获得 Invoker 对象。
2. 如果是参数回调，校验服务消费者实际存在对应的回调方法，通过方法名判断。
3. 设置调用方的地址。
4. 调用 Invoker#invoke(invocation) 方法，执行调用，并返回结果。

### 22.2.2 received ###
用于处理服务消费者的单次调用的消息，通过判断消息类型是不是 Invocation 。

### 22.2.3 connected && disconnected ###
在服务提供者上，有 "onconnect" 和 "ondisconnect" 配置项，在服务提供者连接或断开连接时，调用 Service 对应的方法。目前这个配置项，在 Dubbo 文档里，暂未提及。当然，这个在实际场景下，基本没用过。

调用 #invoke(channel, methodKey) 方法，执行对应的方法。

------

# 23 服务调用（三）之远程调用（Dubbo）【3】异步调用 #

## 23.1 FutureAdapter ##
com.alibaba.dubbo.rpc.protocol.dubbo.FutureAdapter ，实现 Future 接口，适配 ResponseFuture 。通过这样的方式，对上层调用方，透明化 ResponseFuture 的存在。

## 23.2 FutureFilter ##
com.alibaba.dubbo.rpc.protocol.dubbo.filte.FutureFilter ，实现 Filter 接口，事件通知过滤器。

@Activate(group = Constants.CONSUMER) 注解，基于 Dubbo SPI Activate 机制，只有服务消费者才生效该过滤器。

基本流程如下：
1. 调用 RpcUtils#isAsync(url, invocation) 方法，判断是否异步调用。
2. 调用 #fireInvokeCallback(invoker, invocation) 方法，触发前置方法。
3. 调用 invoker#invoke(invocation) 方法，调用服务提供者，即 Dubbo RPC 。
4. 触发回调方法。
	1. 若是异步调用，调用 #asyncCallback(invoker, invocation) 方法，执行异步回调。
	2. 若非异步调用，调用 #syncCallback(invoker, invocation) 方法，执行同步回调。
5. 返回结果。如果是异步调用或单向调用，所以返回结果是空的。

### 23.2.1 fireInvokeCallback ###

基本流程如下：
1. 获得前置方法和对象。
2. 反射调用前置方法。


### 23.2.2 syncCallback ###
fireThrowCallback(invoker, invocation, exception) 方法，触发异常回调方法

fireReturnCallback(invoker, invocation, result) 方法，触发正常回调方法

### 23.2.3 asyncCallback ###
异步回调：设置正常回调和异常回调的方法。

