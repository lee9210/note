
# 20 服务调用（一）之本地调用（Injvm） #
本地调用，在 dubbo-rpc-injvm 模块实现。	

## 20.1 顺序图 ##

消费者调用服务的顺序图：

![](/picture/dubbo-consumer-function-flow.png)

提供者提供服务的顺序图：
![](/picture/dubbo-provider-function-flow.png)

## 20.2 消费者调用服务 ##

### 20.2.1 Proxy ###
通过动态代理生成远程服务的引用。

### 20.2.2 ProtocolFilterWrapper ###
对应消费者调用服务的第5步。

ProtocolFilterWrapper 的带有过滤链的 Invoker ，整个调用过程和 J2EE FilterChain 是一致的。

invoke(invocation) 方法中，调用 Filter#(invoker, invocation) 方法，不断执行过滤逻辑。而在 Filter 中，又不断调用 Invoker#invoker(invocation) 方法，最终最后一个 Filter ，会调用 InjvmInvoker#invoke(invocation) 方法，继续执行逻辑。

### 20.2.3 ListenerInvokerWrapper ###
对应消费者调用服务的第6步。

ListenerInvokerWrapper 类，主要目的是为了 InvokerListener 的触发，目前该监听器只有 #referred(invoker) #destroyed(invoker) 两个接口方法，并未对 #invoke(invocation) 的过程，实现监听。因此，ListenerInvokerWrapper 的 #invoke(invocation) 的实现基本等于零。

### 20.2.4 AbstractInvoker ###
对应消费者调用服务的第7步。

AbstractInvoker ，在 #invoke(invocation) 方法中，实现了公用逻辑，同时抽象了 #doInvoke(invocation) 方法，子类实现自定义逻辑。

基本流程如下：
1. 设置 invocation 的属性。
	1. 设置 invoker 属性为自己。在上面，我们已经看到 Invoker 是层层嵌套，只要到了这里才是真正的 Invoker 对象。
	2. 添加公用的的隐式传参。例如，path interface 等等。所有见 RpcInvocation 构造方法。从 Invocation#addAttachmentsIfAbsent(context) 方法，不存在才添加，因此业务上隐式传参的 KEY 不能冲突到这几个。
	3. 添加自定义的隐式传参，从 RpcContext.attachments 中。使用 RpcContext 隐式传参需要注意：
		- RpcContext 是一个临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。
		- A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。
	4. 异步方法，相关的处理
2. 调用 #doInvoke(invocation) 抽象方法，实现不同协议自定义的调用实现。

Dubbo RPC 抽象模型：

![](/picture/dubbo-rpc-abstract-model.png)

### 20.2.5 InjvmInvoker ###
对应消费者调用服务的第8步。

doInvoke(invocation) 实现方法，基本流程如下：

1. 调用 InjvmProtocol#getExporter(exporterMap, url) 方法，获得对应的 Exporter 对象。在exporterMap 属性，就是从 InjvmProtocol 的 exporterMap 属性。
2. 设置服务提供者地址为本地。
3. 获得到 Exporter 对象，里面就有服务提供者的 Invoker 对象。调用 Invoker#invoke(invocation) 方法，调用服务。

## 20.3 提供者提供服务 ##

### 20.3.1 InjvmInvoker ###

对应提供者提供服务的顺序图图中1.2

### 20.3.2 ProtocolFilterWrapper ###

对应提供者提供服务的顺序图图中3.4

### 20.3.3 DelegateProviderMetaDataInvoker ###
对应提供者提供服务的顺序图图中5
DelegateProviderMetaDataInvoker ，带有服务提供者配置 ServiceConfig 的 Invoker 对象。

------

# 21 服务调用（二）之远程调用（Dubbo）【1】通信实现 #

## 21.1 Server ##
Server 实现类是 HeaderExchangeServer 。

## 21.2 Client ##
Client 实现类是 ReferenceCountExchangeClient 和 LazyConnectExchangeClient 。

## 21.3 ExchangeHandler ##
在 DubboProtocol 中，实现了 ExchangeHandler。
这个处理器，负责将请求，转发到对应的 Invoker 对象，执行逻辑，返回结果。

## 21.4 Codec ##
在 ExchangeCodec 中，我们看到对 Request 和 Response 的通用解析。但是它是不满足在 dubbo:// 协议中，对 RpcInvocation 和 RpcResult 作为 内容体( Body ) 的编解码的需要的。
另外，在 dubbo:// 协议中，支持 参数回调 的特性，也是需要在编解码做一些特殊逻辑。

### 21.4.1 DubboCountCodec ###
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec ，实现 Codec2 接口，支持多消息的编解码器。

#### 21.4.1.1 构造方法 ####
在 Dubbo Client 和 Server 创建的过程，我们看到设置了编解码器为 "dubbo" ，从而通过 Dubbo SPI 机制，加载到 DubboCountCodec 。
````
private DubboCodec codec = new DubboCodec();
````
#### 21.4.1.2 编码 ####
调用
````
codec.encode(channel, buffer, msg);
````
#### 21.4.1.3 解码 ####
包含两块逻辑：1）多消息解析的支持。2）记录每条消息的长度，用于 MonitorFilter 监控。

基本流程如下：
1. 记录当前读位置，用于下面计算每条消息的长度。
2. 创建 MultiMessage 对象。MultiMessageHandler 支持对它的处理分发。
3. 循环解析消息，直到结束。
4. 调用 DubboCodec#decode(channel, buffer) 方法，解码。
5. 字节数组不够，重置读进度，结束解析。
6. 解析到消息，添加到 result 。
7. 调用 #logMessageLength(obj, length) 方法，记录消息长度到隐式参数集合，用于 MonitorFilter 监控。
8. 记录当前读位置，用于计算下一条消息的长度。
9. 返回结果。

### 21.4.2 DubboCodec ###
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec ，实现 Codec2 接口，继承 ExchangeCodec 类，Dubbo 编解码器实现类。

#### 21.4.2.1 编码内容体 ####

##### 21.4.2.1.1 请求 #####

基本流程如下：
1. 编码 RpcInvocation 对象，写入需要编码的字段。
2. 对应的解码，在 DecodeableRpcInvocation 中。
3. 调用 CallbackServiceCodec#encodeInvocationArgument(...) 方法，编码参数。主要用于 参数回调 功能。

##### 21.4.2.1.2 响应 #####

编码 Result 对象，写入需要编码的字段。
对应的解码，在 DecodeableRpcResult 中。


#### 21.4.2.2 解码内容体 ####

基本流程如下：
1. 调用 CodeSupport#getSerialization(url, proto) 方法，获得 Serialization 对象，用于下面反序列化内容体的每个字段。
2. 获得请求或响应的编号。
3. 解析响应( Response )。
4. 解析请求( Request )。

##### 21.4.2.2.1 请求 #####
解码普通响应。
相同点，使用 DecodeableRpcResult 解码。前者，比较好理解；后者，在 DecodeHandler 中，才最终调用 DecodeableRpcResult#decode() 方法。
差异点，使用哪个线程解码。前者，还是比较好理解，当前线程，即通信框架（例如，Netty）的 IO 线程。后者，Dubbo ThreadPool 线程中。
decode.in.io 配置项，目前在 Dubbo 文档中，并未说明，应该是性能调优

##### 21.4.2.2.2 响应 #####
和请求类似，差异点在使用 DecodeableRpcInvocation 。

### 21.4.3 DecodeableRpcInvocation ###
com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation ，实现 Codec 和 Decodeable 接口，继承 RpcInvocation 类，可解码的 RpcInvocation 实现类。
当服务消费者，调用服务提供者，前者编码的 RpcInvocation 对象，后者解码成 DecodeableRpcInvocation 对象。
从目前的代码实现来看，Codec 接口，可不实现。

### 21.4.4 DecodeableRpcResult ###

和 DecodeableRpcInvocation 一致。

------

# 22 服务调用（二）之远程调用（Dubbo）【2】同步调用 #

## 22.1 消费者调用服务 ##

调用 DubboInvoker#invoke(Invocation) 方法，调用服务。基本流程如下

1. 调用 RpcUtils#getMethodName() 方法，获得方法名。
2. 获得 path( 服务名 )、version 。
3. 顺序，获得 ExchangeClient 对象。
4. 调用 RpcUtils#isAsync(url, invocation) 方法，判断是否异步调用。
	- 获得是否异步。服务引用或方法，任一配置 async = true ，即为异步。
5. 调用 RpcUtils#isOneway(url, invocation) 方法，判断是否异步调用。
	- 获得是否单向。方法配置 return = true ，即为单向。
6. 调用 URL#getMethodParameter(method, key, defaultValue) 方法，获得远程调用超时时间，单位：毫秒。
7. oneway 单向调用。
	1. 注意，调用的是 ExchangeClient#send(invocation, sent) 方法，发送消息，而不是请求。
	2. 设置 RpcContext.future = null ，无需 FutureFilter ，异步回调。
	3. 创建 RpcResult 对象，空返回。
8. async 异步调用。
	1. 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求。
	2. 调用 RpcContext#setFuture(future) 方法，在 FutureFitler 中，异步回调。
	3. 创建 RpcResult 对象，空返回。
9. sync 同步调用。
	1. 设置 RpcContext.future = null ，无需 FutureFilter ，异步回调。
	2. 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求。
	3. 调用 ResponseFuture#get() 方法，阻塞等待，返回结果。

## 22.2 提供者提供服务 ##
在 DubboProtocol 类中，实现了自己的 ExchangeHandler 对象，处理请求、消息、连接、断开连接等事件。对于服务消费者的远程调用，通过 #reply(ExchangeChannel channel, Object message) 和 #reply(Channel channel, Object message) 方法来处理。

### 22.2.1 reply ###
用于处理服务消费者的同步调用和异步调用的请求。

基本流程如下：
1. 调用 #getInvoker(channel, invocation) 方法，获得请求对应的 Invoker 对象。
	1. 如果是参数回调，获得真正的服务名 path 。
	2. 调用 #serviceKey(port, path, version) 方法，获得服务键。
	3. 从 exporterMap 集合中，获得 Exporter 对象。
	4. 获得 Invoker 对象。
2. 如果是参数回调，校验服务消费者实际存在对应的回调方法，通过方法名判断。
3. 设置调用方的地址。
4. 调用 Invoker#invoke(invocation) 方法，执行调用，并返回结果。

### 22.2.2 received ###
用于处理服务消费者的单次调用的消息，通过判断消息类型是不是 Invocation 。

### 22.2.3 connected && disconnected ###
在服务提供者上，有 "onconnect" 和 "ondisconnect" 配置项，在服务提供者连接或断开连接时，调用 Service 对应的方法。目前这个配置项，在 Dubbo 文档里，暂未提及。当然，这个在实际场景下，基本没用过。

调用 #invoke(channel, methodKey) 方法，执行对应的方法。

------

# 23 服务调用（三）之远程调用（Dubbo）【3】异步调用 #

## 23.1 FutureAdapter ##
com.alibaba.dubbo.rpc.protocol.dubbo.FutureAdapter ，实现 Future 接口，适配 ResponseFuture 。通过这样的方式，对上层调用方，透明化 ResponseFuture 的存在。

## 23.2 FutureFilter ##
com.alibaba.dubbo.rpc.protocol.dubbo.filte.FutureFilter ，实现 Filter 接口，事件通知过滤器。

@Activate(group = Constants.CONSUMER) 注解，基于 Dubbo SPI Activate 机制，只有服务消费者才生效该过滤器。

基本流程如下：
1. 调用 RpcUtils#isAsync(url, invocation) 方法，判断是否异步调用。
2. 调用 #fireInvokeCallback(invoker, invocation) 方法，触发前置方法。
3. 调用 invoker#invoke(invocation) 方法，调用服务提供者，即 Dubbo RPC 。
4. 触发回调方法。
	1. 若是异步调用，调用 #asyncCallback(invoker, invocation) 方法，执行异步回调。
	2. 若非异步调用，调用 #syncCallback(invoker, invocation) 方法，执行同步回调。
5. 返回结果。如果是异步调用或单向调用，所以返回结果是空的。

### 23.2.1 fireInvokeCallback ###

基本流程如下：
1. 获得前置方法和对象。
2. 反射调用前置方法。


### 23.2.2 syncCallback ###
fireThrowCallback(invoker, invocation, exception) 方法，触发异常回调方法

fireReturnCallback(invoker, invocation, result) 方法，触发正常回调方法

### 23.2.3 asyncCallback ###
异步回调：设置正常回调和异常回调的方法。

----

# 24 服务调用（三）之远程调用（HTTP） #
http:// 协议的远程调用，主要分成三个部分：

- 服务暴露
- 服务引用
- 服务调用

对应项目为 dubbo-rpc-http 。
基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现

## 24.1 AbstractProxyProtocol ##
com.alibaba.dubbo.rpc.protocol.AbstractProxyProtocol ，实现 AbstractProtocol 抽象类，Proxy 协议抽象类。为 HttpProtocol 、RestProtocol 等子类，提供公用的服务暴露、服务引用的公用方法，同时定义了如下抽象方法，用于不同子类协议实现类的自定义的逻辑：

````
/**
 * 执行暴露，并返回取消暴露的回调 Runnable
 *
 * @param impl 服务 Proxy 对象
 * @param type 服务接口
 * @param url URL
 * @param <T> 服务接口
 * @return 消暴露的回调 Runnable
 * @throws RpcException 当发生异常
 */
protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;

/**
 * 执行引用，并返回调用远程服务的 Service 对象
 *
 * @param type 服务接口
 * @param url URL
 * @param <T> 服务接口
 * @return 调用远程服务的 Service 对象
 * @throws RpcException 当发生异常
 */
protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;
````
### 24.1.1 构造方法 ###
rpcExceptions 属性，不同协议的远程调用，会抛出的异常是不同的。在 #refer(Class, URL) 方法中，我们会看到对这个属性的使用，理解会更清晰一些。

### 24.1.2 export ###

暴露服务，基本流程如下：
1. 调用 #serviceKey(url) 方法，获得服务键。
2. 从 exporterMap 中，获得 Exporter 对象。若已经暴露，直接返回。
3. 调用 ProxyFactory#getProxy(invoker) 方法，获得 Service Proxy 对象。
4. 调用 #doExport(impl, type, url) 抽象方法，执行子类实现的暴露服务。
5. 创建 Exporter 对象。基于 AbstractExporter 抽象类实现，覆写 #unexport() 方法
	1. 取消暴露。
	2. 调用 Runnable#run() 方法，执行取消暴露的回调方法。
3. 添加到 Exporter 集合。

### 24.1.3 refer ###
Invoker 集合

基本流程：
1. 调用 #doRefer(type, url) 抽象方法，执行子类实现的引用服务。
2. 调用 ProxyFactory#getInvoker(proxy, type, url) 方法，获得 Invoker 对象。
3. 创建 Invoker 对象。基于 AbstractExporter 抽象类实现，覆写 #doInvoke(invocation) 方法
	1. 调用 Invoker#invoke(invocation) 方法，执行 RPC 调用。
	2. 若返回结果带有异常，并且需要抛出( 异常在 rpcExceptions 中)，则抛出异常。
	3. 返回调用结果。
	4. 若捕捉到 RpcException 异常，调用 #getErrorCode(Throwable) 方法，获得异常对应的错误码。
		- 子类协议实现类，一般会覆写这个方法，实现自己异常的翻译。
	5. 若捕捉到 Throwable 异常，调用 #getRpcException(type, url, invocation, e) 方法，包装成 RpcException 异常，
4. 添加到 Invoker 集合。

## 24.2 HttpProtocol ##
com.alibaba.dubbo.rpc.protocol.http.HttpProtocol ，实现 AbstractProxyProtocol 抽象类，dubbo:// 协议实现类。

- serverMap 属性，HttpServer 集合。键为 ip:port ，通过 #getAddr(url) 方法，计算
- skeletonMap 属性，Spring HttpInvokerServiceExporter 集合。请求处理过程为 HttpServer => DispatcherServlet => InternalHandler => HttpInvokerServiceExporter 。
- httpBinder 属性，HttpBinder$Adaptive 对象，通过 #setHttpBinder(httpBinder) 方法，Dubbo SPI 调用设置。

### 24.2.1 doExport ###
基于 dubbo-remoting-http 项目，作为通信服务器。基本流程如下：
1. 调用 #getAddr(url) 方法，获得服务器地址。
2. 从 serverMap 中，获得 HttpServer 对象。若不存在，调用 HttpBinder#bind(url, handler) 方法，创建 HttpServer 对象。此处使用的 InternalHandler
3. 创建 HttpInvokerServiceExporter 对象。
4. 添加到 skeletonMap 集合中。
5. 返回取消暴露的回调 Runnable 对象。

# 25 服务调用（四）之远程调用（Hessian） #

定义如下：
Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。

Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：

- 提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用
- 或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。

整体实现和 dubbo-rpc-http 一致

## 25.1 HttpClientConnection ##
com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnection ，实现 HessianConnection 接口，HttpClient 连接器实现类。

基于 Apache HttpClient 封装。

### 25.1.1 HttpClientConnectionFactory ###

com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory ，实现 HessianConnectionFactory 接口，创建 HttpClientConnection 的工厂

## 25.2 HessianProtocol ##
com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol ，实现 AbstractProxyProtocol 抽象类，hessian:// 协议实现类。

### 25.2.1 构造方法 ###

````
/**
 * Http 服务器集合
 * serverMap 属性，HttpServer 集合。键为 ip:port ，通过 #getAddr(url) 方法，计算
 * key：ip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * Spring HttpInvokerServiceExporter 集合
 * skeletonMap 属性，com.caucho.hessian.server.HessianSkeleton 集合。请求处理过程为 HttpServer => DispatcherServlet => HessianHandler => HessianSkeleton 。
 * key：path 服务名
 */
private final Map<String, HessianSkeleton> skeletonMap = new ConcurrentHashMap<String, HessianSkeleton>();
/**
 * httpBinder 属性，HttpBinder$Adaptive 对象，通过 #setHttpBinder(httpBinder) 方法，Dubbo SPI 调用设置。
 * HttpBinder$Adaptive 对象
 */
private HttpBinder httpBinder;

public HessianProtocol() {
    super(HessianException.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
````

### 25.2.2 doExport ###
基于 dubbo-remoting-http 项目，作为通信服务器。

基本流程如下：
1. 调用 #getAddr(url) 方法，获得服务器地址。
2. 从 serverMap 中，获得 HttpServer 对象。若不存在，调用 HttpBinder#bind(url, handler) 方法，创建 HttpServer 对象。此处使用的 HessianHandler ，下文详细解析。
3. 创建 HessianSkeleton 对象，添加到 skeletonMap 集合中。
4. 返回取消暴露的回调 Runnable 对象。

#### 25.2.2.1 HessianHandler ####
基本流程如下：
1. 获得 HessianSkeleton 对象
2. 必须是 POST 请求
3. 执行调用

### 25.2.3 doRefer ###
基于 HttpClient ，作为通信客户端。

基本流程如下：
1. 创建 com.caucho.hessian.client.HessianProxyFactory 对象。
2. 创建连接器工厂为 com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory 。
3. 设置超时时间。
4. 调用 HessianProxyFactory#create(Class<?> api, URL url, ClassLoader loader) 方法，生成 Service Proxy 对象。

#### 25.2.3.1 getErrorCode ####
将异常，翻译成 Dubbo 异常码

### 25.2.4 destroy ###
销毁serverMap内保存的HttpServer

----

# 26 服务调用（五）之远程调用（WebService） #
定义如下：

基于 WebService 的远程调用协议，基于 Apache CXF 的 frontend-simple 和 transports-http 实现。
可以和原生 WebService 服务互操作，即：

- 提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用，
- 或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。

整体实现和 dubbo-rpc-http 一致

## 26.1 WebServiceProtocol ##
com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol ，实现 AbstractProxyProtocol 抽象类，webservice:// 协议实现类。


### 26.1.1 构造方法 ###

````
/**
 * 默认服务器端口
 */
public static final int DEFAULT_PORT = 80;
/**
 * Http 服务器集合
 * 属性，HttpServer 集合。键为 ip:port ，通过 #getAddr(url) 方法，计算。
 * key：ip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * 在CXF中，我觉得Bus更像是一个全局配置仓库，你可以向Bus中存放任何你想存放的扩展对象，你也可以从Bus中获取你想要的扩展对象，这个Bus将CXF中的各扩展模块有机地组合在一起了。
 */
private final ExtensionManagerBus bus = new ExtensionManagerBus();
/**
 *
 */
private final HTTPTransportFactory transportFactory = new HTTPTransportFactory();
/**
 * HttpBinder$Adaptive 对象
 * httpBinder 属性，HttpBinder$Adaptive 对象，通过 #setHttpBinder(httpBinder) 方法，Dubbo SPI 调用设置。
 */
private HttpBinder httpBinder;

public WebServiceProtocol() {
    super(Fault.class);
    bus.setExtension(new ServletDestinationFactory(), HttpDestinationFactory.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
````

### 26.1.2 doExport ###
基于 dubbo-remoting-http 项目，作为通信服务器。

基本流程如下：
1. 调用 #getAddr(url) 方法，获得服务器地址。
2. 从 serverMap 中，获得 HttpServer 对象。若不存在，调用 HttpBinder#bind(url, handler) 方法，创建 HttpServer 对象。此处使用的 WebServiceHandler ，下文详细解析。
3. 创建 ServerFactoryBean 对象。
4. 返回取消暴露的回调 Runnable 对象。

#### 26.1.2.1 WebServiceHandler ####
基本流程如下：
1. 创建 ServletController 对象，设置使用 DispatcherServlet 。
2. 设置调用方地址
3. 执行调用

### 26.1.3 doRefer ###
基本流程如下：
1. 创建 ClientProxyFactoryBean 对象。
2. 创建 Service Proxy 对象。
3. 设置超时相关属性。

### 26.1.4 getErrorCode ###
将异常，翻译成 Dubbo 异常码。

----

# 27 服务调用（六）之远程调用（REST） #
对应项目为 dubbo-rpc-rest 。
在 dubbo-rpc-rest 项目中，目前使用使用的是 RedHat 的 Resteasy 。


//  todo 待补充

------

# 28 服务调用（七）之远程调用（WebService） #
//  todo 待补充

------

# 29 服务调用（八）之远程调用（Redis） #
//  todo 待补充

------

# 30 服务调用（九）之远程调用（Memcached） #
//  todo 待补充

------

# 31 调用特性（一）之回声测试 #
回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。

## 31.1 服务消费者 ##

### 31.1.1 EchoService ###
所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。
在 AbstractProxyFactory 中，#getProxy(invoker) 方法，创建服务消费者的 Proxy 对象时，自动实现 EchoService 接口

### 31.1.2 使用示例 ###

Spring 配置：

````
<dubbo:reference id="memberService" interface="com.xxx.MemberService" />
````

代码：

````
// 远程服务引用
MemberService memberService = ctx.getBean("memberService"); 

EchoService echoService = (EchoService) memberService; // 强制转型为EchoService

// 回声测试可用性
String status = echoService.$echo("OK"); 

assert(status.equals("OK"));
````

## 31.2 服务提供者 ##

服务提供者，是不实现 EchoService 接口，而是通过 EchoFilter 实现。

com.alibaba.dubbo.rpc.filter.EchoFilter ，实现 Filter 接口，回声过滤器

- 使用 Dubbo SPI Adaptive 机制，自动加载，仅限服务提供者。
- 如果调用方法是回声调用时，通过方法名( $echo ) 和方法参数数量为 1 ，直接返回方法参数。
- 若果调用方法非回声调用时，调用 Invoker#invoke(invocation) 方法，继续走后面的过滤链。

------

# 32 调用特性（二）之泛化引用 #
泛化接口调用方式主要用于客户端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过 GenericService 调用所有服务实现。

请注意，消费消费者没有 API 接口 及 模型类元。那就是说，Dubbo 在泛化引用中，需要做两件事情：

- 没有 API 接口，所以提供一个泛化服务接口，目前是 com.alibaba.dubbo.rpc.service.GenericService 
	- 一个泛化引用，只对应一个服务实现。
	- 通过 $invoke(method, parameterTypes, args) 方法，可以实现服务的泛化调用。
- 没有 模型类元，所以方法参数和方法返回若是 POJO ( 例如 User 和 Order 等 ) ，需要转换处理：
	- 服务消费者，将 POJO 转成 Map ，然后再调用服务提供者。
	- 服务提供者，接收到 Map ，转换成 POJO ，再调用 Service 方法。若返回值有 POJO ，则转换成 Map 再返回。

整体流程如下：

![](/picture/dubbo-generic-flow.png)

## 32.1 示例 ##

### provider ###
````
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Provider {

    public static void main(String[] args) throws Exception {
        System.setProperty("java.net.preferIPv4Stack", "true");
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{"META-INF/spring/dubbo-demo-provider.xml"});
        context.start();
        System.in.read(); // press any key to exit
    }
}
````
````
import com.alibaba.dubbo.rpc.service.GenericException;
import com.alibaba.dubbo.rpc.service.GenericService;

public class DemoServiceImpl implements GenericService {
    @Override
    public Object $invoke(String method, String[] parameterTypes, Object[] args) throws GenericException {
        if ("sayHello".equals(method)) {
            return "Welcome " + args[0];
        }
        return "unknown method";
    }
}
````
````
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd">
    <dubbo:application name="demo-provider"/>
    <dubbo:provider delay="-1" retries="0"  >
    </dubbo:provider>
    <dubbo:registry address="zookeeper://127.0.0.1:2181" />
    <bean id="demoService" class="com.alibaba.dubbo.demo.provider.DemoServiceImpl"/>
    <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" generic="true" timeout="200000" />
    <dubbo:protocol name="dubbo" port="20880" />
</beans>
````

### consumer ###

````
import com.alibaba.dubbo.demo.DemoService;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Consumer {

    public static void main(String[] args) {
        System.setProperty("java.net.preferIPv4Stack", "true");
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{"META-INF/spring/dubbo-demo-consumer.xml"});
        context.start();
        DemoService demoService = (DemoService) context.getBean("demoService"); // get remote service proxy
        while (true) {
            try {
                Thread.sleep(1000);
                Object result = demoService.say01("NIHAO");
                System.out.println("result: " + result);

            } catch (Throwable throwable) {
                throwable.printStackTrace();
            }
        }
    }
}

````
````
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd">
    <dubbo:application name="demo-consumer" />
    <dubbo:registry address="zookeeper://127.0.0.1:2181"/>
    <dubbo:reference id="demoService" check="false" interface="com.alibaba.dubbo.demo.DemoService" timeout="100000">
    </dubbo:reference>
</beans>
````

### 32.1.2 有关泛化类型的进一步解释 ###
假设存在 POJO 如：

````
public class PersonImpl implements Person {
    private String name;
    private String password;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
````

则 POJO 数据：
````
Person person = new PersonImpl(); 
person.setName("xxx"); 
person.setPassword("yyy");
````
【服务消费者】可用下面 Map 表示：

````
Map<String, Object> map = new HashMap<String, Object>(); 
// 注意：如果参数类型是接口，或者List等丢失泛型，可通过class属性指定类型。
map.put("class", "com.xxx.PersonImpl"); 
map.put("name", "xxx"); 
map.put("password", "yyy");
````
- Map 中的 class 属性，在 PojoUtils 中，会根据该属性，将 Map 转换成 POJO 对象。

## 32.2 服务消费者 GenericImplFilter ##
com.alibaba.dubbo.rpc.filter.GenericImplFilter ，实现 Filter 接口，服务消费者的泛化调用过滤器。

- 使用 Dubbo SPI Adaptive 机制，自动加载，仅限服务消费者，并且有 generic 配置项。
	- RegistryDirectory#mergeUrl(providerUrl) 方法，它会将服务消费者的配置( URL )项，覆盖到服务提供者的 URL 。
	- 又因为泛化引用时，我们会在服务消费者的配置 generic = true ，那么服务提供者 URL 自然就有了该配置项，所以便有了 GenericImplFilter 过滤器。

基本流程如下：
1. 获得 generic 配置项。
2. 省略用于调用泛化实现服务的代码
3. 泛化引用的调用，通过方法( 包括方法名、参数 ) + generic 配置项，进行判断。
	1. 根据不同的 generic 配置项，校验方法参数是否已经正确序列化。若不合法，调用 #error(expected, actual) 方法，抛出 RpcException 异常。
	2. 调用 RpcInvocation#setAttachment(key, value) 通过隐式参数，传递 generic 配置项。
4. 调用 Invoker#invoke(invocation) 方法，继续过滤链的调用，最终 RPC 调用。

## 32.3 服务提供者 GenericFilter ##
com.alibaba.dubbo.rpc.filter.GenericFilter ，实现 Filter 接口，服务消费者的泛化调用过滤器

使用 Dubbo SPI Adaptive 机制，自动加载，仅限服务提供者。若是普通调用( 非泛化引用的调用 )，调用 Invoker#invoke(invocation) 方法，继续过滤链的调用，最终调用 Service 服务。 若是泛化引用的调用，通过方法( 包括方法名、参数 )判断

基本流程如下：
1. 调用 ReflectUtils#findMethodByMethodSignature(Class<?> clazz, String methodName, String[] parameterTypes) 方法，通过反射，获得对应的方法 Method 对象。
2. 获得方法参数类型和方法参数数组。
3. 获得 generic 配置项。

【反序列化参数】

1. generic = true ，调用 PojoUtils#realize(Object[] objs, Class<?>[] types, Type[] gtypes) 方法，反序列化参数。注意，在该方法中，只有带有 class 属性的 Map ，需要反序列化成对应的 POJO 对象。
2. generic = nativejava ，调用 NativeJavaSerialization#deserialize(url, input) 方法，反序列化参数，即 byte[] => 方法参数 。
3. generic = bean ，调用 JavaBeanSerializeUtil#deserialize(JavaBeanDescriptor) 方法，反序列化参数，即 JavaBeanDescriptor => 方法参数 。

【方法调用】

1. 创建新的 RpcInvocation 对象。这是非常关键的一步，$invoke 的泛化调用，被转换成具体的普通调用。
2. 调用 Invoker#invoke(invocation) 方法，继续过滤链的调用，最终调用 Service 服务。

【序列化结果】

- 若是异常结果，并且非 GenericException 异常，可能这个异常在服务消费端是没有的，因此需要使用 GenericException 包装后返回。
- generic = nativejava ，调用 NativeJavaSerialization#serialize(url, output) 方法，序列化结果，即 结果 => byte[] 。
- generic = bean ，调用 JavaBeanSerializeUtil#serialize(Object, JavaBeanAccessor) 方法，序列化结果，即 结果 => JavaBeanDescriptor 。
- generic = true ，调用 PojoUtils#generalize(Object) 方法，序列化结果，仅有 POJO => Map 。

----

# 33 调用特性（三）之泛化实现 #
泛接口实现方式主要用于服务器端没有API接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。
通过前面的例子可以看出，服务调用者和和我们普通的服务消费者，调用服务提供者，一模一样，注意，是一模一样。

## 33.1 服务消费者 GenericImplFilter ##
com.alibaba.dubbo.rpc.filter.GenericImplFilter ，实现 Filter 接口，服务消费者的泛化调用过滤器。

- 整体，和服务提供者的 GenericFilter 有一些类似。
- 使用 Dubbo SPI Adaptive 机制，自动加载，仅限服务消费者，并且有 generic 配置项。
- 若是普通调用( 非泛化引用的调用 )，调用 Invoker#invoke(invocation) 方法，继续过滤链的调用，最终调用 Service 服务。

基本流程如下
1. 判断是泛化实现的调用
2. 获得参数类型数组。

【序列化参数】
- generic = bean ，调用 JavaBeanSerializeUtil#serialize(JavaBeanDescriptor) 方法，序列化参数，即 方法参数 => JavaBeanDescriptor 。
- generic = true ，调用 PojoUtils#generalize(Object[] objs 方法，序列化参数，仅有 POJO => Map 。

【RPC 调用】
- 设置 RpcInvocation 的方法名为 $invoke 。
- 设置 RpcInvocation 的方法参数类型为 GENERIC_PARAMETER_TYPES 。
- 设置 RpcInvocation 的参数数组为 methodName types types 。
- 通过如上的 RpcInvocation 的设置，我们调用 Invoker#invoke(invocation) 方法，就能 RPC 调用到泛化实现的服务。

【反序列化正常结果】
- generic = bean ，调用 JavaBeanSerializeUtil#serialize(JavaBeanDescriptor) 方法，反序列化结果，即 JavaBeanDescriptor => POJO 。
- generic = true ，调用 PojoUtils#realize(pojo, type, genericType) 方法，反序列化结果，仅有 Map => POJO 。
- 注意，反序列完，是会创建新的 RpcResult 。 

【反序列化异常结果】
- 根据 GenericException 异常，创建原始异常 targetException 。
- 设置异常明细到 targetException 。
- 创建新的异常 RpcResult 对象。
- 创建原始异常失败，抛出异常 lastException 。

----

# 34 过滤器（一）之 ClassLoaderFilter #
在 ProtocolFilterWrapper 中，在服务引用和暴露时，#buildInvokerChain(invoker, key, group) 方法中，基于 Dubbo SPI Active 机制，加载匹配对应的过滤器数组，创建带有过滤器链的 Invoker 对象。

## 34.1 ClassLoaderFilter ##
com.alibaba.dubbo.rpc.filter.ClassLoaderFilter ，实现 Filter 接口，类加载器切换过滤器实现类

基本流程如下：
1. 调用 Thread#getContextClassLoader() 方法，获得原来的类加载器。
2. 调用 Thread#setContextClassLoader(ClassLoader) 方法，切换当前线程的类加载器为服务接口的类加载器。
3. 调用 Invoker#invoke(invocation) 方法，服务调用。
4. 调用 Thread#setContextClassLoader(ClassLoader) 方法，切换当前线程的类加载器为原来的类加载器。

使用这个filter的目的是：在设计目的中，切换到加载了接口定义的类加载器，以便实现与相同的类加载器上下文一起工作。例如：使用 PF4J 加载不同的服务实现类的 Jar ，不同的 Jar 的类加载器不同。

----

# 35 过滤器（二）之 ContextFilter #
RpcContext 相关过滤器，包括两个：

- ConsumerContextFilter ：在服务消费者中使用，负责发起调用时，初始化 RpcContext 。
- ContextFilter ：在服务提供者中使用，负责被调用时，初始化 RpcContext 。

## 35.1 RpcContext ##
RpcContext，上下文信息。定义如下：

上下文中存放的是当前调用过程中所需的环境信息。所有配置信息都将转换为 URL 的参数，参见 schema 配置参考手册 中的对应URL参数一列。
RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，
- 在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，
- 在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。

## 35.2 ConsumerContextFilter ##
com.alibaba.dubbo.rpc.filter.ConsumerContextFilter ，实现 Filter 接口，服务消费者的 ContextFilter 实现类。

基本流程如下：
1. 设置 RpcContext 对象。
2. 设置 RpcInvocation 对象的 invoker 属性。
3. 调用 Invoker#invoke(invocation) 方法，服务调用。
4. 调用 RpcContext#clearAttachments() 方法，清理隐式参数集合。所以，每次（注意，每次！！！）服务调用完成，RpcContext 设置的隐式参数都会被清理！

## 35.3 ContextFilter ##
com.alibaba.dubbo.rpc.filter.ContextFilter ，实现 Filter 接口，服务提供者的 ContextFilter 实现类。

基本流程如下：
1. 创建新的 attachments 集合，因为要清理公用的隐式参数。
2. 设置 RpcContext 对象。
3. 在此过滤器( 例如 RestProtocol 的 RpcContextFilter )之前，我们可能已经在 RpcContext 中添加了一些隐式参数。
4. 调用 Invoker#invoke(invocation) 方法，服务调用。
5. 调用 Invoker#invoke(invocation) 方法，服务调用。
6. 调用 RpcContext#removeContext() 方法，移除上下文。

## 35.4 RpcContext.values ##
目前 Dubbo 中，并未使用它。

----

# 36 过滤器（三）之 AccessLogFilter #

访问日志的过滤器 AccessLogFilter ，需要在 <dubbo:protocol /> 或 <dubbo:provider /> 或 <dubbo:service /> 中，设置 "accesslog" 配置项开启。有两种配置项选择：

- 【配置方式一】 true ：将向日志组件 logger 中输出访问日志。
- 【配置方式二】访问日志文件路径：直接把访问日志输出到指定文件。

## 36.1 AccessLogFilter ##

com.alibaba.dubbo.rpc.filter.AccessLogFilter ，实现 Filter 接口，记录服务的访问日志的过滤器实现类。

### 36.1.1 构造方法 ###
- 【配置方式一】
	- ACCESS_LOG_KEY
- 【配置方式二】
	- 文件相关：
		- FILE_DATE_FORMAT
		- MESSAGE_DATE_FORMAT
	- 队列相关：
		- logQueue
		- LOG_MAX_BUFFER
	- 任务相关：
		- logScheduled
		- LOG_OUTPUT_INTERVAL
		- logFuture
	- 日志流向为：logMessage => 队列 => 任务 => 文件。

### 36.1.2 invoke ###

基本流程如下：

1. 获得访问日志的配置项。
2. 获得服务的名字、版本、分组信息。
3. 拼接日志的内容。例子如下：

````
[2018-04-14 11:57:58] 192.168.3.17:57207 -> 192.168.3.17:20880 - com.alibaba.dubbo.demo.DemoService say01(java.lang.String) [null]

````

4. 调用 ConfigUtils#isDefault(value) 方法，判断是否使用日志组件记录日志。例如 Log4J 等等。
5. 调用 #log(accesslog, logMessage) 方法，添加日志内容到日志队列。

### 36.1.3 LogTask ###
LogTask 是 AccessLogFilter 的内部类
从 #init() 方法，我们可以看到，LogTask 每 5000 ( LOG_OUTPUT_INTERVAL ) 毫秒，执行一次。

基本流程如下：
1. 循环日志队列 logQueue 。注意，日志集合使用了 ConcurrentHashSet ，所以会有一定的乱序，在最终输出到指定文件后。
2. 获得日志文件。
3. 归档历史日志文件，例如：accesslog => access.20181023 。
	1. 注意，因为是按照文件最后修改时间，所以极端情况（写着写着到了第二天），那么就不会归档了。
4. 输出日志到指定文件。

**tips**
实际使用时，推荐使用 accesslog="true" 配置项。

# 37 过滤器（四）之 ActiveLimitFilter && ExecuteLimitFilter #

服务方法的最大可并行调用的限制过滤器，在服务消费者和提供者各有一个 LimitFilter ：

- ActiveLimitFilter ，在服务消费者，通过 <dubbo:reference /> 的 "actives" 统一配置项开启：
	- 每服务消费者，每服务的每方法最大并发调用数。
- ExecuteLimitFilter ，在服务提供者，通过 <dubbo:service /> 的 "executes" 统一配置项开启：
	- 服务提供者，每服务的每方法最大可并行执行请求数。

另外，在 <dubbo:method /> 的 "actives" 和 "executes" 配置项，可以自定义每个方法的配置。

## 37.1 RpcStatus ##
com.alibaba.dubbo.rpc.RpcStatus ，RPC 状态。可以计入如下维度统计：

- 基于服务 URL
- 基于服务 URL + 方法

用于 ActiveLimitFilter 和 ExecuteLimitFilter 中。

### 37.1.1 构造方法 ###



````
/**
 * 基于服务 URL 为维度的 RpcStatus 集合
 *
 * key：URL
 */
private static final ConcurrentMap<String, RpcStatus> SERVICE_STATISTICS = new ConcurrentHashMap<String, RpcStatus>();
/**
 * 基于服务 URL + 方法维度的 RpcStatus 集合
 *
 * key1：URL
 * key2：方法名
 */
private static final ConcurrentMap<String, ConcurrentMap<String, RpcStatus>> METHOD_STATISTICS = new ConcurrentHashMap<String, ConcurrentMap<String, RpcStatus>>();

// 目前没有用到
private final ConcurrentMap<String, Object> values = new ConcurrentHashMap<String, Object>();
/**
 * 调用中的次数
 */
private final AtomicInteger active = new AtomicInteger();
/**
 * 总调用次数
 */
private final AtomicLong total = new AtomicLong();
/**
 * 总调用失败次数
 */
private final AtomicInteger failed = new AtomicInteger();
/**
 * 总调用时长，单位：毫秒
 */
private final AtomicLong totalElapsed = new AtomicLong();
/**
 * 总调用失败时长，单位：毫秒
 */
private final AtomicLong failedElapsed = new AtomicLong();
/**
 * 最大调用时长，单位：毫秒
 */
private final AtomicLong maxElapsed = new AtomicLong();
/**
 * 最大调用失败时长，单位：毫秒
 */
private final AtomicLong failedMaxElapsed = new AtomicLong();
/**
 * 最大调用成功时长，单位：毫秒
 */
private final AtomicLong succeededMaxElapsed = new AtomicLong();

/**
 * Semaphore used to control concurrency limit set by `executes`
 *
 * 服务执行信号量，在 {@link com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter} 中使用
 */
private volatile Semaphore executesLimit;
/**
 * 服务执行信号量大小
 */
private volatile int executesPermits;
````



**静态属性**
SERVICE_STATISTICS 属性，基于服务 URL 为维度的 RpcStatus 集合。#getStatus(url) 静态方法，获得 RpcStatus 对象
METHOD_STATISTICS 属性，基于服务 URL + 方法为维度的 RpcStatus 集合。#getStatus(url, methodName) 静态方法，获得 RpcStatus 对象

**对象属性**
- 次数相关
	- active ，调用中的次数。这个属性在 ActiveLimitFilter 中非常关键。
	- total failed
- 时长相关
	- totalElapsed failedElapsed
	- failedElapsed failedMaxElapsed succeededMaxElapsed
- 信号量相关
	- executesLimit ，服务执行信号量。这个属性在 ExecuteLimitFilter 中非常关键。
	- executesPermits ，服务执行信号量大小。

### 37.1.2 beginCount ###

静态方法，在其内部，会调用两次 #beginCount(RpcStatus) 方法，分别计数。

### 37.1.3 endCount ###

静态方法，在其内部，会调用两次 #endCount(RpcStatus) 方法，分别计数。

### 37.1.4 getSemaphore ###

- 对象方法，获得信号量 executesPermits 属性。
- 创建信号量的条件，信号量 executesPermits 不存在，或者信号量大小 executesLimit 发生改变。我们会发生比较“神奇”的是，这个方法是直接返回 Semaphore 对象。考虑到有信号量大小改变的需求，但是信号量不支持批量修改大小，那么剩余的一种合适的方式，创建新的信号量对象。因此，这个方法就选择了直接返回 Semaphore 对象。

## 37.2 ActiveLimitFilter ##
com.alibaba.dubbo.rpc.filter.ActiveLimitFilter ，实现 Filter 接口，每服务消费者每服务、每方法的最大可并行调用数限制的过滤器实现类。

ActiveLimitFilter 基于 RpcStatus.active 属性，判断当前正在调用中的服务的方法的次数来判断。因为，需要有等待超时的特性，所以不使用 RpcStatus.semaphore 信号量的方式来实现。

基本流程如下：
1. 调用 URL#getMethodParameter(methodName, key, defaultValue) 方法，获得服务提供者每服务每方法最大可并行执行请求数。优先 <dubbo: method /> ，其次 <dubbo:reference /> 。
2. 调用 RpcStatus#getStatus(url, methodName) 方法，获得 RpcStatus 对象，基于服务 URL + 方法为维度。
3. 获得超时值。这里有一点需要注意，此处产生的等待时长，不占用调用服务的超时时长。所以，极端情况下的服务超时，约等于 2 * timeout 。
4. 超过最大可并行执行请求数，需要等待。
5. 通过锁定 synchronized ，有且仅有一个在等待。同时，也保证先调用的可以先执行。
6. 循环，等待可并行执行请求数。
7. 等待，直到超时，或者被唤醒
8. 判断若没有剩余时长了，抛出 RpcException 异常。
9. 调用 RpcStaus#beginCount(url, methodName) 方法，调用开始的计数。
10. 调用 Invoker#invoke(invocation) 方法，服务调用。
11. 调用 RpcStaus#endCount(url, methodName, true) 方法，调用开始的计数（成功）。
12. 调用 RpcStaus#endCount(url, methodName, false) 方法，调用开始的计数（失败）。
13. 唤醒等待的相同服务的相同方法的请求。

## 37.3 ExecuteLimitFilter ##

com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter ，实现 Filter 接口，服务提供者每服务、每方法的最大可并行执行请求数的过滤器实现类。

ActiveLimitFilter 基于 RpcStatus.semaphore 信号量属性，判断若超过最大可并行，抛出 RpcException 异常。

基本流程如下：
1. 调用 URL#getMethodParameter(methodName, key, defaultValue) 方法，获得服务提供者每服务每方法最大可并行执行请求数。优先 <dubbo: method /> ，其次 <dubbo:service /> 。
1. 调用 RpcStatus#getStatus(url, methodName) 方法，获得 RpcStatus 对象，基于服务 URL + 方法为维度。
1. 调用 RpcStatus#getSemaphore(max) 方法，获得 Semaphore 对象。
1. 调用 Semaphore#tryAcquire() 方法，若获得不到信号量，抛出 RpcException 异常。
1. 调用 RpcStaus#beginCount(url, methodName) 方法，调用开始的计数。
1. 调用 Invoker#invoke(invocation) 方法，服务调用。
1. 若发生异常，标记 isSuccess = false ，表示调用失败。
1. 调用 RpcStaus#endCount(url, methodName, success) 方法，调用开始的计数（成功）（失败）。
1. 调用 Semaphore#release() 方法，释放信号量。

----

# 38 过滤器（五）之 TimeoutFilter #

TimeoutFilter ，用于服务提供者中。

## 38.1 TimeoutFilter ##
com.alibaba.dubbo.rpc.filter.TimeoutFilter ，实现 Filter 接口，超时过滤器。如果服务调用超时，记录告警日志，不干涉服务的运行。

基本流程如下：
1. 调用 Invoker#invoke(invocation) 方法，服务调用。
2. 计算调用时长。
3. 超过时长，打印告警日志。注意，此处的 "timeout" 取得的是服务提供者的配置，不同于服务消费者的配置。
4. 返回调用结果。

在服务提供者，执行服务调用时，即使超过了超时时间，也不会取消执行。虽然，服务消费者，已经结束调用，返回调用超时。

----

# 39 过滤器（六）之 DeprecatedFilter #
DeprecatedFilter ，用于服务消费者中，通过 <dubbo: service /> 或 <dubbo:reference /> 或 <dubbo:method /> 的 "deprecated" 配置项为 true 来开启。

## 39.1 DeprecatedFilter ##
com.alibaba.dubbo.rpc.filter.DeprecatedFilter ，实现 Filter 接口，废弃调用的过滤器实现类。当调用废弃的服务方法时，打印错误日志提醒。

基本属性：logged 静态属性，已经打印日志的方法集合。

基本流程如下：
1. 获得方法名。
2. 打印告警日志。一个服务的方法，有且仅有打印一次。
3. 调用 Invoker#invoke(invocation) 方法，服务调用。

----

# 40 过滤器（七）之 ExceptionFilter #

异常过滤器 ExceptionFilter ，用于服务提供者中。用途如下：

1. 不期望的异常打 ERROR 日志( Provider端 )。不期望的日志即是，没有的接口上声明的Unchecked异常。
1. 异常不在 API 包中，则 Wrap 一层 RuntimeException 。RPC 对于第一层异常会直接序列化传输( Cause 异常会 String 化) ，避免异常在 Client 出不能反序列化问题。

- 和我们平时业务写的用于捕捉异常的过滤器或者拦截器不太一样，而是关注点在服务消费者会不会出现不存在该异常类，导致反序列化的问题。

## 40.1 ExceptionFilter ##

com.alibaba.dubbo.rpc.filter.ExceptionFilter ，实现 Filter 接口，异常过滤器实现类

基本流程如下：
1. 调用 Invoker#invoke(invocation) 方法，服务调用。
2. 调用结果有异常，并且非泛化调用。
3. 如果是 checked 异常，直接返回。因为，checked 异常，肯定定义在接口上了。
4. 在接口方法的签名有生命，直接返回结果。
5. 未在方法签名上定义的异常，在服务器端打印 ERROR 日志。
6. 异常类和接口类在同一 jar 包里，直接返回结果。因为，服务消费者可以反序列化该异常。
7. 是 JDK 自带的异常，直接返回结果。
8. 是 Dubbo 本身的异常，直接返回结果。
9. 否则，包装成 RuntimeException 异常返回给服务消费者，同时把异常堆栈给包进去。

# 41 过滤器（八）之 TokenFilter #
TokenFilter 过滤器，用于服务提供者中，提供 令牌验证 的功能。定义如下：

通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者。
另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者。

## 41.1 【服务消费者】随机 Token ##
在 ServiceConfig 的 #doExportUrlsFor1Protocol(protocolConfig, registryURLs) 方法中，随机生成 Token 

## 41.2 【服务消费者】接收 Token ##
服务消费者，从注册中心，获取服务提供者的 URL ，从而获得该服务着的 Token 。
所以，即使服务提供者随机生成 Token ，消费者一样可以拿到。

## 41.3 【服务消费者】发送 Token ##
RpcInvocation 在创建时，“自动”带上 Token 

## 41.4 【服务提供者】认证 Token ##
com.alibaba.dubbo.rpc.filter.TokenFilter ，实现 Filter 接口，令牌验证 Filter 实现类。

------

# 42 过滤器（九）之 TpsLimitFilter #
TpsLimitFilter 过滤器，用于服务提供者中，提供 限流 的功能。

配置方式

- 通过 <dubbo:parameter key="tps" value="" /> 配置项，添加到 <dubbo:service /> 或 <dubbo:provider /> 或 <dubbo:protocol /> 中开启，例如：

````
<dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoServiceImpl" protocol="injvm" >
    <dubbo:parameter key="tps" value="100" />
</dubbo:service>
````

- 通过 <dubbo:parameter key="tps.interval" value="" /> 配置项，设置 TPS 周期。

## 42.1 TpsLimitFilter ##
com.alibaba.dubbo.rpc.filter.TpsLimitFilter ，实现 Filter 接口，TPS 限流过滤器实现类。

基本流程如下：
1. 调用 TPSLimiter#isAllowable(url, invocation) 方法，根据 tps 限流规则判断是否限制此次调用。若是，抛出 RpcException 异常。目前使用 TPSLimiter 作为限流器的实现类。
2. 调用 Invoker#invoke(invocation) 方法，服务调用。

## 42.2 TPSLimiter ##
com.alibaba.dubbo.rpc.filter.tps.TPSLimiter ，TPS 限制器接口。

### 42.2.1 DefaultTPSLimiter ###
com.alibaba.dubbo.rpc.filter.tps.DefaultTPSLimiter ，实现 TPSLimiter 接口，默认 TPS 限制器实现类，以服务为维度。

属性：
stats 属性，StatItem 集合，Key 为 服务名，即以服务为维度。

基本流程如下：
1. 获得 TPS 大小配置项 "tps"。
1. 获得 TPS 周期配置项 "tps.interval"，默认 60 * 1000 毫秒。
1. 若要限流，调用 StatItem#isAllowable(url, invocation) 方法，根据 TPS 限流规则判断是否限制此次调用。
1. 若不限流，移除 StatItem 对象。

### 42.2.2 StatItem ###
com.alibaba.dubbo.rpc.filter.tps.StatItem ，统计项。

#### 42.2.2.1 构造方法 ####

#### 42.2.2.2 isAllowable ####

----

# 43 过滤器（十）之 CacheFilter #

dubbo-filter-cache 项目的 CacheFilter 过滤器，用于服务消费者和提供者中，提供 结果缓存 的功能。

结果缓存 ，用于加速热门数据的访问速度，Dubbo 提供声明式缓存，以减少用户加缓存的工作量。

Dubbo 提供了三种实现：
- lru ：基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。
- threadlocal ：当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。
- jcache ：与 JSR107 集成，可以桥接各种缓存实现。

## 43.1 CacheFilter ##
com.alibaba.dubbo.cache.filter.CacheFilter ，实现 Filter 接口，缓存过滤器实现类。

基本流程如下：
1. 判断方法开启 Cache 功能。因为，一个服务里，可能只有部分方法开启了 Cache 功能。
2. 调用 CacheFactory$Adaptive#getCache(url) 方法，基于 URL + Method 为维度，获得 Cache 对象。
3. 调用 StringUtils#toArgumentString(Object[] args) 方法，获得 Cache Key 。
4. 调用 Cache#get(key) 方法，从缓存中获得结果。若存在，创建 RpcResult 对象并返回。
5. 调用 Invoker#invoke(invocation) 方法，服务调用。
6. 若非异常，调用 Cache#put(key, value) 方法，缓存正常的结果。
7. 返回调用结果。
8. 若不使用 Cache 功能，直接调用 Invoker#invoke(invocation) 方法，服务调用。

## 43.2 API 定义 ##

### 43.2.1 Cache ###
com.alibaba.dubbo.cache.Cache ，缓存容器接口。
Cache 是个缓存容器，内部可以管理缓存的键值。

### 43.2.2 CacheFactory ###
com.alibaba.dubbo.cache.CacheFactory ，Cache 工厂接口。

- @SPI("lru") 注解，Dubbo SPI 拓展点，默认为 "lru" 。
- @Adaptive("cache") 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Cache 实现，使用 URL.cache 属性。

#### 43.2.3 AbstractCacheFactory ####
com.alibaba.dubbo.cache.support.AbstractCacheFactory ，Cache 工厂抽象类。

## 43.3 LRU 实现 ##
lru ，基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。

### 43.3.1 LruCache ###
com.alibaba.dubbo.cache.support.lru.LruCache ，实现 Cache 接口

属性：
- "cache.size" 配置项，设置缓存大小。
- 基于 com.alibaba.dubbo.common.utils.LRUCache 实现。

#### 43.3.1.1 LRUCache ####
com.alibaba.dubbo.common.utils.LRUCache ，实现 LinkedHashMap 类，LRU 缓存实现类。

- 构造方法，设置 LRUCache 为按访问顺序(调用get方法)的链表。
- 重写 removeEldestEntry 方法返回 true 值，指定插入元素时移除最老的元素。
	- 根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。
- lock 属性，锁。避免并发读写，导致死锁。

### 43.3.2 LruCacheFactory ###
com.alibaba.dubbo.cache.support.lru.LruCacheFactory ，实现 AbstractCacheFactory 抽象类

## 43.4 ThreadLocal 实现 ##
基于 ThreadLocal ，当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。

### 43.4.1 ThreadLocalCache ###
com.alibaba.dubbo.cache.support.threadlocal.ThreadLocalCache ，实现 Cache 接口

- 基于 ThreadLocal 实现，相当于一个线程，一个 ThreadLocalCache 对象。
- ThreadLocalCache 目前没有过期或清理机制，所以需要注意。

## 43.5 JCache 实现 ##
与 JSR107 集成，可以桥接各种缓存实现。

### 43.5.1 JCache ###
com.alibaba.dubbo.cache.support.jcache.JCache ，实现 Cache 接口

### 43.5.2 JCacheFactory ###

com.alibaba.dubbo.cache.support.jcache.JCacheFactory ，实现 AbstractCacheFactory 抽象类

----

# 44 过滤器（十一）之 ValidationFilter #
dubbo-filter-validation 项目的 ValidationFilter 过滤器，用于服务消费者和提供者中，提供 参数验证 的功能。

参数验证功能，是基于 JSR303 Bean Validation 实现的，用户只需标识 JSR303 标准的验证 annotation，并通过声明 filter 来实现验证。

## 44.1 ValidationFilter ##
com.alibaba.dubbo.validation.filter.ValidationFilter ，实现 Filter 接口，参数验证过滤器实现类

1. 基本流程如下：
1. 非泛化调用和回音调用等方法。
1. 判断方法开启 Validation 功能。因为，一个服务里，可能只有部分方法开启了 Validation 功能。
1. 调用 Validation$Adaptive#getValidator(url) 方法，基于 URL 为维度，获得 Validator 对象。
1. 调用 Validator#validate(String methodName, Class<?>[] parameterTypes, Object[] arguments) 方法，方法参数验证。若不合法，抛出异常。
1. 调用 Invoker#invoke(invocation) 方法，服务调用。

## 44.2 API 定义 ##

### 44.2.1 Validator ###
com.alibaba.dubbo.validation.Validator ，验证器接口。

### 44.2.2 Validation ###
com.alibaba.dubbo.validation.Validation ，Validator 工厂接口

- @SPI("jvalidation") 注解，Dubbo SPI 拓展点，默认为 "jvalidation" 。
- @Adaptive("validation") 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Validator 实现，使用 URL.validation 属性。

#### 44.2.2.1 AbstractValidation ####
com.alibaba.dubbo.validation.support.AbstractValidation ，实现 Validation 接口，Validator 工厂抽象类。

### 44.2.3 @MethodValidated ###
com.alibaba.dubbo.validation.@MethodValidated ，方法分组验证注解。

使用场景：当调用某个方法时，需要检查多个分组，可以在接口方法上加上该注解。

用法：

````
@MethodValidated({Save.class, Update.class})
void relatedQuery(ValidationParameter parameter);
````

在接口方法上增加注解，表示 #relatedQuery(ValidationParameter) 这个方法，需要同时检查 Save 和 Update 这两个分组。

## 44.3 JSR303 实现 ##
基于 JSR303 Bean Validation 实现的，用户只需标识 JSR303 标准的验证 annotation 。

### 44.3.1 JValidator ###

com.alibaba.dubbo.validation.support.jvalidation.JValidator ，实现 Validator 接口，基于 JSR303 的验证器实现类。

#### 44.3.1.1 构造方法 ####

````
/**
 * 服务接口类
 */
private final Class<?> clazz;
/**
 * Validator 对象
 */
private final javax.validation.Validator validator;

@SuppressWarnings({"unchecked", "rawtypes"})
public JValidator(URL url) {
    // 获得服务接口类
    this.clazz = ReflectUtils.forName(url.getServiceInterface());
    // 获得 `"jvalidation"` 配置项
    String jvalidation = url.getParameter("jvalidation");
    // 获得 ValidatorFactory 对象
    ValidatorFactory factory;
    if (jvalidation != null && jvalidation.length() > 0) { // 指定实现
        factory = Validation.byProvider((Class) ReflectUtils.forName(jvalidation)).configure().buildValidatorFactory();
    } else { // 默认
        factory = Validation.buildDefaultValidatorFactory();
    }
    // 获得 javax Validator 对象
    this.validator = factory.getValidator();
}
````

- "jvalidation" 配置项，可指定具体的 JSR303 的实现类。
- 如果我们未配置，并且引入 Hibernate Validator ，则使用的是 HibernateValidatorFactory 。

#### 44.3.1.2 validate ####

【第一步】获得验证分组集合

1. 验证分组集合 group ，目前有四种来源。

【第一种】添加以方法命名的内部接口，作为验证分组。例如 ValidationService#save(...) 方法，对应 ValidationService.Save 接口。
【第二种】添加方法的 @MethodValidated 注解的值对应的类，作为验证分组。
【第三种】添加 Default.class 类，作为验证分组。在 JSR 303 中，未设置分组的验证注解，使用 Default.class 。
【第四种】添加服务接口类 clazz ，作为验证分组。
最终生成的验证分组集合的顺序为：【第三种】》【第四种】》【第一种】》【第二种】。

【第二步】验证方法参数
验证错误集合 violations 。
【第一步】调用 #getMethodParameterBean(Class<?> clazz, Method method, Object[] args) 方法，获得方法参数的 Bean 对象。因为，JSR 303 是 Java Bean Validation ，以 Bean 为维度。
【第一步】调用 Validator#validate(T object, Class<?>... groups) 方法，验证 Bean 对象。
【第二步】循环方法参数，调用 #validate(violations, arg, classGroups) 方法，验证集合参数。为什么会有这一步？因为，在【第一步】中，校验的是 Constraint 注解的参数( 例如 @NotNull ) ，但是呢，若是集合参数，不会校验集合中的每个元素。

若有验证错误，抛出 ConstraintViolationException 异常。


//  todo 需要时再更新

------

# 45 NIO 服务器（一）之抽象 API #
- API 层：
	- dubbo-remoting-api
- 实现层：
	- dubbo-remoting-netty3
	- dubbo-remoting-netty4
	- dubbo-remoting-mina
	- dubbo-remoting-grizzly
	- dubbo-remoting-p2p


再配合上 Dubbo SPI 的机制，使用者可以自定义使用哪一种具体的实现。


## 45.1 Endpoint ##
com.alibaba.dubbo.remoting.Endpoint ，端点接口。
Endpoint ，从中文上解释来说是，“端点”。从字面上来看，不太容易理解。在 dubbo-remoting-api 中，一个 Client 或 Server ，都是一个 Endpoint 。不同系统的，Endpoint 代表的会略有差距，例如 SpringMVC 中，一个请求 Restful URL 也可以是一个 Endpoint。

### 45.1.1 Channel ###
com.alibaba.dubbo.remoting.Channel ，继承 Endpoint 接口，通道接口

和 Netty Channel 一致，通讯的载体

### 45.1.2 Client ###
com.alibaba.dubbo.remoting.Client ，实现 Endpoint 和 Channel 和 Resetable 接口，客户端接口。

### 45.1.3 Server ###
com.alibaba.dubbo.remoting.Server ，继承 Endpoint 和 Resetable 接口，服务器接口。

#### 45.1.3.1 Resetable ####
com.alibaba.dubbo.common.Resetable ，可重置接口

Server 实现 Resetable 接口，在实现 #reset(url) 方法，用于根据新传入的 url 属性，重置自己内部的一些属性，例如 AbstractServer#reset(url) 方法。

## 45.2 ChannelHandler ##
com.alibaba.dubbo.remoting.ChannelHandler ，通道处理器接口。

和 Netty ChannelHandler 一致，负责 Channel 中的逻辑处理。

## 45.3 Transporter ##
com.alibaba.dubbo.remoting.Transporter ，网络传输接口。

- @SPI("netty") 注解，Dubbo SPI 拓展点，默认为 "netty" 。注意，此处的 netty 对应的是 netty3 ，因为 Dubbo 项目在开发时，netty4 并未发布。
- @Adaptive({Constants.SERVER_KEY, Constants.TRANSPORTER_KEY}) 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Server 实现，使用 URL.server 或 URL.transporter 属性。
- @Adaptive({Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY}) 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Client 实现，使用 URL.client 或 URL.transporter 属性。

### 45.3.1 Transporters ###
com.alibaba.dubbo.remoting.Transporters ，Transporter 门面类。

- bind(String url, ChannelHandler... handler) 静态方法，绑定一个服务器。

基本流程如下：
1. 创建 handler 。若 handlers 是多个，使用 ChannelHandlerDispatcher 进行封装。在 ChannelHandlerDispatcher 中，会循环调用 handlers ，对应的方法。
2. 调用 #getTransporter() 方法，基于 Dubbo SPI 机制，获得 Transporter$Adaptive 对象。
3. 调用 Transporter#bind(url, handler) 方法，在 Transporter$Adaptive 对象中，会根据 url 参数，获得对应的 Transporter 实现对象（例如， NettyTransporter），从而创建对应的 Server 对象（例如， NettyServer）。

## 45.4 Codec2 ##
com.alibaba.dubbo.remoting.Codec2 ，编解码器接口。

- @SPI("netty") 注解，Dubbo SPI 拓展点。
- @Adaptive({Constants.CODEC_KEY}) 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Codec2 实现，使用 URL.codec 属性。

### 45.4.1 Codec ###
com.alibaba.dubbo.remoting.Codec ，老的编解码器接口，被 Codec2 取代。

### 45.4.2 Decodeable ###
com.alibaba.dubbo.remoting.Decodeable ，可解码的接口。

## 45.5 Dispatcher ##
com.alibaba.dubbo.remoting.Dispatcher ，调度器接口

- @SPI(AllDispatcher.NAME) 注解，Dubbo SPI 拓展点，默认为 "all" 。
- @Adaptive({Constants.DISPATCHER_KEY, "dispather", "channel.handler"}) 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 ChanelHander 实现，使用 URL.dispatcher 属性。

## 45.6 RemotingException ##
com.alibaba.dubbo.remoting.RemotingException ，实现 Exception 类，dubbo-remoting-api 的基础异常。

### 45.6.1 ExecutionException ###
com.alibaba.dubbo.remoting.ExecutionException ，实现 RemotingException 类，执行异常

### 45.6.2 TimeoutException ###
com.alibaba.dubbo.remoting.TimeoutException ，实现 RemotingException 类，超时异常


123