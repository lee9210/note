# 项目结构 #
### dubbo-common ###
**公共逻辑模块**：提供工具类和通用模型。

### dubbo-remoting ###
**远程通信模块**：提供通用的客户端和服务端的通讯功能。
- dubbo-remoting-zookeeper ，相当于 Zookeeper Client ，和 Zookeeper Server 通信。
- dubbo-remoting-api ， 定义了 Dubbo Client 和 Dubbo Server 的接口。
	- dubbo-remoting-grizzly ，基于 Grizzly 实现。
	- dubbo-remoting-http ，基于 Jetty 或 Tomcat 实现。
	- dubbo-remoting-mina ，基于 Mina 实现。
	- dubbo-remoting-netty ，基于 Netty 3 实现。
	- dubbo-remoting-netty4 ，基于 Netty 4 实现。
	- dubbo-remoting-p2p ，P2P 服务器。注册中心 dubbo-registry-multicast 项目的使用该项目。

### dubbo-rpc ###
**远程调用模块**：抽象各种协议，以及动态代理，只包含一对一的调用，**不关心集群的管理**。

- dubbo-rpc-api ，抽象各种协议以及动态代理，实现了一对一的调用。
- 其他模块，实现 dubbo-rpc-api ，提供对应的协议实现。

### dubbo-cluster ###
**集群模块**：将多个服务提供方伪装为一个提供方，包括：负载均衡, 集群容错，路由，分组聚合等。集群的地址列表可以是静态配置的，也可以是由注册中心下发。

集群模块包含多个功能：容错、目录、路由、配置、负载均衡、合并结果。

整体流程用图表示为：

![avatar](/picture/main-flow.png)

### dubbo-registry ###
**注册中心模块**：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。

- dubbo-registry-api ，抽象注册中心的注册与发现接口。
- 其他模块，实现 dubbo-registry-api ，提供对应的注册中心实现。

### dubbo-monitor ###
**监控模块**：统计服务调用次数，调用时间的，调用链跟踪的服务。

### dubbo-config ###
**配置模块**：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。

- dubbo-config-api ，实现了 API 配置 和 属性配置 功能。
- dubbo-config-spring ，实现了 XML 配置 和 注解配置 功能。

### dubbo-container ###
**容器模块**：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。

- dubbo-container-api ：定义了 com.alibaba.dubbo.container.Container 接口，并提供 加载所有容器启动的 Main 类。
	- dubbo-container-spring ，提供了 com.alibaba.dubbo.container.spring.SpringContainer 。
	- dubbo-container-log4j ，提供了 com.alibaba.dubbo.container.log4j.Log4jContainer 。
	- dubbo-container-logback ，提供了 com.alibaba.dubbo.container.logback.LogbackContainer 。

### dubbo-filter ###
**过滤器模块**：提供了内置的过滤器。
- dubbo-filter-cache ，缓存过滤器。
- dubbo-filter-validation ，参数验证过滤器。

### dubbo-plugin ###
**插件模块**：提供了内置的插件。

### hessian-lite ###
Dubbo 对 Hessian 2 的 序列化 部分的精简、改进、BugFix 。

### dubbo-demo ###
快速启动示例。

### dubbo-test ###
测试模块。

- dubbo-test-benchmark ，性能测试。
- dubbo-test-compatibility ，兼容性测试。
- dubbo-test-example ，使用示例。


# API 配置（一）之应用 #
**应用配置**：指的是配置应用的名称，应用地址等等。
包括的标签有：
````
<dubbo:application>//应用信息配置。对应的配置类：com.alibaba.dubbo.config.ApplicationConfig
<dubbo:registry>//注册中心配置。对应的配置类： com.alibaba.dubbo.config.RegistryConfig。同时如果有多个不同的注册中心，可以声明多个 <dubbo:registry> 标签，并在 <dubbo:service> 或 <dubbo:reference> 的 registry 属性指定使用的注册中心。
<dubbo:module>//模块信息配置。对应的配置类 com.alibaba.dubbo.config.ModuleConfig
<dubbo:monitor>//监控中心配置。对应的配置类： com.alibaba.dubbo.config.MonitorConfig
<dubbo:argument>方法参数配置。对应的配置类： com.alibaba.dubbo.config.ArgumentConfig。该标签为 <dubbo:method> 的子标签，用于方法参数的特征描述，比如：
	<dubbo:method name="findXxx" timeout="3000" retries="2">
	    <dubbo:argument index="0" callback="true" />
	</dubbo:method>
````
所有配置项分为三大类：
- 服务发现：表示该配置项用于服务的注册与发现，目的是让消费方找到提供方。
- 服务治理：表示该配置项用于治理服务间的关系，或为开发测试提供便利条件。
- 性能调优：表示该配置项用于调优性能，不同的选项对性能会产生影响。

所有配置最终都将转换为 Dubbo URL 表示，并由服务提供方生成，经注册中心传递给消费方，各属性对应 URL 的参数

配置关系图：
![avatar](/picture/schema-config-relation.png)


## Config ##

例子：消费者初始化代码
````
// 当前应用配置
ApplicationConfig application = new ApplicationConfig();
application.setName("yyy");

// 连接注册中心配置
RegistryConfig registry = new RegistryConfig();
registry.setAddress("10.20.130.230:9090");
registry.setUsername("aaa");
registry.setPassword("bbb");

// 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接

// 引用远程服务
ReferenceConfig<XxxService> reference = new ReferenceConfig<XxxService>(); // 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏
reference.setApplication(application);
reference.setRegistry(registry); // 多个注册中心可以用setRegistries()
reference.setInterface(XxxService.class);
reference.setVersion("1.0.0");

// 和本地bean一样使用xxxService
XxxService xxxService = reference.get(); // 注意：此代理对象内部封装了所有通讯细节，对象较重，请缓存复用
````

### AbstractConfig ###
AbstractConfig 主要提供配置解析与校验相关的工具方法。

appendParameters(parameters, config, prefix) 方法，将配置对象的属性，添加到参数集合。
- arameters ，参数集合。实际上，该集合会用于 URL.parameters 。
- onfig ，配置对象。
- refix ，属性前缀。用于配置项添加到 parameters 中时的前缀。

### URL ###
格式：protocol://username:password@host:port/path?key=value&key=value
例如：
````
dubbo://192.168.3.17:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&default.delay=-1&default.retries=0&default.service.filter=demoFilter&delay=-1&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=19031&side=provider&timestamp=1519651641799
````
appendAttributes(parameters, config, prefix) 方法，将 @Parameter(attribute = true) 配置对象的属性，添加到参数集合。
appendProperties(config) 方法，读取环境变量和 properties 配置到配置对象
appendAnnotation(annotationClass, annotation) 方法，读取注解配置到配置对象


### @Parameter ###
Parameter 参数注解，用于 Dubbo URL 的 parameters 拼接。

# API 配置（二）之服务提供者 #
包括 provider-config 和 sub-config 部分。
包括的标签有
````
<dubbo:protocol>//服务提供者协议配置。对应的配置类： com.alibaba.dubbo.config.ProtocolConfig。同时，如果需要支持多协议，可以声明多个 <dubbo:protocol> 标签，并在 <dubbo:service> 中通过 protocol 属性指定使用的协议。
<dubbo:method>//方法级配置。对应的配置类： com.alibaba.dubbo.config.MethodConfig。同时该标签为 <dubbo:service> 或 <dubbo:reference> 的子标签，用于控制到方法级。
<dubbo:method>
<dubbo:service>//服务提供者暴露服务配置。对应的配置类：com.alibaba.dubbo.config.ServiceConfig
<dubbo:provider>//服务提供者缺省值配置。对应的配置类： com.alibaba.dubbo.config.ProviderConfig。同时该标签为 <dubbo:service> 和 <dubbo:protocol> 标签的缺省值设置。
````
## ServiceConfig ##

暴露服务的方法是：ServiceConfig#export()。该方法主要做了如下几件事情：
1. 进一步初始化 ServiceConfig 对象。
2. 校验 ServiceConfig 对象的配置项。
3. 使用 ServiceConfig 对象，生成 Dubbo URL 对象数组。
4. 使用 Dubbo URL 对象，暴露服务。

### export() ###

执行步骤
1. 当 export 或 delay 未配置时，从 ProviderConfig 对象读取。
2. 当配置不需要暴露服务( export = false )时，直接返回。
3. 当配置延迟暴露( delay > 0 )时，使用 delayExportExecutor 延迟调度，调用 #doExport() 方法。
	1. 因为spring暴露服务不需要bean初始化全部完成，所以当暴露之后，有可能请求会进来，会导致服务不可用。
4. 立即暴露，调用 #doExport() 方法。

### doExport() ###
完成暴露服务前检查，并调用暴露url方法。大致过程如下

1. 检查是否可以暴露。若可以，标记已经暴露( exported = true )。
2. 校验接口名 interfaceName 非空。（校验暴露的interface类型的service是否为空）
3. 调用 #checkDefault() 方法，读取属性配置( 环境变量 + properties 属性 )到 ProviderConfig 对象。
4. 从 ProviderConfig 对象中，读取 application、module、registries、monitor、protocols 对象。（若没有配置这些对象，从provider中读取数据）
5. 从 ModuleConfig 对象中，读取 registries、monitor 对象。
6. 从 ApplicationConfig 对象中，读取 registries、monitor 对象。
7. 泛化接口的实现。（若配置了需要实现泛化接口，则需要实现，否则实现普通接口）
8. 普通接口的实现。
	1. 根据 interfaceName ，获得对应的接口类，并赋值给 interfaceClass。
	2. 调用 #checkInterfaceAndMethods(interfaceClass, methods) 方法，检查接口和方法。
	3. 调用 #checkRef() 方法，校验指向的 Service 对象。（校验指向的service是否为空）
	4. 标记 generic 为非泛化实现。
9. 处理服务接口客户端本地代理( local )相关。实际目前已经废弃，此处主要用于兼容，使用 stub 属性
10. 处理服务接口客户端本地代理( stub 属性，参见 AbstractInterfaceConfig#setLocal(local) )相关。
11. 调用 #checkApplication() 方法，校验 ApplicationConfig 配置。
12. 调用 #checkRegistry() 方法，校验 RegistryConfig 配置。
13. 调用 #checkProtocol() 方法，校验 ProtocolConfig 配置数组。
14. 调用 #appendProperties(config) 方法，读取属性配置( 环境变量 + properties 属性 )到 ServiceConfig 对象（自己）。
15. 调用 #checkStubAndMock(interfaceClass) 方法，校验 Stub 和 Mock 相关的配置。
16. 服务路径 path 为空时，缺省为接口名（即当最后组装的path为空的时候，默认的缺省值为interface的路径）。
17. 调用 #doExportUrls() 方法，暴露服务。
18. 等待 qos

### doExportUrls() ###
执行暴露url的方法，完成服务的暴露

1. 协议名空时，缺省 "dubbo" 。
2. 创建参数集合 map ，用于下面创建 Dubbo URL 的 parameters 属性。
3. 将 side dubbo timestamp timestamp pid 添加到 map 中。
4. 调用 #appendParameters(map, config) 方法，将各种配置对象添加到 map 中。
5. 调用 MethodConfig 对象数组，添加到 map 中。
	1. 目的是将每个 MethodConfig 和其对应的 ArgumentConfig 对象数组，添加到 map 中。
6. 将 generic methods revision 到 map 中。
7. 将 token 添加到 map 中。（token验证是为了只能通过注册中心访问，不能通过自己构造参数调用服务。）
8. 当协议为 injvm 时，添加 notify = false 到 map 中，表示不注册，不通知。
9. 获得 contextPath ，基础路径，即java web应用中常说的context path 。
10. 调用 #this.findConfigedHosts(protocolConfig, registryURLs, map) 方法，获得注册到注册中心的服务提供者 Host 。
11. 调用 #findConfigedHosts(protocolConfig, name, map) 方法，获得注册到注册中心的服务提供者 Port 。
12. 创建 Dubbo URL （创建出的URL类似：dubbo://192.168.29.215:20880/com.alibaba.dubbo.demo.DemoService?accesslog=true&anyhost=true&application=demo-provider&bind.ip=192.168.29.215&bind.port=20880&callbacks=1000&default.delay=-1&default.retries=0&delay=-1&deprecated=false&dubbo=2.0.0&generic=false&group=g1&interface=com.alibaba.dubbo.demo.DemoService&logger=jcl&methods=sayHello,callbackParam,save,update,say03,delete,say04,demo,say01,bye,say02,hello02,saves,hello01,hello&pid=6736&qos.port=22222&say01.deprecated=true&server=netty4&service.filter=demo&side=provider&timeout=200000&timestamp=1544855503737）。
13. 配置规则
14. 服务暴露逻辑


# API 配置（三）之服务消费者 #
主要是消费者的配置。
前面基本配置流程和provider差不多，主要是后面引用服务的部分不同
## AbstractReferenceConfig ##
抽象引用配置类。
需要配置的标签为：
````
<dubbo:reference>//服务消费者引用服务配置。对应的配置类： com.alibaba.dubbo.config.ReferenceConfig
<dubbo:consumer>//服务消费者缺省值配置。配置类： com.alibaba.dubbo.config.ConsumerConfig 。同时该标签为 <dubbo:reference> 标签的缺省值设置。
````

## ConsumerConfig ##
服务消费者缺省值配置。主要解析的标签是：<dubbo:consumer>

## ReferenceConfig ##
服务消费者引用服务配置类。
主要解析的标签是：<dubbo:consumer>
在ReferenceConfig 的初始化示例代码中（消费者初始化代码），最后调用的是 ServiceConfig#get() 方法。从方法的命名，我们可以看出，获取引用服务。该方法主要做了如下几件事情：

1. 进一步初始化 ReferenceConfig 对象。
2. 校验 ReferenceConfig 对象的配置项。
3. 使用 ReferenceConfig 对象，生成 Dubbo URL 对象数组。
4. 使用 Dubbo URL 对象，应用服务。

在#get()函数中，主要是完成 init() 方法的调用，完成服务的初始化。
主要过程为：

1. 若已经初始化( initialized = true ) 时，直接返回。否则，标记已经初始化。
2. 校验接口名 interfaceName 非空（interface service的path）。
3. 调用 #checkDefault() 方法，读取属性配置( 环境变量 + properties 属性 )到 ConsumerConfig 对象。
4. 调用 #appendProperties(config) 方法，读取属性配置( 环境变量 + properties 属性 )到 ReferenceConfig 对象（自己）
5. 若未设置 generic 属性，使用 ConsumerConfig.generic 属性。
6. 泛化接口的实现。
7. 普通接口的实现。
	1. 根据 interfaceName ，获得对应的接口类，并赋值给 interfaceClass(使用反射获取类)。
	2. 调用 #checkInterfaceAndMethods(interfaceClass, methods) 方法，检查接口和方法。
8. 直连提供者（若配置了直连provider，比如配置了 <dubbo:reference id="xxxService" interface="com.alibaba.xxx.XxxService" url="dubbo://localhost:20890" /> 或者在jvm启动参数中加入 java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 便可以直接连接provider，绕过注册中心。注意，此配置仅用于开发，线上环境删除）。
9. 从 ConsumerConfig、ModuleConfig、ApplicationConfig 配置对象，复制 application module registries monitor 给 ReferenceConfig ( 自己 )。
10. 调用 #checkApplication() 方法，校验 ApplicationConfig 配置。
11. 调用 #checkStubAndMock(interfaceClass) 方法，校验 Stub 和 Mock 相关的配置。
12. 创建参数集合 map ，用于下面创建 Dubbo URL 的 parameters 属性。
13. 将 side dubbo timestamp timestamp pid 添加到 map 中。
14. 将 interface methods revision 到 map 中。
15. 调用 #appendParameters(map, config) 方法，将各种配置对象添加到 map 中。
16. 调用 MethodConfig 对象数组，添加到 map 中。
	1. 目的是将每个 MethodConfig 和其对应的 ArgumentConfig 对象数组，添加到 map 中。
	2. 调用 #appendAttributes(parameters, config, prefix) 方法，将 @Parameter(attribute = true) 配置对象的属性，添加到参数集合。
	3. 调用 #checkAndConvertImplicitConfig(method, map, attributes) 方法，检查属性集合中的事件通知方法是否正确。若正确，进行转换。
17. 以系统换将变量 ( DUBBO_IP_TO_REGISTRY ) 作为服务注册地址，
18. 添加到 com.alibaba.dubbo.rpc.StaticContext 进行缓存。
19. 【服务引用】逻辑-创建 Service 代理对象。

# 属性配置 #
如果公共配置很简单，没有多注册中心，多协议等情况，或者想多个 Spring 容器想共享配置，可以使用 dubbo.properties 作为缺省配置。
Dubbo 将自动加载 classpath 根目录下的 dubbo.properties，可以通过JVM启动参数 -Ddubbo.properties.file=xxx.properties 改变缺省配置位置。

- 属性配置，不支持多注册中心，多协议等情况
- 外部化配置，能够解决上述的问题

## AbstractConfig ##
在 AbstractConfig 中，提供了 #appendProperties(config) 方法，读取启动参数变量和 properties 配置到配置对象。

配置策略在：https://dubbo.gitbooks.io/dubbo-user-book/configuration/properties.html


# XML 配置 #
XML 配置，自定义 <dubbo: /> 标签，基于 Spring XML 进行解析
xml配置在：https://dubbo.gitbooks.io/dubbo-user-book/configuration/xml.html
https://dubbo.gitbooks.io/dubbo-user-book/references/xml/introduction.html

# 核心流程 #
框架设计：

![avatar](/picture/dubbo-frame.png)

### 图例说明 ###
- 最顶上九个图标，代表本图中的对象与流程。
- 图中左边 淡蓝背景( Consumer ) 的为服务消费方使用的接口，右边 淡绿色背景( Provider ) 的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。
- 图中从下至上分为十层，各层均为单向依赖，右边的 黑色箭头( Depend ) 代表层之间的依赖关系，每一层都可以剥离上层被复用。其中，Service 和 Config 层为 API，其它各层均为 SPI 。
- 图中 绿色小块( Interface ) 的为扩展接口，蓝色小块( Class ) 为实现类，图中只显示用于关联各层的实现类。
- 图中 蓝色虚线( Init ) 为初始化过程，即启动时组装链。红色实线( Call )为方法调用过程，即运行时调时链。紫色三角箭头( Inherit )为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。

### 各层说明 ###
------------business------------
- Service 业务层：业务代码的接口与实现。我们实际使用 Dubbo

------------RPC------------
- config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 Spring 解析配置生成配置类。
	- dubbo-config 模块实现。
- proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory 。
	- dubbo-rpc-rpc 模块实现。
	- com.alibaba.dubbo.rpc.proxy包 + com.alibaba.dubbo.rpc.ProxyFactory接口 。
- registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService 。
	- dubbo-registry 模块实现。
- cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance 。
	- dubbo-cluster 模块实现。
- monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService 。
	- dubbo-monitor 模块实现。

------------Remoting------------
- protocol 远程调用层：封将 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter 。
	- dubbo-rpc-rpc 模块实现。
	- com.alibaba.dubbo.rpc.protocol包 + com.alibaba.dubbo.rpc.Protocol接口 。
- exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer 。
	- dubbo-remoting-api 模块定义接口。
	- com.alibaba.dubbo.remoting.exchange包。
- transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec 。
	- dubbo-remoting-api 模块定义接口。
	- com.alibaba.dubbo.remoting.transport包。
- serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool 。
	- dubbo-common 模块实现。
	- com.alibaba.dubbo.common.serialize包。

### 关系说明 ###
1. 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。
2. 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。
3. 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。
4. Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。（简单粗暴的说，Proxy 会拦截 service.doSomething(args) 的调用，“转发”给该 Service 对应的 Invoker ，从而实现透明化的代理。）
5. 而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上。Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输；而 Exchange 层是在传输层之上封装了 Request-Response 语义。
6. Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。

## 核心流程 ##

### 调用链 ###
展开总设计图的红色调用链( Call )，如下：

![avatar](/picture/dubbo-call.png)


- 垂直分层如下：
	- 下方 淡蓝背景( Consumer )：服务消费方使用的接口
	- 上方 淡绿色背景( Provider )：服务提供方使用的接口
	- 中间 粉色背景( Remoting )：通信部分的接口
- 自 LoadBalance 向上，每一行分成了多个相同的 Interface ，指的是负载均衡后，向 Provider 发起调用。
- 左边 括号 部分，代表了垂直部分更细化的分层，依次是：Common、Remoting、RPC、Interface 。
- 右边 蓝色虚线( Init ) 为初始化过程，通过对应的组件进行初始化。例如，ProxyFactory 初始化出 Proxy 。

### 暴露服务 ###
展开总设计图左边服务提供方暴露服务的蓝色初始化链( Init )，时序图如下：
![avatar](/picture/dubbo-provider-init.png)

### 引用服务 ###
展开总设计图右边服务消费方引用服务的蓝色初始化链( Init )，时序图如下：
![avatar](/picture/dubbo-consumer-init.png)

## 领域模型 ##
### Invoker ###
com.alibaba.dubbo.rpc.Invoker 。

Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它。
它代表一个可执行体，可向它发起 invoke 调用。
它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。

- getInterface() 方法，获得 Service 接口。
- invoke(Invocation) 方法，调用方法。

#### Invoker ####
由于 Invoker 是 Dubbo 领域模型中非常重要的一个概念，很多设计思路都是向它靠拢。

服务提供 Invoker 和服务消费 Invoker：

![avatar](/picture/dubbo-invoker.png)

服务消费者代码：
````
public class DemoClientAction {

    private DemoService demoService;

    public void setDemoService(DemoService demoService) {
        this.demoService = demoService;
    }

    public void start() {
        String hello = demoService.sayHello("world" + i);
    }
}
````
上面代码中的 DemoService 就是上图中服务消费端的 Proxy，用户代码通过这个 Proxy 调用其对应的 Invoker，而该 Invoker 实现了真正的远程服务调用。

服务提供者代码：
````
public class DemoServiceImpl implements DemoService {

    public String sayHello(String name) throws RemoteException {
        return "Hello " + name;
    }
}
````
上面这个类会被封装成为一个 AbstractProxyInvoker 实例，并新生成一个 Exporter 实例。这样当网络通讯层收到一个请求后，会找到对应的 Exporter 实例，并调用它所对应的 AbstractProxyInvoker 实例，从而真正调用了服务提供者的代码。

### Invocation ###

Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。

### Result ###
Result 是会话域，它持有调用过程中返回值，异常等。

### Filter ###

过滤器接口，和我们平时理解的 javax.servlet.Filter 基本一致。

### ProxyFactory ###
代理工厂接口。

#### 内部方法声明 ####

- getProxy(invoker) 方法，创建 Proxy ，在引用服务时调用。

服务消费着引用服务的 主过程 如下图：

![avatar](/picture/dubbo-consumer-flow.png)

- 从图中我们可以看出，方法的 invoker 参数，通过 Protocol 将 Service接口 创建出 Invoker 。
- 通过创建 Service 的 Proxy ，实现我们在业务代理调用 Service 的方法时，透明的内部转换成调用 Invoker 的 #invoke(Invocation) 方法。

- getInvoker(proxy, type, url) 方法，创建 Invoker ，在暴露服务时调用。

服务提供者暴露服务的 主过程 如下图：

![avatar](/picture/dubbo-provider-flow.png)

从图中我们可以看出，该方法创建的 Invoker ，下一步会提交给 Protocol ，从 Invoker 转换到 Exporter 。

### Protocol ###

Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口。
它负责 Invoker 的生命周期管理。

#### 内部方法声明 ####

export(invoker)方法，暴露远程服务

1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();
2. export() 必须是幂等的，也就是暴露同一个 URL 的 Invoker 两次，和暴露一次没有区别。
3. export() 传入的 Invoker 由框架实现并传入，协议不需要关心。

refer(type, url)方法，引用远程服务

1. 当用户调用 refer() 所返回的 Invoker 对象的 invoke() 方法时，协议需相应执行同 URL 远端 export() 传入的 Invoker 对象的 invoke() 方法。
2. refer() 返回的 Invoker 由协议实现，协议通常需要在此 Invoker 中发送远程请求。
3. 当 url 中有设置 check=false 时，连接失败不能抛出异常，并内部自动恢复。

destroy()方法，释放协议

1. 取消该协议所有已经暴露和引用的服务。
2. 释放协议所占用的所有资源，比如连接和端口。
3. 协议在释放后，依然能暴露和引用新的服务。








123`