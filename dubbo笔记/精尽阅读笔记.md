# 1. 项目结构 #
### 1.1.1 dubbo-common ###
**公共逻辑模块**：提供工具类和通用模型。

### 1.1.2 dubbo-remoting ###
**远程通信模块**：提供通用的客户端和服务端的通讯功能。
- dubbo-remoting-zookeeper ，相当于 Zookeeper Client ，和 Zookeeper Server 通信。
- dubbo-remoting-api ， 定义了 Dubbo Client 和 Dubbo Server 的接口。
	- dubbo-remoting-grizzly ，基于 Grizzly 实现。
	- dubbo-remoting-http ，基于 Jetty 或 Tomcat 实现。
	- dubbo-remoting-mina ，基于 Mina 实现。
	- dubbo-remoting-netty ，基于 Netty 3 实现。
	- dubbo-remoting-netty4 ，基于 Netty 4 实现。
	- dubbo-remoting-p2p ，P2P 服务器。注册中心 dubbo-registry-multicast 项目的使用该项目。

### 1.1.3 dubbo-rpc ###
**远程调用模块**：抽象各种协议，以及动态代理，只包含一对一的调用，**不关心集群的管理**。

- dubbo-rpc-api ，抽象各种协议以及动态代理，实现了一对一的调用。
- 其他模块，实现 dubbo-rpc-api ，提供对应的协议实现。

### 1.1.4 dubbo-cluster ###
**集群模块**：将多个服务提供方伪装为一个提供方，包括：负载均衡, 集群容错，路由，分组聚合等。集群的地址列表可以是静态配置的，也可以是由注册中心下发。

集群模块包含多个功能：容错、目录、路由、配置、负载均衡、合并结果。

整体流程用图表示为：

![](/picture/main-flow.png)

### 1.1.5 dubbo-registry ###
**注册中心模块**：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。

- dubbo-registry-api ，抽象注册中心的注册与发现接口。
- 其他模块，实现 dubbo-registry-api ，提供对应的注册中心实现。

### 1.1.6 dubbo-monitor ###
**监控模块**：统计服务调用次数，调用时间的，调用链跟踪的服务。

### 1.1.7 dubbo-config ###
**配置模块**：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。

- dubbo-config-api ，实现了 API 配置 和 属性配置 功能。
- dubbo-config-spring ，实现了 XML 配置 和 注解配置 功能。

### 1.1.8 dubbo-container ###
**容器模块**：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。

- dubbo-container-api ：定义了 com.alibaba.dubbo.container.Container 接口，并提供 加载所有容器启动的 Main 类。
	- dubbo-container-spring ，提供了 com.alibaba.dubbo.container.spring.SpringContainer 。
	- dubbo-container-log4j ，提供了 com.alibaba.dubbo.container.log4j.Log4jContainer 。
	- dubbo-container-logback ，提供了 com.alibaba.dubbo.container.logback.LogbackContainer 。

### 1.1.9 dubbo-filter ###
**过滤器模块**：提供了内置的过滤器。
- dubbo-filter-cache ，缓存过滤器。
- dubbo-filter-validation ，参数验证过滤器。

### 1.1.10 dubbo-plugin ###
**插件模块**：提供了内置的插件。

### 1.1.11 hessian-lite ###
Dubbo 对 Hessian 2 的 序列化 部分的精简、改进、BugFix 。

### 1.1.12 dubbo-demo ###
快速启动示例。

### 1.1.13 dubbo-test ###
测试模块。

- dubbo-test-benchmark ，性能测试。
- dubbo-test-compatibility ，兼容性测试。
- dubbo-test-example ，使用示例。

-------

# 2. API 配置（一）之应用 #
**应用配置**：指的是配置应用的名称，应用地址等等。
包括的标签有：
````
<dubbo:application>//应用信息配置。对应的配置类：com.alibaba.dubbo.config.ApplicationConfig
<dubbo:registry>//注册中心配置。对应的配置类： com.alibaba.dubbo.config.RegistryConfig。同时如果有多个不同的注册中心，可以声明多个 <dubbo:registry> 标签，并在 <dubbo:service> 或 <dubbo:reference> 的 registry 属性指定使用的注册中心。
<dubbo:module>//模块信息配置。对应的配置类 com.alibaba.dubbo.config.ModuleConfig
<dubbo:monitor>//监控中心配置。对应的配置类： com.alibaba.dubbo.config.MonitorConfig
<dubbo:argument>方法参数配置。对应的配置类： com.alibaba.dubbo.config.ArgumentConfig。该标签为 <dubbo:method> 的子标签，用于方法参数的特征描述，比如：
	<dubbo:method name="findXxx" timeout="3000" retries="2">
	    <dubbo:argument index="0" callback="true" />
	</dubbo:method>
````
所有配置项分为三大类：
- 服务发现：表示该配置项用于服务的注册与发现，目的是让消费方找到提供方。
- 服务治理：表示该配置项用于治理服务间的关系，或为开发测试提供便利条件。
- 性能调优：表示该配置项用于调优性能，不同的选项对性能会产生影响。

所有配置最终都将转换为 Dubbo URL 表示，并由服务提供方生成，经注册中心传递给消费方，各属性对应 URL 的参数

配置关系图：
![](/picture/schema-config-relation.png)


## 2.1 Config ##

例子：消费者初始化代码
````
// 当前应用配置
ApplicationConfig application = new ApplicationConfig();
application.setName("yyy");

// 连接注册中心配置
RegistryConfig registry = new RegistryConfig();
registry.setAddress("10.20.130.230:9090");
registry.setUsername("aaa");
registry.setPassword("bbb");

// 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接

// 引用远程服务
ReferenceConfig<XxxService> reference = new ReferenceConfig<XxxService>(); // 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏
reference.setApplication(application);
reference.setRegistry(registry); // 多个注册中心可以用setRegistries()
reference.setInterface(XxxService.class);
reference.setVersion("1.0.0");

// 和本地bean一样使用xxxService
XxxService xxxService = reference.get(); // 注意：此代理对象内部封装了所有通讯细节，对象较重，请缓存复用
````

### 2.1.1 AbstractConfig ###
AbstractConfig 主要提供配置解析与校验相关的工具方法。

appendParameters(parameters, config, prefix) 方法，将配置对象的属性，添加到参数集合。
- arameters ，参数集合。实际上，该集合会用于 URL.parameters 。
- onfig ，配置对象。
- refix ，属性前缀。用于配置项添加到 parameters 中时的前缀。

### 2.1.2 URL ###
格式：protocol://username:password@host:port/path?key=value&key=value
例如：
````
dubbo://192.168.3.17:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&default.delay=-1&default.retries=0&default.service.filter=demoFilter&delay=-1&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=19031&side=provider&timestamp=1519651641799
````
appendAttributes(parameters, config, prefix) 方法，将 @Parameter(attribute = true) 配置对象的属性，添加到参数集合。
appendProperties(config) 方法，读取环境变量和 properties 配置到配置对象
appendAnnotation(annotationClass, annotation) 方法，读取注解配置到配置对象


### 2.1.3 @Parameter ###
Parameter 参数注解，用于 Dubbo URL 的 parameters 拼接。

-------

# 3 API 配置（二）之服务提供者 #
包括 provider-config 和 sub-config 部分。
包括的标签有
````
<dubbo:protocol>//服务提供者协议配置。对应的配置类： com.alibaba.dubbo.config.ProtocolConfig。同时，如果需要支持多协议，可以声明多个 <dubbo:protocol> 标签，并在 <dubbo:service> 中通过 protocol 属性指定使用的协议。
<dubbo:method>//方法级配置。对应的配置类： com.alibaba.dubbo.config.MethodConfig。同时该标签为 <dubbo:service> 或 <dubbo:reference> 的子标签，用于控制到方法级。
<dubbo:method>
<dubbo:service>//服务提供者暴露服务配置。对应的配置类：com.alibaba.dubbo.config.ServiceConfig
<dubbo:provider>//服务提供者缺省值配置。对应的配置类： com.alibaba.dubbo.config.ProviderConfig。同时该标签为 <dubbo:service> 和 <dubbo:protocol> 标签的缺省值设置。
````
## 3.1 ServiceConfig ##

暴露服务的方法是：ServiceConfig#export()。该方法主要做了如下几件事情：
1. 进一步初始化 ServiceConfig 对象。
2. 校验 ServiceConfig 对象的配置项。
3. 使用 ServiceConfig 对象，生成 Dubbo URL 对象数组。
4. 使用 Dubbo URL 对象，暴露服务。

### 3.1.1 export() ###

执行步骤
1. 当 export 或 delay 未配置时，从 ProviderConfig 对象读取。
2. 当配置不需要暴露服务( export = false )时，直接返回。
3. 当配置延迟暴露( delay > 0 )时，使用 delayExportExecutor 延迟调度，调用 #doExport() 方法。
	1. 因为spring暴露服务不需要bean初始化全部完成，所以当暴露之后，有可能请求会进来，会导致服务不可用。
4. 立即暴露，调用 #doExport() 方法。

### 3.1.2 doExport() ###
完成暴露服务前检查，并调用暴露url方法。大致过程如下

1. 检查是否可以暴露。若可以，标记已经暴露( exported = true )。
2. 校验接口名 interfaceName 非空。（校验暴露的interface类型的service是否为空）
3. 调用 #checkDefault() 方法，读取属性配置( 环境变量 + properties 属性 )到 ProviderConfig 对象。
4. 从 ProviderConfig 对象中，读取 application、module、registries、monitor、protocols 对象。（若没有配置这些对象，从provider中读取数据）
5. 从 ModuleConfig 对象中，读取 registries、monitor 对象。
6. 从 ApplicationConfig 对象中，读取 registries、monitor 对象。
7. 泛化接口的实现。（若配置了需要实现泛化接口，则需要实现，否则实现普通接口）
8. 普通接口的实现。
	1. 根据 interfaceName ，获得对应的接口类，并赋值给 interfaceClass。
	2. 调用 #checkInterfaceAndMethods(interfaceClass, methods) 方法，检查接口和方法。
	3. 调用 #checkRef() 方法，校验指向的 Service 对象。（校验指向的service是否为空）
	4. 标记 generic 为非泛化实现。
9. 处理服务接口客户端本地代理( local )相关。实际目前已经废弃，此处主要用于兼容，使用 stub 属性
10. 处理服务接口客户端本地代理( stub 属性，参见 AbstractInterfaceConfig#setLocal(local) )相关。
11. 调用 #checkApplication() 方法，校验 ApplicationConfig 配置。
12. 调用 #checkRegistry() 方法，校验 RegistryConfig 配置。
13. 调用 #checkProtocol() 方法，校验 ProtocolConfig 配置数组。
14. 调用 #appendProperties(config) 方法，读取属性配置( 环境变量 + properties 属性 )到 ServiceConfig 对象（自己）。
15. 调用 #checkStubAndMock(interfaceClass) 方法，校验 Stub 和 Mock 相关的配置。
16. 服务路径 path 为空时，缺省为接口名（即当最后组装的path为空的时候，默认的缺省值为interface的路径）。
17. 调用 #doExportUrls() 方法，暴露服务。
18. 等待 qos

### 3.1.3 doExportUrls() ###
执行暴露url的方法，完成服务的暴露

1. 协议名空时，缺省 "dubbo" 。
2. 创建参数集合 map ，用于下面创建 Dubbo URL 的 parameters 属性。
3. 将 side dubbo timestamp timestamp pid 添加到 map 中。
4. 调用 #appendParameters(map, config) 方法，将各种配置对象添加到 map 中。
5. 调用 MethodConfig 对象数组，添加到 map 中。
	1. 目的是将每个 MethodConfig 和其对应的 ArgumentConfig 对象数组，添加到 map 中。
6. 将 generic methods revision 到 map 中。
7. 将 token 添加到 map 中。（token验证是为了只能通过注册中心访问，不能通过自己构造参数调用服务。）
8. 当协议为 injvm 时，添加 notify = false 到 map 中，表示不注册，不通知。
9. 获得 contextPath ，基础路径，即java web应用中常说的context path 。
10. 调用 #this.findConfigedHosts(protocolConfig, registryURLs, map) 方法，获得注册到注册中心的服务提供者 Host 。
11. 调用 #findConfigedHosts(protocolConfig, name, map) 方法，获得注册到注册中心的服务提供者 Port 。
12. 创建 Dubbo URL （创建出的URL类似：dubbo://192.168.29.215:20880/com.alibaba.dubbo.demo.DemoService?accesslog=true&anyhost=true&application=demo-provider&bind.ip=192.168.29.215&bind.port=20880&callbacks=1000&default.delay=-1&default.retries=0&delay=-1&deprecated=false&dubbo=2.0.0&generic=false&group=g1&interface=com.alibaba.dubbo.demo.DemoService&logger=jcl&methods=sayHello,callbackParam,save,update,say03,delete,say04,demo,say01,bye,say02,hello02,saves,hello01,hello&pid=6736&qos.port=22222&say01.deprecated=true&server=netty4&service.filter=demo&side=provider&timeout=200000&timestamp=1544855503737）。
13. 配置规则
14. 服务暴露逻辑

-------

# 4 API 配置（三）之服务消费者 #
主要是消费者的配置。
前面基本配置流程和provider差不多，主要是后面引用服务的部分不同
## 4.1 AbstractReferenceConfig ##
抽象引用配置类。
需要配置的标签为：
````
<dubbo:reference>//服务消费者引用服务配置。对应的配置类： com.alibaba.dubbo.config.ReferenceConfig
<dubbo:consumer>//服务消费者缺省值配置。配置类： com.alibaba.dubbo.config.ConsumerConfig 。同时该标签为 <dubbo:reference> 标签的缺省值设置。
````

## 4.2 ConsumerConfig ##
服务消费者缺省值配置。主要解析的标签是：<dubbo:consumer>

## 4.3 ReferenceConfig ##
服务消费者引用服务配置类。
主要解析的标签是：<dubbo:consumer>
在ReferenceConfig 的初始化示例代码中（消费者初始化代码），最后调用的是 ServiceConfig#get() 方法。从方法的命名，我们可以看出，获取引用服务。该方法主要做了如下几件事情：

1. 进一步初始化 ReferenceConfig 对象。
2. 校验 ReferenceConfig 对象的配置项。
3. 使用 ReferenceConfig 对象，生成 Dubbo URL 对象数组。
4. 使用 Dubbo URL 对象，应用服务。

在#get()函数中，主要是完成 init() 方法的调用，完成服务的初始化。
主要过程为：

1. 若已经初始化( initialized = true ) 时，直接返回。否则，标记已经初始化。
2. 校验接口名 interfaceName 非空（interface service的path）。
3. 调用 #checkDefault() 方法，读取属性配置( 环境变量 + properties 属性 )到 ConsumerConfig 对象。
4. 调用 #appendProperties(config) 方法，读取属性配置( 环境变量 + properties 属性 )到 ReferenceConfig 对象（自己）
5. 若未设置 generic 属性，使用 ConsumerConfig.generic 属性。
6. 泛化接口的实现。
7. 普通接口的实现。
	1. 根据 interfaceName ，获得对应的接口类，并赋值给 interfaceClass(使用反射获取类)。
	2. 调用 #checkInterfaceAndMethods(interfaceClass, methods) 方法，检查接口和方法。
8. 直连提供者（若配置了直连provider，比如配置了 <dubbo:reference id="xxxService" interface="com.alibaba.xxx.XxxService" url="dubbo://localhost:20890" /> 或者在jvm启动参数中加入 java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 便可以直接连接provider，绕过注册中心。注意，此配置仅用于开发，线上环境删除）。
9. 从 ConsumerConfig、ModuleConfig、ApplicationConfig 配置对象，复制 application module registries monitor 给 ReferenceConfig ( 自己 )。
10. 调用 #checkApplication() 方法，校验 ApplicationConfig 配置。
11. 调用 #checkStubAndMock(interfaceClass) 方法，校验 Stub 和 Mock 相关的配置。
12. 创建参数集合 map ，用于下面创建 Dubbo URL 的 parameters 属性。
13. 将 side dubbo timestamp timestamp pid 添加到 map 中。
14. 将 interface methods revision 到 map 中。
15. 调用 #appendParameters(map, config) 方法，将各种配置对象添加到 map 中。
16. 调用 MethodConfig 对象数组，添加到 map 中。
	1. 目的是将每个 MethodConfig 和其对应的 ArgumentConfig 对象数组，添加到 map 中。
	2. 调用 #appendAttributes(parameters, config, prefix) 方法，将 @Parameter(attribute = true) 配置对象的属性，添加到参数集合。
	3. 调用 #checkAndConvertImplicitConfig(method, map, attributes) 方法，检查属性集合中的事件通知方法是否正确。若正确，进行转换。
17. 以系统换将变量 ( DUBBO_IP_TO_REGISTRY ) 作为服务注册地址，
18. 添加到 com.alibaba.dubbo.rpc.StaticContext 进行缓存。
19. 【服务引用】逻辑-创建 Service 代理对象。

-------

# 5. 属性配置 #
如果公共配置很简单，没有多注册中心，多协议等情况，或者想多个 Spring 容器想共享配置，可以使用 dubbo.properties 作为缺省配置。
Dubbo 将自动加载 classpath 根目录下的 dubbo.properties，可以通过JVM启动参数 -Ddubbo.properties.file=xxx.properties 改变缺省配置位置。

- 属性配置，不支持多注册中心，多协议等情况
- 外部化配置，能够解决上述的问题

## 5.1 AbstractConfig ##
在 AbstractConfig 中，提供了 #appendProperties(config) 方法，读取启动参数变量和 properties 配置到配置对象。

配置策略在：https://dubbo.gitbooks.io/dubbo-user-book/configuration/properties.html

-------

# 6 XML 配置 #
XML 配置，自定义 <dubbo: /> 标签，基于 Spring XML 进行解析
xml配置在：https://dubbo.gitbooks.io/dubbo-user-book/configuration/xml.html
https://dubbo.gitbooks.io/dubbo-user-book/references/xml/introduction.html

-------

# 7. 核心流程 #
框架设计：

![](/picture/dubbo-frame.png)

### 7.1.1 图例说明 ###
- 最顶上九个图标，代表本图中的对象与流程。
- 图中左边 淡蓝背景( Consumer ) 的为服务消费方使用的接口，右边 淡绿色背景( Provider ) 的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。
- 图中从下至上分为十层，各层均为单向依赖，右边的 黑色箭头( Depend ) 代表层之间的依赖关系，每一层都可以剥离上层被复用。其中，Service 和 Config 层为 API，其它各层均为 SPI 。
- 图中 绿色小块( Interface ) 的为扩展接口，蓝色小块( Class ) 为实现类，图中只显示用于关联各层的实现类。
- 图中 蓝色虚线( Init ) 为初始化过程，即启动时组装链。红色实线( Call )为方法调用过程，即运行时调时链。紫色三角箭头( Inherit )为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。

### 7.1.2 各层说明 ###
------------business------------
- Service 业务层：业务代码的接口与实现。我们实际使用 Dubbo

------------RPC------------
- config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 Spring 解析配置生成配置类。
	- dubbo-config 模块实现。
- proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory 。
	- dubbo-rpc-rpc 模块实现。
	- com.alibaba.dubbo.rpc.proxy包 + com.alibaba.dubbo.rpc.ProxyFactory接口 。
- registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService 。
	- dubbo-registry 模块实现。
- cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance 。
	- dubbo-cluster 模块实现。
- monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService 。
	- dubbo-monitor 模块实现。

------------Remoting------------
- protocol 远程调用层：封将 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter 。
	- dubbo-rpc-rpc 模块实现。
	- com.alibaba.dubbo.rpc.protocol包 + com.alibaba.dubbo.rpc.Protocol接口 。
- exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer 。
	- dubbo-remoting-api 模块定义接口。
	- com.alibaba.dubbo.remoting.exchange包。
- transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec 。
	- dubbo-remoting-api 模块定义接口。
	- com.alibaba.dubbo.remoting.transport包。
- serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool 。
	- dubbo-common 模块实现。
	- com.alibaba.dubbo.common.serialize包。

### 7.1.3 关系说明 ###
1. 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。
2. 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。
3. 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。
4. Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。（简单粗暴的说，Proxy 会拦截 service.doSomething(args) 的调用，“转发”给该 Service 对应的 Invoker ，从而实现透明化的代理。）
5. 而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上。Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输；而 Exchange 层是在传输层之上封装了 Request-Response 语义。
6. Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。

## 7.2 核心流程 ##

### 7.2.1 调用链 ###
展开总设计图的红色调用链( Call )，如下：

![](/picture/dubbo-call.png)


- 垂直分层如下：
	- 下方 淡蓝背景( Consumer )：服务消费方使用的接口
	- 上方 淡绿色背景( Provider )：服务提供方使用的接口
	- 中间 粉色背景( Remoting )：通信部分的接口
- 自 LoadBalance 向上，每一行分成了多个相同的 Interface ，指的是负载均衡后，向 Provider 发起调用。
- 左边 括号 部分，代表了垂直部分更细化的分层，依次是：Common、Remoting、RPC、Interface 。
- 右边 蓝色虚线( Init ) 为初始化过程，通过对应的组件进行初始化。例如，ProxyFactory 初始化出 Proxy 。

### 7.2.2 暴露服务 ###
展开总设计图左边服务提供方暴露服务的蓝色初始化链( Init )，时序图如下：
![](/picture/dubbo-provider-init.png)

### 7.2.3 引用服务 ###
展开总设计图右边服务消费方引用服务的蓝色初始化链( Init )，时序图如下：
![](/picture/dubbo-consumer-init.png)

## 7.3 领域模型 ##
### 7.3.1 Invoker ###
com.alibaba.dubbo.rpc.Invoker 。

Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它。它代表一个可执行体，可向它发起 invoke 调用。
它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。

- getInterface() 方法，获得 Service 接口。
- invoke(Invocation) 方法，调用方法。

#### 7.3.1.1 Invoker ####
由于 Invoker 是 Dubbo 领域模型中非常重要的一个概念，很多设计思路都是向它靠拢。

服务提供 Invoker 和服务消费 Invoker：

![](/picture/dubbo-invoker.png)

服务消费者代码：
````
public class DemoClientAction {

    private DemoService demoService;

    public void setDemoService(DemoService demoService) {
        this.demoService = demoService;
    }

    public void start() {
        String hello = demoService.sayHello("world" + i);
    }
}
````
上面代码中的 DemoService 就是上图中服务消费端的 Proxy，用户代码通过这个 Proxy 调用其对应的 Invoker，而该 Invoker 实现了真正的远程服务调用。

服务提供者代码：
````
public class DemoServiceImpl implements DemoService {

    public String sayHello(String name) throws RemoteException {
        return "Hello " + name;
    }
}
````
上面这个类会被封装成为一个 AbstractProxyInvoker 实例，并新生成一个 Exporter 实例。这样当网络通讯层收到一个请求后，会找到对应的 Exporter 实例，并调用它所对应的 AbstractProxyInvoker 实例，从而真正调用了服务提供者的代码。

### 7.3.2 Invocation ###

Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。

### 7.3.3 Result ###
Result 是会话域，它持有调用过程中返回值，异常等。

### 7.3.4 Filter ###

过滤器接口，和我们平时理解的 javax.servlet.Filter 基本一致。

### 7.3.5 ProxyFactory ###
代理工厂接口。

#### 7.3.5.1 内部方法声明 ####

- getProxy(invoker) 方法，创建 Proxy ，在引用服务时调用。

服务消费着引用服务的 主过程 如下图：

![](/picture/dubbo-consumer-flow.png)

- 从图中我们可以看出，方法的 invoker 参数，通过 Protocol 将 Service接口 创建出 Invoker 。
- 通过创建 Service 的 Proxy ，实现我们在业务代理调用 Service 的方法时，透明的内部转换成调用 Invoker 的 #invoke(Invocation) 方法。

- getInvoker(proxy, type, url) 方法，创建 Invoker ，在暴露服务时调用。

服务提供者暴露服务的 主过程 如下图：

![](/picture/dubbo-provider-flow.png)

从图中我们可以看出，该方法创建的 Invoker ，下一步会提交给 Protocol ，从 Invoker 转换到 Exporter 。

### 7.3.6 Protocol ###

Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口。
它负责 Invoker 的生命周期管理。

#### 7.3.6.1 内部方法声明 ####

export(invoker)方法，暴露远程服务

1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();
2. export() 必须是幂等的，也就是暴露同一个 URL 的 Invoker 两次，和暴露一次没有区别。
3. export() 传入的 Invoker 由框架实现并传入，协议不需要关心。

refer(type, url)方法，引用远程服务

1. 当用户调用 refer() 所返回的 Invoker 对象的 invoke() 方法时，协议需相应执行同 URL 远端 export() 传入的 Invoker 对象的 invoke() 方法。
2. refer() 返回的 Invoker 由协议实现，协议通常需要在此 Invoker 中发送远程请求。
3. 当 url 中有设置 check=false 时，连接失败不能抛出异常，并内部自动恢复。

destroy()方法，释放协议

1. 取消该协议所有已经暴露和引用的服务。
2. 释放协议所占用的所有资源，比如连接和端口。
3. 协议在释放后，依然能暴露和引用新的服务。

Dubbo 处理服务暴露的关键就在 Invoker 转换到 Exporter 的过程。下面我们以 Dubbo 和 RMI 这两种典型协议的实现来进行说明：

- Dubbo 的实现
	- Dubbo 协议的 Invoker 转为 Exporter 发生在 DubboProtocol 类的 export 方法，它主要是打开 socket 侦听服务，并接收客户端发来的各种请求，通讯细节由 Dubbo 自己实现。

- RMI 的实现
	- RMI 协议的 Invoker 转为 Exporter 发生在 RmiProtocol 类的 export 方法，它通过 Spring 或 Dubbo 或 JDK 来实现 RMI 服务，通讯细节这一块由 JDK 底层来实现，这就省了不少工作量。

## 7.4 Exporter ##

Exporter ，Invoker 暴露服务在 Protocol 上的对象。

- getInvoker() 方法，获得对应的 Invoker 。
- unexport() 方法，取消暴露。
	- Exporter 相比 Invoker 接口，多了 这个方法。通过实现该方法，使相同的 Invoker 在不同的 Protocol 实现的取消暴露逻辑。

### 7.4.1 InvokerListener ###
Invoker 监听器。

### 7.4.2 ExporterListener ###
Exporter 监听器。


# 8 服务暴露（一）之本地暴露（Injvm） #
本地暴露无需向注册中心注册。

配置的每一个需要暴露的服务都需要经历下面的步骤:解析->生成url->暴露服务。

## 8.1 doExportUrls ##

本地暴露服务的顺序图如下：

![](/picture/dubbo-local-export.png)

### 8.1.1 loadRegistries ###

loadRegistries(provider) 方法，加载注册中心 com.alibaba.dubbo.common.URL 数组

大概流程如下：

1. 调用 #checkRegistry() 方法，校验 RegistryConfig 配置数组，实际上，该方法会初始化 RegistryConfig 的配置属性。
2. 创建注册中心 URL 数组。创建一个list保存数组。
3. 循环注册中心配置对象数组 registries 。循环配置的registries，把每个元素都配置成URL
4. 获得注册中心的地址 address 。如果配置为空的话，用本地ip（0.0.0.0）代替，如果在jvm启动参数中配置，便用本地的配置代替配置的。
	1. 从启动参数 dubbo.registry.address 读取，若存在，最高优先级，进行覆盖。
5. 地址 address 是有效地址，包括 address != N/A 。若配置的是"N/A"则不配置注册中心
	1. "N/A" 代表不配置注册中心。
6. 创建参数集合 map 。用于保存注册中心的参数。
7. 调用 #appendParameters(map, config) 方法，将各种配置对象，添加到 map 集合中。
	1. RegistryConfig#getAddress() 上有 @Parameter(excluded = true) ，因此 Registry.address 属性不会添加到 map 中。
8. 添加 path dubbo timestamp pid 到 map 集合中。
9. 若不存在 protocol 参数，缺省默认为 “dubbo” ，并添加到 map 集合中。若配置的注册中心没有配置protocal参数，默认protocol参数为dubbo
	1. 可以忽略。因为，remote 这个拓展实现已经不存在。
10. 调用 UrlUtils#parseURLs(address, map) 方法，解析 address ，创建 Dubbo URL 数组（数组大小可以为一）。创建的注册中心URL基本格式为：zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&logger=jcl&pid=7816&qos.port=22222&timestamp=1544874706783
	1. address 可以使用 "|" 或者 ";" 作为分隔符，设置多个注册中心分组。注意，一个注册中心集群是一个分组，而不是多个。
11. 循环 urls ，设置 “registry” 和 “protocol” 属性。
	1. 设置 registry=${protocol} 和 protocol=registry 到 URL 。
	2. 若是服务提供者，判断是否只订阅不注册。如果是，不添加结果到 registryList 中。对应 《Dubbo 用户指南 —— 只订阅》 文档。
	3. 若是服务消费者，判断是否只注册不订阅。如果是，不添加到结果 registryList 。对应 《Dubbo 用户指南 —— 只注册》 文档。
	4. 添加到结果 registryList 。生成的结果类似于：registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&logger=jcl&pid=7816&qos.port=22222&registry=zookeeper&timestamp=1544874706783

### 8.1.2 doExportUrlsFor1Protocol ###
doExportUrlsFor1Protocol(protocolConfig, registryURLs) 方法，基于单个协议，暴露服务。简化代码如下：

大概流程如下：

1. 创建服务 URL 对象。类似dubbo://192.168.29.215:20880/com.alibaba.dubbo.demo.DemoService?accesslog=true&anyhost=true&application=demo-provider&bind.ip=192.168.29.215&bind.port=20880&callbacks=1000&default.delay=-1&default.retries=0&delay=-1&deprecated=false&dubbo=2.0.0&generic=false&group=g1&interface=com.alibaba.dubbo.demo.DemoService&logger=jcl&methods=sayHello,callbackParam,save,update,say03,delete,say04,demo,say01,bye,say02,hello02,saves,hello01,hello&pid=7816&qos.port=22222&say01.deprecated=true&server=netty4&service.filter=demo&side=provider&timeout=200000&timestamp=1544875301827
2. 当非 "remote" 时，调用 #exportLocal(url) 方法，本地暴露服务。
3. 非 "local" 时，远程暴露服务。(远程暴露下面讲解)

### 8.1.3 exportLocal ###
exportLocal(url) 方法，本地暴露服务。

URL ：Exporter 不一定是 1：1 的关系。
例如：scope 未设置时，会暴露 Local + Remote 两个，也就是 URL ：Exporter = 1：2
     scope 设置为空时，不会暴露，也就是 URL ：Exporter = 1：0
     scope 设置为 Local 或 Remote 任一时，会暴露 Local 或 Remote 一个，也就是 URL ：Exporter = 1：1

参数说明：

- protocol 静态属性，自适应 Protocol 实现对象。
- proxyFactory 静态属性，自适应 ProxyFactory 实现对象。
- interfaceClass 属性，Service 接口。
- ref 属性，Service 对象。
- exporters 属性，Exporter 集合。

基本流程如下：

1. 基于原有 url ，创建新的服务的本地 Dubbo URL 对象，并设置属性 protocol=injvm host=127.0.0.1 port=0 。因为 url 在后面远程暴露服务会使用，所以要新创建。
2. 添加服务的真实类名，例如 DemoServiceImpl ，仅用于 RestProtocol 中。
3. 调用 ProxyFactory#getInvoker(proxy, type, url) 方法，创建 Invoker 对象。该 Invoker 对象，执行 #invoke(invocation) 方法时，内部会调用 Service 对象( ref )对应的调用方法。
4. 用 Protocol#export(invoker) 方法，暴露服务。实际只是把url缓存到本地一个map缓存中。 key类似于：g1/com.alibaba.dubbo.demo.DemoService，value为InjvmExporter对象。
	1. 此处 Dubbo SPI 自适应的特性的好处就出来了，可以自动根据 URL 参数，获得对应的拓展实现。例如，invoker 传入后，根据 invoker.url 自动获得对应 Protocol 拓展实现为 InjvmProtocol 。
	2. 实际上，Protocol 有两个 Wrapper 拓展实现类： ProtocolFilterWrapper、ProtocolListenerWrapper 。所以，#export(...) 方法的调用顺序是：Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => InjvmProtocol 。
	3. 添加到 exporters 集合中。

## 8.2 Protocol ##
Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口。
它负责 Invoker 的生命周期管理。有三个方法：
export():暴露服务
refer():引用远程服务
destroy():销毁服务。

### 8.2.1 Protocol$Adaptive ###
dubbo使用动态生成的自适应类*$Adaptive模板
#### 8.2.1.1 Adaptive注解 ####
@Adaptive:为生成Adaptive实例提供参数，作用域在类或方法上；
使用javassist字节码编译生成一个adaptive拦截所有请求，然后由它基于策略动态委派合适的provider进行处理。 
SPI接口会动态编译出一个adaptive，用于适配provider处理请求。

生成的动态类如下图：

![](/picture/dubbo-proxy$adaptive-class.png)

### 8.2.2 ProtocolFilterWrapper ###
实现 Protocol 接口，Protocol 的 Wrapper 拓展实现类，用于给 Invoker 增加过滤链。

#### 8.2.2.1 export ####

主要流程如下：

1. 当 invoker.url.protocl = registry ，跳过，本地暴露服务不会符合这个判断。在远程暴露服务会符合暴露该判断。
2. 调用 #buildInvokerChain(invoker, key, group) 方法，创建带有 Filter 过滤链的 Invoker 对象。
3. 调用 protocol#export(invoker) 方法，继续暴露服务。

#### 8.2.2.2 buildInvokerChain ####
创建带 Filter 链的 Invoker 对象。

主要属性：

- key 属性，获得 URL 参数名。
	- 该参数用于获得 ServiceConfig 或 ReferenceConfig 配置的自定义过滤器。
	- 例如配置的是：&lt;dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" filter="demo" /&gt;。生成的注册url为：url = injvm://127.0.0.1/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.3.17&bind.port=20880&default.delay=-1&default.retries=0&default.service.filter=demo&delay=-1&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=81844&qos.port=22222&service.filter=demo&side=provider&timestamp=1520682156043 中，service.filter=demo，这是配置自定义的 DemoFilter 过滤器。
- group 属性，分组。
	- 在暴露服务时，group = provider 。
	- 在引用服务时，group = consumer 。

主要流程如下：
1. 调用 ExtensionLoader#getActivateExtension(url, key, group) 方法，获得过滤器数组。上面的例子中，带有的filter就是：EchoFilter，ClassLoaderFilter，GenericFilter，ContextFilter，TraceFilter，TimeoutFilter，MonitorFilter，ExceptionFilter，DemoFilter 【自定义】‘
2. 倒序循环 Filter ，创建带 Filter 链的 Invoker 对象。因为是通过嵌套声明匿名类循环调用的方式，所以要倒序。

### 8.2.3 ProtocolListenerWrapper ###
实现 Protocol 接口，Protocol 的 Wrapper 拓展实现类，用于给 Exporter 增加 ExporterListener ，监听 Exporter 暴露完成和取消暴露完成。

#### 8.2.3.1 export ####

主要流程如下：

1. 当 invoker.url.protocl = registry ，跳过，本地暴露服务不会符合这个判断。在远程暴露服务会符合暴露该判断
2. 调用 InjvmProtocol#export(invoker) 方法，暴露本地服务，创建 InjvmExporter 对象。
3. 调用 ExtensionLoader#getActivateExtension(url, key, group) 方法，获得监听器数组。
	1. 以上面的例子为基础，listeners 为空。可以自行实现 ExporterListener ，并进行配置 @Activate 注解，或者 XML 中 listener 属性。
4. 创建带 ExporterListener 的 ListenerExporterWrapper 对象。在这个过程中，会执行 ExporterListener#exported(exporter) 方法。

### 8.2.4 AbstractProtocol ###
实现 Protocol 接口，协议抽象类。

- exporterMap 属性，Exporter 集合。该集合拥有该协议中，所有暴露中的 Exporter 对象。其中 key 为服务键。不同协议的实现，生成的方式略有差距。例如：
	- InjvmProtocol 使用 URL#getServiceKey() 方法
	- DubboProtocol 使用 #serviceKey(URL) 方法。
	- 差别主要在于是否包含 port 。实际上，也是一致的。因为 InjvmProtocol 统一 port=0 。

### 8.2.5 InjvmProtocol ###
实现 AbstractProtocol 抽象类，Injvm 协议实现类。

#### 8.2.5.1 属性 ####
- NAME 静态属性，injvm ，协议名。
- DEFAULT_PORT 静态属性，默认端口为 0 。
- INSTANCE 静态属性，单例。通过 Dubbo SPI 加载创建，有且仅有一次。
- getInjvmProtocol() 静态方法，获得单例。

#### 8.2.5.2 export ####

- 创建 InjvmExporter 对象。

## 8.3 Exporter ##
Exporter ，Invoker 暴露服务在 Protocol 上的对象。

### 8.3.1 AbstractExporter ###
实现 Exporter 接口，Exporter 抽象类。

属性：
- invoker 属性，Invoker 对象。
- unexported 属性，是否取消暴露服务。

方法：
- getInvoker() 方法，获得 Invoker 对象。
- unexport() 方法，取消暴露服务。

### 8.3.2 InjvmExporter ###
实现 AbstractExporter 抽象类，Injvm Exporter 实现类。

属性：
- key 属性，服务键。
- exporterMap 属性，Exporter 集合。在上文 InjvmProtocol#export(invoker) 方法中，我们可以看到，该属性就是 AbstractProtocol.exporterMap 属性。

方法：
- 构造方法，发起暴露，将自己添加到 exporterMap 中。
- unexport() 方法，取消暴露，将自己移除出 exporterMap 中。

### 8.3.3 ListenerExporterWrapper ###
实现 Exporter 接口，具有监听器功能的 Exporter 包装器。

主要作用：
- 构造方法，循环 listeners ，执行 ExporterListener#exported(listener) 。若执行过程中发生异常 RuntimeException ，打印错误日志，继续执行，最终才抛出。
- unexport() 方法，循环 listeners ，执行 ExporterListener#unexported(listener) 。若执行过程中发生异常 RuntimeException ，打印错误日志，继续执行，最终才抛出。

## 8.4 ExporterListener ##
Exporter 监听器。

### 8.4.1 ExporterListenerAdapter ###
实现 ExporterListener 接口，ExporterListener 适配器抽象类。

# 9 服务暴露（二）之远程暴露（Dubbo） #
特性：
缺省协议，使用基于 mina 1.1.7 和 hessian 3.2.1 的 remoting 交互。

- 连接个数：单连接
- 连接方式：长连接
- 传输协议：TCP
- 传输方式：NIO 异步传输
- 序列化：Hessian 二进制序列化
- 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。
- 适用场景：常规远程服务方法调用

相比本地暴露，远程暴露会多做如下几件事情：

- 启动通信服务器，绑定服务端口，提供远程调用。
- 向注册中心注册服务提供者，提供服务消费者从注册中心发现服务。

## 9.1 远程暴露 ##

远程暴露服务的顺序图如下：

![](/picture/dubbo-remote-export-flow.png)

在 #doExportUrlsFor1Protocol(protocolConfig, registryURLs) 方法中，涉及远程暴露服务，基本流程如下:

1. 循环祖册中心 URL 数组 registryURLs 。
2. "dynamic" 配置项，服务是否动态注册。如果设为 false ，注册后将显示后 disable 状态，需人工启用，并且服务提供者停止时，也不会自动取消册，需人工禁用。
3. 调用 #loadMonitor(registryURL) 方法，获得监控中心 URL 。
4. 调用 URL#addParameterAndEncoded(key, value) 方法，将监控中心的 URL 作为 "monitor" 参数添加到服务提供者的 URL 中，并且需要编码。通过这样的方式，服务提供者的 URL 中，包含了监控中心的配置。
5. 调用 URL#addParameterAndEncoded(key, value) 方法，将服务体用这的 URL 作为 "export" 参数添加到注册中心的 URL 中。通过这样的方式，注册中心的 URL 中，包含了服务提供者的配置。
6. 调用 ProxyFactory#getInvoker(proxy, type, url) 方法，创建 Invoker 对象。该 Invoker 对象，执行 #invoke(invocation) 方法时，内部会调用 Service 对象( ref )对应的调用方法。
7. 创建 com.alibaba.dubbo.config.invoker.DelegateProviderMetaDataInvoker 对象。该对象在 Invoker 对象的基础上，增加了当前服务提供者 ServiceConfig 对象。
8. 调用 Protocol#export(invoker) 方法，暴露服务。
	1. 此处 Dubbo SPI 自适应的特性的好处就出来了，可以自动根据 URL 参数，获得对应的拓展实现。例如，invoker 传入后，根据 invoker.url 自动获得对应 Protocol 拓展实现为 DubboProtocol 。
	2. 实际上，Protocol 有两个 Wrapper 拓展实现类： ProtocolFilterWrapper、ProtocolListenerWrapper 。所以，#export(...)方法的调用顺序是：Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => RegistryProtocol
=> Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => DubboProtocol。也就是说，这一条大的调用链，包含两条小的调用链。原因是：
		- 首先，传入的是注册中心的 URL ，通过 Protocol$Adaptive 获取到的是 RegistryProtocol 对象。
		- 其次，RegistryProtocol 会在其 #export(...) 方法中，使用服务提供者的 URL ( 即注册中心的 URL 的 export 参数值)，再次调用 Protocol$Adaptive 获取到的是 DubboProtocol 对象，进行服务暴露。
		- 为什么是这样的顺序？通过这样的顺序，可以实现类似 AOP 的效果，在本地服务器启动完成后，再向注册中心注册。
9. 添加到 exporters 集合中。

**个人理解：**
生成invoker对象时，是把service具体实现，service interface path 和生成的url组合成一个invoker对象，并且存入exporters集合中，当需要使用的时候，取出相应的对象，执行相应的逻辑，并且返回结果。

### 9.1.1 loadMonitor ###
loadMonitor(registryURL) 方法，加载监控中心 com.alibaba.dubbo.common.URL 数组

基本流程如下：
1. 从属性配置中，加载配置到 MonitorConfig 对象。
2. 添加 interface dubbo timestamp pid 到 map 集合中。
3. 调用 #appendParameters(map, config) 方法，将 MonitorConfig ，添加到 map 集合中。
4. 获得监控中心的地址。
5. 当 address 非空时，直连监控中心服务器地址的情况。
	1. 若不存在 protocol 参数，缺省默认为 “dubbo” ，并添加到 map 集合中。
	2. 调用 UrlUtils#parseURL(address, map) 方法，解析 address ，创建 Dubbo URL 对象。
6. 当 protocol = registry 时，并且注册中心 URL 非空时，从注册中心发现监控中心地址。以 registryURL 为基础，创建 URL ：
	- protocol = dubbo
	- parameters.protocol = registry
	- parameters.refer = map
7. 无注册中心，返回空。

## 9.2 Protocol ##
### 9.2.1 ProtocolFilterWrapper ###

大致流程如下：
1. 当 invoker.url.protocl = registry ，注册中心的 URL ，无需创建 Filter 过滤链。
2. 调用 #buildInvokerChain(invoker, key, group) 方法，创建带有 Filter 过滤链的 Invoker 对象。
3. 调用 protocol#export(invoker) 方法，继续暴露服务。
4. RegistryProtocol 中，会调用 DubboProtocol#export(...) 方法。

### 9.2.2 RegistryProtocol ###
实现 Protocol 接口，注册中心协议实现类。

#### 9.2.2.1 属性 ####
- INSTANCE 静态属性，单例。通过 Dubbo SPI 加载创建，有且仅有一次。
	- getRegistryProtocol() 静态方法，获得单例。
- bounds 属性，绑定关系集合。其中，Key 为服务提供者 URL 。
- protocol 属性，Protocol 自适应拓展实现类，通过 Dubbo SPI 自动注入。
- registryFactory 属性，自适应拓展实现类，通过 Dubbo SPI 自动注入。
	- 用于创建注册中心 Registry 对象。

#### 9.2.2.2 export ####
用过滤链的 Invoker，暴露服务。

基本流程如下：
1. 调用 #doLocalExport(invoker) 方法，暴露服务。
2. 调用 #getRegistryUrl(originInvoker) 方法，获得注册中心 URL 。
3. 获得注册中心对象。
4. 调用 #getRegistedProviderUrl(originInvoker) 方法，获得服务提供者 URL 。
	1. 重点，从注册中心的 URL 中获得 export 参数对应的值，即服务提供者的 URL 。
	2. 移除多余的参数。因为，这些参数注册到注册中心没有实际的用途。
5. 配置项 register ，服务提供者是否注册到配置中心。
6. 调用 ProviderConsumerRegTable#registerProvider(invoker, registryUrl) 方法，向本地注册表，注册服务提供者。
7. 调用 #register(registryUrl, registedProviderUrl) 方法，向注册中心注册服务提供者（自己）。
	1. 调用 RegistryService#register(url) 方法
8. 标记向本地注册表的注册服务提供者，已经注册。
9. 使用 OverrideListener 对象，订阅配置规则。
10. 创建 DestroyableExporter 对象。

#### 9.2.2.3 doLocalExport ####
doLocalExport() 方法，暴露服务。此处的 Local 指的是，本地启动服务，但是不包括向注册中心注册服务的意思。

基本流程如下：
1. 调用 #getCacheKey(originInvoker) 方法，获得在 bounds 中的缓存 Key 。
2. 从 bounds 中，获得已经暴露过的 ExporterChangeableWrapper 对象。
3. 未暴露过，进行暴露服务。
	1. 调用 #getProviderUrl(originInvoker) 方法，获得服务提供者的 URL 。
	2. 创建 com.alibaba.dubbo.registry.integration.RegistryProtocol.InvokerDelegete 对象。
		1. InvokerDelegete 实现 com.alibaba.dubbo.rpc.protocol.InvokerWrapper 类，主要增加了 #getInvoker() 方法，获得真实的，非 InvokerDelegete 的 Invoker 对象。因为，可能会存在 InvokerDelegete.invoker 也是 InvokerDelegete 类型的情况。
	3. 调用 DubboProtocol#export(invoker) 方法，暴露服务，返回 Exporter 对象。
	4. 使用【创建的 Exporter 对象】+【originInvoker】，创建 ExporterChangeableWrapper 对象。这样，originInvoker 就和 Exporter 对象，形成了绑定的关系。
	5. 添加到 bounds 。 

````
// 用于解决rmi重复暴露端口冲突的问题，已经暴露过的服务不再重新暴露
// providerurl <--> exporter
private final Map<String, ExporterChangeableWrapper<?>> bounds = new ConcurrentHashMap<String, ExporterChangeableWrapper<?>>();
````

### 9.2.3 DubboProtocol ###
实现 AbstractProtocol 抽象类，Dubbo 协议实现类。

#### 9.2.3.1 属性 ####
serverMap 属性，通信服务器集合。其中，Key 为服务器地址，格式为 host:port。

#### 9.2.3.2 export ####

基本流程如下：

1. 调用 #serviceKey(url) 方法，获得服务键。该方法从父类继承而来。
2. 创建 DubboExporter 对象。
3. 添加到 exporterMap 中。该属性从父类继承而来。
4. 调用 #openServer(url) 方法，启动服务器。（即启动通信服务，创建并启动一个server客户端，对外提供服务。）
5. 调用 #optimizeSerialization(url) 方法，初始化序列化优化器。

**个人理解**
provider提供一个服务，最终的结果就是对外提供一个server客户端，能对外提供服务。

#### 9.2.3.3 openServer ####

openServer(url) 方法，启动通信服务器。

基本流程为：
1. 获得服务器地址。
2. 从 serverMap 获得对应服务器地址已存在的通信服务器。即，不重复创建。
3. 通信服务器不存在，调用 #createServer(url) 方法，创建服务器。
4. 通信服务器已存在，调用 Server#reset(url) 方法，重置服务器的属性。
	1. 为什么会存在呢？因为键是 host:port ，那么例如，多个 Service 共用同一个 Protocol ，服务器是同一个对象。

#### 9.2.3.4 createServer ####
创建并启动通信服务器。

基本流程：
1. 默认开启 Server 关闭时，发送 READ_ONLY 事件。
2. 默认开启心跳功能。
3. 校验配置的 Server 的 Dubbo SPI 拓展是否存在。若不存在，抛出 RpcException 异常。
4. 设置编解码器为 "Dubbo" 协议，即 DubboCountCodec 。
5. 调用 Exchangers#bind(url, handler) 方法，启动服务器。
6. 校验配置的 Client 的 Dubbo SPI 拓展是否存在。若不存在，抛出 RpcException 异常。默认情况下，未配置，所以不会校验。
7. 返回通信服务器。

## 9.3 Exporter ##
### 9.3.1 ExporterChangeableWrapper ###
com.alibaba.dubbo.registry.integration.RegistryProtocol.ExporterChangeableWrapper ，实现 Exporter 接口，Exporter 可变的包装器。

- 建立【返回的 Exporter】与【Protocol export 出的 Exporter】的对应关系。
- 在 override 时可以进行关系修改。

### 9.3.2 DestroyableExporter ###
com.alibaba.dubbo.registry.integration.RegistryProtocol.DestroyableExporter ，实现 Exporter 接口，可销毁的 Exporter 实现类。

- Exporter 代理，建立原始的 Invoker 与 Protocol#export(Invoker<T> invoker) 方法返回的 Exporter 的对应关系。
- 在配置规则发生变化时，可调用 #setExporter(Exporter<T>) 方法，修改对应关系。

### 9.3.3 DubboExporter ###
com.alibaba.dubbo.rpc.protocol.dubbo.DubboExporter ，实现 AbstractExporter 抽象类，Dubbo Exporter 实现类。

属性：
- key 属性，服务键。
- exporterMap 属性，Exporter 集合。
	- 构造方法，发起暴露，将自己添加到 exporterMap 中。	
	- unexport() 方法，取消暴露，将自己移除出 exporterMap 中。

----

# 10 服务引用（一）之本地引用（Injvm） #

## 10.1 createProxy ##

本地引用服务的顺序图如下

![](./picture/dubbo-consumer-injvm-flow.png)

函数说明：
属性：
- map 方法参数，URL 参数集合，包含服务引用配置对象的配置项。

基本流程如下：
1. 创建 URL 对象，重点在第四个参数，传入的是 map 
2. 是否本地引用变量 isJvmRefer 。
3. 调用 #isInjvm() 方法，返回非空，说明配置了 injvm 配置项，直接使用配置项。
4. 配置了 url 配置项，说明使用直连服务提供者的功能，则不使用本地使用。
5. 调用 InjvmProtocol#isInjvmRefer(url) 方法，通过 tmpUrl 判断，是否需要本地引用。使用 tmpUrl ，相当于使用服务引用配置对象的配置项。
6. 本地引用
	1. 创建本地服务引用 URL 对象。
	2. 调用 Protocol#refer(interface, url) 方法，引用服务，返回 Invoker 对象。
		1. 此处 Dubbo SPI 自适应的特性的好处就出来了，可以自动根据 URL 参数，获得对应的拓展实现。例如，invoker 传入后，根据 invoker.url 自动获得对应 Protocol 拓展实现为 InjvmProtocol 。
		2. 实际上，Protocol 有两个 Wrapper 拓展实现类： ProtocolFilterWrapper、ProtocolListenerWrapper 。所以，#refer(...) 方法的调用顺序是：Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => InjvmProtocol 。
7. 若配置 check = true 配置项时，调用 Invoker#isAvailable() 方法，启动时检查。
8. 调用 ProxyFactory#getProxy(invoker) 方法，创建 Service 代理对象。该 Service 代理对象的内部，会调用 Invoker#invoke(Invocation) 方法，进行 Dubbo 服务的调用。


## 10.2 Protocol ##

### 10.2.1 ProtocolFilterWrapper ###

#### 10.2.1.1 refer ####

主要流程如下：
1. 当 invoker.url.protocl = registry ，跳过，本地引用服务不会符合这个判断。
2. 调用 protocol#refer(type, url) 方法，继续引用服务，最终返回 Invoker 。
3. 在引用服务完成后，调用 #buildInvokerChain(invoker, key, group) 方法，创建带有 Filter 过滤链的 Invoker 对象。

#### 10.2.1.2 buildInvokerChain ####

默认情况下，获得的 Filter 数组如下：
- ConsumerContextFilter
- FutureFilter
- MonitorFilter

### 10.2.2 ProtocolListenerWrapper ###

涉及的 #refer(type, url) 方法，基本流程如下：

1. 当 invoker.url.protocl = registry ，跳过，本地引用服务不会符合这个判断。在远程引用服务会符合暴露该判断
2. 调用 protocol#refer(type, url) 方法，继续引用服务，最终返回 Invoker 。
3. 调用 ExtensionLoader#getActivateExtension(url, key, group) 方法，获得监听器数组。
4. 创建带 InvokerListener 的 ListenerInvokerWrapper 对象。在这个过程中，会执行 ExporterListener#referred(invoker) 方法。

### 10.2.3 InjvmProtocol ###

创建 InjvmInvoker 对象。注意，传入的 exporterMap 参数，包含所有的 InjvmExporter 对象。

## 10.3 Invoker ##
Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它。它代表一个可执行体，可向它发起 invoke 调用。
它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。

### 10.3.1 AbstractInvoker ###
com.alibaba.dubbo.rpc.protocol.AbstractInvoker ，实现 Invoker 接口，抽象 Invoker 类，主要提供了 Invoker 的通用属性和 #invoke(Invocation) 方法的通用实现。

### 10.3.2 InjvmInvoker ###

com.alibaba.dubbo.rpc.protocol.injvm.InjvmInvoker ，实现 AbstractInvoker 抽象类，Injvm Invoker 实现类。

#### 10.3.2.1 属性 ####

- key 属性，服务键。
- exporterMap 属性，Exporter 集合。在 InjvmInvoker#invoke(invocation) 方法中，通过该 Invoker 的 key 属性，获得对应的 Exporter 对象。

#### 10.3.2.2 isAvailable ####
isAvailable() 方法，是否可用

开启 启动时检查 时，调用该方法，判断该 Invoker 对象，是否有对应的 Exporter 。若不存在，说明依赖服务不存在，检查不通过。

### 10.3.3 ListenerInvokerWrapper ###

com.alibaba.dubbo.rpc.listener.ListenerInvokerWrapper ，实现 Invoker 接口，具有监听器功能的 Invoker 包装器。

- 构造方法，循环 listeners ，执行 InvokerListener#referred(invoker) 方法。和 ListenerExporterWrapper 不同，若执行过程中发生异常 RuntimeException ，仅打印错误日志，继续执行，最终不抛出异常。
- unexport() 方法，循环 listeners ，执行 InvokerListener#destroyed(invoker) 。 和 ListenerExporterWrapper 不同，若执行过程中发生异常 RuntimeException ，仅打印错误日志，继续执行，最终不抛出异常。

## 10.4 InvokerListener ##

com.alibaba.dubbo.rpc.InvokerListener ，Invoker 监听器。

### 10.4.1 InvokerListenerAdapter ###
com.alibaba.dubbo.rpc.listener.InvokerListenerAdapter ，实现 InvokerListener 接口，InvokerListener 适配器抽象类。

### 10.4.2 DeprecatedInvokerListener ###
com.alibaba.dubbo.rpc.listener.DeprecatedInvokerListener ，实现 InvokerListenerAdapter 抽象类 ，引用废弃的服务时，打印错误日志提醒。

@Activate(Constants.DEPRECATED_KEY) 注解，基于 Dubbo SPI Activate 机制加载。

````
    <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" deprecated="true" />

    * 通过设置 `"deprecated"` 为 `true` 来设置。
    * 该方式仅适用于**远程引用**服务。
 
	* 在 `#referred(invoker)` 方法中，打印错误日志，例如：

    [25/03/18 07:37:56:056 CST] main ERROR listener.DeprecatedInvokerListener:  [DUBBO] The service com.alibaba.dubbo.demo.DemoService is DEPRECATED! Declare from dubbo://127.0.0.1:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&compiler=jdk&default.delay=-1&default.retries=0&delay=-1&deprecated=true&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello,bye&pid=45155&qos.port=33333&register.ip=127.0.0.1&remote.timestamp=1521977820764&service.filter=demo&side=consumer&timestamp=1521977854685, dubbo version: 2.0.0, current host: 127.0.0.1
    group:consumer
````
在引用本地服务时，不是使用服务提供者的URL，而是消费者的URL。

------

# 11 服务引用（二）之远程引用（Dubbo） #

特性

缺省协议，使用基于 mina 1.1.7 和 hessian 3.2.1 的 remoting 交互。

- 连接个数：单连接
- 连接方式：长连接
- 传输协议：TCP
- 传输方式：NIO 异步传输
- 序列化：Hessian 二进制序列化
- 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。
- 适用场景：常规远程服务方法调用

相比本地引用，远程引用会多做如下几件事情：

- 向注册中心订阅，从而发现服务提供者列表。
- 启动通信客户端，通过它进行远程调用。

## 11.1 远程引用 ##
远程暴露服务的顺序图如下：

![](./picture/dubbo-export-service-remote.png)

在 #createProxy(map) 方法中，涉及远程服务引用服务的代码如下

````
/**
 * 服务引用 URL 数组
 */
private final List<URL> urls = new ArrayList<URL>();
/**
 * 直连服务地址
 *
 * 1. 可以是注册中心，也可以是服务提供者
 * 2. 可配置多个，使用 ; 分隔
 */
// url for peer-to-peer invocation
private String url;

/**
 * 创建 Service 代理对象
 *
 * @param map 集合
 * @return 代理对象
 */
@SuppressWarnings({"unchecked", "rawtypes", "deprecation"})
private T createProxy(Map<String, String> map) {
    URL tmpUrl = new URL("temp", "localhost", 0, map);
    // 【省略代码】是否本地引用
    final boolean isJvmRefer;

    // 【省略代码】本地引用
    if (isJvmRefer) {
    // 正常流程，一般为远程引用
    } else {
        // 定义直连地址，可以是服务提供者的地址，也可以是注册中心的地址
        if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.
            // 拆分地址成数组，使用 ";" 分隔。
            String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);
            // 循环数组，添加到 `url` 中。
            if (us != null && us.length > 0) {
                for (String u : us) {
                    // 创建 URL 对象
                    URL url = URL.valueOf(u);
                    // 设置默认路径
                    if (url.getPath() == null || url.getPath().length() == 0) {
                        url = url.setPath(interfaceName);
                    }
                    // 注册中心的地址，带上服务引用的配置参数
                    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
                        urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));
                    // 服务提供者的地址
                    } else {
                        urls.add(ClusterUtils.mergeUrl(url, map));
                    }
                }
            }
        // 注册中心
        } else { // assemble URL from register center's configuration
            // 加载注册中心 URL 数组
            List<URL> us = loadRegistries(false);
            // 循环数组，添加到 `url` 中。
            if (us != null && !us.isEmpty()) {
                for (URL u : us) {
                    // 加载监控中心 URL
                    URL monitorUrl = loadMonitor(u);
                    // 服务引用配置对象 `map`，带上监控中心的 URL
                    if (monitorUrl != null) {
                        map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));
                    }
                    // 注册中心的地址，带上服务引用的配置参数
                    urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map))); // 注册中心，带上服务引用的配置参数
                }
            }
            if (urls == null || urls.isEmpty()) {
                throw new IllegalStateException("No such any registry to reference " + interfaceName + " on the consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() + ", please config <dubbo:registry address=\"...\" /> to your spring config.");
            }
        }

        // 单 `urls` 时，引用服务，返回 Invoker 对象
        if (urls.size() == 1) {
            // 引用服务
            invoker = refprotocol.refer(interfaceClass, urls.get(0));
        } else {
            // 循环 `urls` ，引用服务，返回 Invoker 对象
            List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();
            URL registryURL = null;
            for (URL url : urls) {
                // 引用服务
                invokers.add(refprotocol.refer(interfaceClass, url));
                // 使用最后一个注册中心的 URL
                if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
                    registryURL = url; // use last registry url
                }
            }
            // 有注册中心
            if (registryURL != null) { // registry url is available
                // 对有注册中心的 Cluster 只用 AvailableCluster
                // use AvailableCluster only when register's cluster is available
                URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);
                invoker = cluster.join(new StaticDirectory(u, invokers));
            // 无注册中心
            } else { // not a registry url
                invoker = cluster.join(new StaticDirectory(invokers));
            }
        }
    }

    // 【省略代码】启动时检查

    // 创建 Service 代理对象
    // create service proxy
    return (T) proxyFactory.getProxy(invoker);
}
````

基本流程如下：

1. url 配置项，定义直连地址，可以是服务提供者的地址，也可以是注册中心的地址。
	1. 拆分地址成数组，使用 “;” 分隔。
	2. 循环数组 us ，创建 URL 对象后，添加到 urls 中。
	3. 创建 URL 对象。
	4. 路径属性 url.path 未设置时，缺省使用接口全名 interfaceName 。
	5. 若 url.protocol = registry 时，注册中心的地址，在参数 url.parameters.refer 上，设置上服务引用的配置参数集合 map 。
	6. 服务提供者的地址。
2. protocol 配置项，注册中心。
	1. 调用 #loadRegistries(provider) 方法，加载注册中心的 com.alibaba.dubbo.common.URL` 数组。
	2. 循环数组 us ，创建 URL 对象后，添加到 urls 中。
		1. 调用 #loadMonitor(registryURL) 方法，获得监控中心 URL 。
		2. 服务引用配置对象 map，带上监控中心的 URL 。具体用途，我们在后面分享监控中心会看到。
		3. 调用 URL#addParameterAndEncoded(key, value) 方法，将服务引用配置对象参数集合 map ，作为 "refer" 参数添加到注册中心的 URL 中，并且需要编码。通过这样的方式，注册中心的 URL 中，包含了服务引用的配置。
3. 单 urls 时，直接调用 Protocol#refer(type, url) 方法，引用服务，返回 Invoker 对象。
	1. 此处 Dubbo SPI 自适应的特性的好处就出来了，可以自动根据 URL 参数，获得对应的拓展实现。例如，invoker 传入后，根据 invoker.url 自动获得对应 Protocol 拓展实现为 DubboProtocol 。
	2. 实际上，Protocol 有两个 Wrapper 拓展实现类： ProtocolFilterWrapper、ProtocolListenerWrapper 。所以，#export(...) 方法的调用顺序是：
		1. Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => RegistryProtocol => Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => DubboProtocol。也就是说，这一条大的调用链，包含两条小的调用链。原因是：
			1. 首先，传入的是注册中心的 URL ，通过 Protocol$Adaptive 获取到的是 RegistryProtocol 对象。
			2. 其次，RegistryProtocol 会在其 #refer(...) 方法中，使用服务提供者的 URL ( 即注册中心的 URL 的 refer 参数值)，再次调用 Protocol$Adaptive 获取到的是 DubboProtocol 对象，进行服务暴露。
		2. 通过这样的顺序，可以实现类似 AOP 的效果，在获取服务提供者列表后，再创建连接服务提供者的客户端。
4. 多 urls 时，循环调用 Protocol#refer(type, url) 方法，引用服务，返回 Invoker 对象。此时，会有多个 Invoker 对象，需要进行合并。
	1. 循环 urls ，引用服务。
		1. 调用 Protocol#refer(type, url) 方法，引用服务，返回 Invoker 对象。然后，添加到 invokers 中。

**个人理解**
通过此过程，默认用javassist方式动态生成service的代理，当需要调用此service的时候，调用里面的invoker，invoker调用远程服务，并得到返回结果。

## 11.2 Protocol ##
### 11.2.1 ProtocolFilterWrapper ###
和引用本地服务的流程差不多。

### 11.2.2 RegistryProtocol ###

#### 11.2.2.1 refer ####
获得真实的注册中心的 URL 的流程是loadRegistries的反向流程（红线部分）

![](/picture/dubbo-consumer-refer-remote.png)

refer(type, url)的基本流程如下:
1. 获得真实的注册中心的 URL
2. 获得注册中心 Registry 对象。
3. 获得服务引用配置参数集合 qs 。
4. 分组聚合
5. 调用 #doRefer(cluster, registry, type, url) 方法，执行服务引用。

#### 11.2.2.2 doRefer ####
doRefer(cluster, registry, type, url) 方法，执行服务引用的逻辑。

基本流程如下：
1. 创建 RegistryDirectory 对象，并设置注册中心到它的属性。
2. 获得服务引用配置集合 parameters 。注意，url 传入 RegistryDirectory 后，经过处理并重新创建，所以 url != directory.url ，所以获得的是服务引用配置集合。
3. 创建订阅 URL 对象。
4. 调用 RegistryService#register(url) 方法，向注册中心注册自己（服务消费者）。
5. 调用 Directory#subscribe(url) 方法，向注册中心订阅服务提供者 + 路由规则 + 配置规则。
	1. 在该方法中，会循环获得到的服务体用这列表，调用 Protocol#refer(type, url) 方法，创建每个调用服务的 Invoker 对象。
6. 创建 Invoker 对象。
7. 调用 ProviderConsumerRegTable#registerConsuemr(invoker, url, subscribeUrl, directory) 方法，向本地注册表，注册消费者。
8. 返回 Invoker 对象。

### 11.2.3 DubboProtocol ###
和远程通信的对象，内部定义了引用远程的执行体和引用通信模块的函数。

初始化连接的时候，会把本应用引用的服务从注册中心里面取出一个正常提供服务的地址，然后和这个地址建立rpc连接。所以所dubbo是单连接的。由于是默认用netty作为连接工具，所以说是长连接。

#### 11.2.3.1 refer ####

属性：
- invokers 属性，Invoker 集合。

主要流程如下：

1. 调用 #optimizeSerialization(url) 方法，初始化序列化优化器。
2. 调用 #getClients(url) 方法，创建远程通信客户端数组。
3. 创建 DubboInvoker 对象。
4. 添加到 invokers 。
5. 返回 Invoker 对象。

#### 11.2.3.2 getClients ####
getClients(url) 方法，获得连接服务提供者的远程通信客户端数组。

基本流程如下：

1. 是否共享连接。
2. 创建连接服务提供者的 ExchangeClient 对象数组。
	1. 若开启共享连接，基于 URL 为维度共享。
	2. 共享连接，调用 #getSharedClient(url) 方法，获得 ExchangeClient 对象。
	3. 不共享连接，调用 #initClient(url) 方法，直接创建 ExchangeClient 对象。

connections 配置项。

- 默认 0 。即，对同一个远程服务器，共用同一个连接。
- 大于 0 。即，每个服务引用，独立每一个连接。

#### 11.2.3.3 getSharedClient ####

getSharedClient(url) 方法，获得共享连接服务提供者通信客户端。

属性：

referenceClientMap 属性，通信客户端集合。在我们创建好 Client 对象，“连接”服务器后，会添加到这个集合中，用于后续的 Client 的共享。

- ReferenceCountExchangeClient ，顾名思义，带有指向数量计数的 Client 封装。
- “连接” ，打引号的原因，因为有 LazyConnectExchangeClient ，还是顾名思义，延迟连接的 Client 封装。
- ReferenceCountExchangeClient 和 LazyConnectExchangeClient 的具体实现

ghostClientMap 属性，幽灵客户端集合。

- 每次 ReferenceCountExchangeClient 彻底关闭( 指向归零 ) ，其内部的 client 会替换成重新创建的 LazyConnectExchangeClient 对象，此时叫这个对象为幽灵客户端，添加到 ghostClientMap 中。
- 当幽灵客户端，对应的 URL 的服务器被重新连接上后，会被移除。
- 在幽灵客户端被移除之前，referenceClientMap 中，依然保留着对应的 URL 的 ReferenceCountExchangeClient 对象。所以，ghostClientMap 相当于标记 referenceClientMap 中，哪些 LazyConnectExchangeClient 对象，是幽灵状态。

基本流程如下：

1. 从集合 referenceClientMap 中，查找 ReferenceCountExchangeClient 对象。
	1. 查找到客户端。
	2. 若未关闭，调用 ReferenceCountExchangeClient#incrementAndGetCount() 方法，增加指向该客户端的数量，并返回。
	3. 若已关闭，适用于幽灵状态的 ReferenceCountExchangeClient 对象，从 referenceClientMap 中移除，准备下面的代码，创建新的 ReferenceCountExchangeClient 对象。
4. 同步( synchronized ) ，创建新的 ReferenceCountExchangeClient 对象。
	1. 调用 #initClient(url) 方法，创建 ExchangeClient 对象。
	2. 将 ExchangeClient 对象，封装创建成 ReferenceCountExchangeClient 独享。
	3. 添加到集合 referenceClientMap 。
	4. 移除出集合 ghostClientMap ，因为不再是幽灵状态啦。

#### 11.2.3.4 initClient ####

initClient(url) 方法，创建 ExchangeClient 对象，”连接”服务器。

基本流程如下：

1. 校验配置的 Client 的 Dubbo SPI 拓展是否存在。若不存在，抛出 RpcException 异常。
2. 设置编解码器为 "Dubbo" 协议，即 DubboCountCodec 。
3. 默认开启心跳功能。
4. 连接服务器，创建客户端。
	1. 懒加载，创建 LazyConnectExchangeClient 对象。
	2. 直接连接，创建 HeaderExchangeClient 对象。

## 11.3 Invoker ##

Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它。它代表一个可执行体，可向它发起 invoke 调用。
它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。

### 11.3.1 DubboInvoker ###

## 11.4 Client ##

### 11.4.1 ReferenceCountExchangeClient ###

com.alibaba.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient ，实现 ExchangeClient 接口，支持指向计数的信息交换客户端实现类。

属性：
- refenceCount 属性，指向计数。
	- 【初始】构造方法，【第 21 行】，计数加一。
	- 【引用】每次引用，计数加一。
- ghostClientMap 属性，幽灵客户端集合，和 Protocol.ghostClientMap 参数，一致。
- client 属性，客户端。
	- 【创建】构造方法，传入 client 属性，指向它。
	- 【关闭】关闭方法，创建 LazyConnectExchangeClient 对象，指向该幽灵客户端。

### 11.4.2 LazyConnectExchangeClient ###

com.alibaba.dubbo.rpc.protocol.dubbo.LazyConnectExchangeClient ，实现 ExchangeClient 接口，支持懒连接服务器的信息交换客户端实现类。

# 12 Zookeeper 客户端 #
在 dubbo-remoting-zookeeper 模块，实现了 Dubbo 对 Zookeeper 客户端的封装。在该模块中，抽象了通用的 Zookeeper Client API 接口，实现了两种 Zookeeper Client 库的接入：Apache Curator 和 ZkClient
默认不配置 client 的情况下，使用 Curator 。

dubbo-remoting-zookeeper 的整体类图如下：

![](/picture/dubbo-remoting-zookeeper.png)

## 12.1 接口 ##

### 12.1.1 StateListener ###
com.alibaba.dubbo.remoting.zookeeper.StateListener ，状态监听器接口

### 12.1.2 ChildListener ###

com.alibaba.dubbo.remoting.zookeeper.StateListener ，节点监听器接口

### 12.1.3 ZookeeperClient ###
// todo zookeeper客户端内容完善

# 13 注册中心（一）之抽象 API #

dubbo-registry-api 模块，注册中心的抽象 API，类结构如下图：

![](/picture/dubbo-registry-api-class.png)

## 13.1 RegistryFactory ##

- RegistryFactory 是一个 Dubbo SPI 拓展接口。
- getRegistry(url) 方法，获得注册中心 Registry 对象。
	- @Adaptive({"protocol"}) 注解，Dubbo SPI 会自动实现 RegistryFactory$Adaptive 类，根据 url.protocol 获得对应的 RegistryFactory 实现类。例如，url.protocol = zookeeper 时，获得 ZookeeperRegistryFactory 实现类。

### 13.1 AbstractRegistryFactory ###
com.alibaba.dubbo.registry.support.AbstractRegistryFactory ，实现 RegistryFactory 接口，RegistryFactory 抽象类，实现了 Registry 的容器管理。

主要采用订阅者模式，当注册数据有变更时，自动推送。

#### 13.1.1 属性 ####

- REGISTRIES 静态属性，Registry 集合。
- LOCK 静态属性，锁，用于 #destroyAll() 和 #getRegistry(url) 方法，对 REGISTRIES 访问的竞争。

#### 13.1.2 createRegistry ####
createRegistry(url) 抽象方法，创建 Registry 对象。
子类实现该方法，创建其对应的 Registry 实现类。例如，ZookeeperRegistryFactory 的该方法，创建 ZookeeperRegistry 对象。

#### 13.1.3 getRegistry ####
getRegistry(url) 实现方法，获得注册中心 Registry 对象。优先从缓存中获取，否则进行创建。

#### 13.1.4 destroyAll ####
destroyAll() 方法，销毁所有 Registry 对象。


## 13.2 RegistryService ##
com.alibaba.dubbo.registry.RegistryService ，注册中心服务接口，定义了注册、订阅、查询三种操作方法，如下：

- register(url) 方法，注册数据，比如：提供者地址，消费者地址，路由规则，覆盖规则，等数据。
	- unregister(url) 方法，取消注册。
- subscribe(url, NotifyListener) 方法，订阅符合条件的已注册数据，当有注册数据变更时自动推送。
	- unsubscribe(url, NotifyListener) 方法，取消订阅。
	- 在 URL.parameters.category 属性上，表示订阅的数据分类。目前有四种类型：
		- consumers ，服务消费者列表。
		- providers ，服务提供者列表。
		- routers ，路由规则列表。
		- configurations ，配置规则列表。
- lookup(url) 方法，查询符合条件的已注册数据，与订阅的推模式相对应，这里为拉模式，只返回一次结果。


### 13.2.1 Registry ###
com.alibaba.dubbo.registry.Registry ，注册中心接口。Registry 继承了：

- RegistryService 接口，拥有注册、订阅、查询三种操作方法。
- com.alibaba.dubbo.common.Node 接口，拥有节点相关的方法。

### 13.2.2 AbstractRegistry ###
com.alibaba.dubbo.registry.support.AbstractRegistry ，实现 Registry 接口，Registry 抽象类，实现了如下方法：

- 通用的注册、订阅、查询、通知等方法。
- 持久化注册数据到文件，以 properties 格式存储。应用于，重启时，无法从注册中心加载服务提供者列表等信息时，从该文件中读取。

#### 13.2.2.1 属性 ####
- file 属性:本地磁盘缓存文件，缓存注册中心的数据
- properties 属性:本地磁盘缓存。1. 其中特殊的 key 值 .registies 记录注册中心列表;2. 其它均为 notified 服务提供者列表
	- 数据流向
		- 启动时，从 file 读取数据到 properties 中。
		- 注册中心数据发生变更时，通知到 Registry 后，修改 properties 对应的值，并写入 file 。
	- 数据键值
		- 大多数情况下，键为服务消费者的 URL 的服务键( URL#serviceKey() )，对应的值为服务提供者列表、路由规则列表、配置规则列表。
	- 因为值会存在为列表的情况，使用空格( URL_SEPARATOR ) 分隔。
- syncSaveFile 属性，properties 发生变更时候，是同步还是异步写入 file 。
- registryCacheExecutor 属性。注册中心缓存写入执行器。
- lastCacheChanged 属性。数据版本号
	- 因为每次写入 file 是全量，而不是增量写入，通过版本号，避免老版本覆盖新版本。
- registered 属性。已注册 URL 集合。
	- 注意，注册的 URL 不仅仅可以是服务提供者的，也可以是服务消费者的
- subscribed 属性。订阅 URL 的监听器集合。key：消费者的 URL ，例如消费者的 URL
- notified 属性。被通知的 URL 集合。
	- 从数据上，和 properties 比较相似。有两点差异：1）数据格式上，notified 根据分类做了聚合；2）不从 file 中读取，都是从注册中心读取的数据。
- registryUrl 属性。注册中心 URL
- destroyed 属性。是否销毁
- 构造方法
	- 调用 #loadProperties() 方法，加载本地磁盘缓存文件到内存缓存。

#### 13.2.2.2 register && unregister ####
- register(url)
	- 从实现上，我们可以看出，并未向注册中心发起注册，仅仅是添加到 registered 中，进行状态的维护。实际上，真正的实现在 FailbackRegistry 类中。
- unregister(url)
	- 和 #register(url) 的处理方式相同。

#### 13.2.2.3 subscribe && unsubscribe ####
- subscribe(url, listener)
	- 和 #register(url) 的处理方式相同。
- unsubscribe(url, listener)
	- 和 #register(url) 的处理方式相同。

#### 13.2.2.4 notify ####
notify(url, listener, urls) 方法，通知监听器，URL 变化结果。这里我们有两点要注意下：
- 第一，向注册中心发起订阅后，会获取到全量数据，此时会被调用 #notify(...) 方法，即 Registry 获取到了全量数据。
- 第二，每次注册中心发生变更时，会调用 #notify(...) 方法，虽然变化是增量，调用这个方法的调用方，已经进行处理，传入的 urls 依然是全量的。

基本流程如下：
1. 将 urls 按照 url.parameter.category 分类，添加到集合 result 中。
	1. 这里有一点要注意，每次传入的 urls 的“全量”，指的是至少要是一个分类的全量，而不一定是全部数据。
2. 获得消费者 URL 对应的在 notified 中的数据。
3. 按照分类，循环处理通知的 URL 变化结果（全量数据）。
	1. 将 result 覆盖到 notified 中。这里又有一点需要注意，当某个分类的数据为空时，会依然有 urls 。其中 urls[0].protocol = empty ，通过这样的方式，处理所有服务提供者为空的情况。
	2. 调用 #saveProperties(url) 方法，保存到文件。
	3. 调用 NotifyListener#notify(urls) 方法，通知监听器处理。例如，有新的服务提供者启动时，被通知，创建新的 Invoker 对象。

#### 13.2.2.5 recover ####
在注册中心断开，重连成功，调用 #recover() 方法，进行恢复注册和订阅。

#### 13.2.2.6 destroy ####
在 JVM 关闭时，调用 #destroy() 方法，进行取消注册和订阅。


### 13.2.3 FailbackRegistry ###
com.alibaba.dubbo.registry.support.FailbackRegistry ，实现 AbstractRegistry 抽象类，支持失败重试的 Registry 抽象类。
AbstractRegistry 进行的注册、订阅等操作，更多的是修改状态，而无和注册中心实际的操作。FailbackRegistry 在 AbstractRegistry 的基础上，实现了和注册中心实际的操作，并且支持失败重试的特性。

#### 13.2.3.1 属性 ####
- retryExecutor 属性。定时任务执行器
- retryFuture 属性。失败重试定时器，定时检查是否有请求失败，如有，无限次重试
	- 在构造方法中创建该定时器，在其 #run() 方法中，会调用 #retry() 方法，进行重试。
- failedXXX 属性。一系列失败的集
- destroyed 属性。是否销毁

函数：和AbstractRegistry差不多

## 13.3 NotifyListener ##

com.alibaba.dubbo.registry.NotifyListener ，通知监听器。当收到服务变更通知时触发

当收到服务变更通知时触发。
通知需处理契约：
1. 总是以服务接口和数据类型为维度全量通知，即不会通知一个服务的同类型的部分数据，用户不需要对比上一次通知结果。
2. 订阅时的第一次通知，必须是一个服务的所有类型数据的全量通知。
3. 中途变更时，允许不同类型的数据分开通知，比如：providers, consumers, routers, overrides，允许只通知其中一种类型，但该类型的数据必须是全量的，不是增量的。
4. 如果一种类型的数据为空，需通知一个empty协议并带category参数的标识性URL数据。
5. 通知者(即注册中心实现)需保证通知的顺序，比如：单线程推送，队列串行化，带版本对比。

## 13.4 ProviderConsumerRegTable ##
com.alibaba.dubbo.registry.support.ProviderConsumerRegTable ，服务提供者和消费者注册表，存储 JVM 进程内自己的服务提供者和消费者的 Invoker 。
该信息用于 Dubbo QOS 使用，例如将 JVM 进程中，自己的服务提供者下线，又或者查询自己的服务提供者和消费者列表。

//  todo qos再添加

------

# 14 注册中心（二）之 Zookeeper #

zookeeper内结构图：

![](/picture/dubbo-registry-zookeeper.png)

流程说明：

- 服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址
- 服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址
- 监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。

在图中，我们可以看到 Zookeeper 的节点层级，自上而下是：

- Root 层：根目录，可通过 <dubbo:registry group="dubbo" /> 的 "group" 设置 Zookeeper 的根节点，缺省使用 "dubbo" 。
- Service 层：服务接口全名。
- Type 层：分类。目前除了我们在图中看到的 "providers"( 服务提供者列表 ) "consumers"( 服务消费者列表 ) 外，还有 "routes"( 路由规则列表 ) 和 "configurations"( 配置规则列表 )。
- URL 层：URL ，根据不同 Type 目录，下面可以是服务提供者 URL 、服务消费者 URL 、路由规则 URL 、配置规则 URL 。
- 实际上 URL 上带有 "category" 参数，已经能判断每个 URL 的分类，但是 Zookeeper 是基于节点目录订阅的，所以增加了 Type 层。

实际上，服务消费者启动后，不仅仅订阅了 "providers" 分类，也订阅了 "routes" "configurations" 分类。

## 14.1 ZookeeperRegistryFactory ##

com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistryFactory ，实现 AbstractRegistryFactory 抽象类，Zookeeper Registry 工厂。

## 14.2 ZookeeperRegistry ##
com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry ，实现 FailbackRegistry 抽象类，Zookeeper Registry 。

### 14.2.1 属性 + 构造方法 ###

- root 属性，Zookeeper 根节点，即首图的 Root 层。
- anyServices 属性，Service 接口接口全名集合。该属性适可用于监控中心，订阅整个 Service 层。因为，Service 层是动态的，可以有不断有新的 Service 服务发布（注意，不是服务实例）。在 #doSubscribe(url, notifyListener) 方法中，会更容易理解。
- zkListeners 属性，监听器集合，建立 NotifyListener 和 ChildListener 的映射关系。
- zkClient 属性，Zookeeper 客户端。

构造方法:
1. 设置注册中心的 URL 。主要为注册到zookeeper上的信息。类似：zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&interface=com.alibaba.dubbo.registry.RegistryService&logger=jcl&pid=1892&qos.port=22222&timestamp=1545204610284
2. 设置在 Zookeeper 的根节点，缺省使用 DEFAULT_ROOT 。
3. 调用 ZookeeperTransporter#connect(url) 方法，基于 Dubbo SPI Adaptive 机制，根据 url 参数，加载对应的 ZookeeperTransporter 实现类，创建对应的 ZookeeperClient 实现类的对应。
4. 添加 StateListener 对象到 ZookeeperClient 对象中。该监听器，在重连时，调用 #recover() 方法，进行恢复逻辑，重新发起注册和订阅。

### 14.2.2 doRegister ###

基本流程如下：

1. 调用 #toUrlPath(url) 方法，获得 URL 的路径。
2. url.parameters.dynamic ，是否动态数据。若为 false ，该数据为持久数据，当注册方退出时，数据依然保存在注册中心。
3. 调用 ZookeeperClient#create(url, ephemeral) 方法，创建 URL 节点，即我们在首图看到的 URL 层。

------

# 15 注册中心（三）之 Redis #

基于 Redis 实现的注册中心结构图：

![](/picture/dubbo-registry-redis.png)












123