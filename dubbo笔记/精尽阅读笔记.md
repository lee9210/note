# 项目结构 #
### dubbo-common ###
**公共逻辑模块**：提供工具类和通用模型。

### dubbo-remoting ###
**远程通信模块**：提供通用的客户端和服务端的通讯功能。
- dubbo-remoting-zookeeper ，相当于 Zookeeper Client ，和 Zookeeper Server 通信。
- dubbo-remoting-api ， 定义了 Dubbo Client 和 Dubbo Server 的接口。
	- dubbo-remoting-grizzly ，基于 Grizzly 实现。
	- dubbo-remoting-http ，基于 Jetty 或 Tomcat 实现。
	- dubbo-remoting-mina ，基于 Mina 实现。
	- dubbo-remoting-netty ，基于 Netty 3 实现。
	- dubbo-remoting-netty4 ，基于 Netty 4 实现。
	- dubbo-remoting-p2p ，P2P 服务器。注册中心 dubbo-registry-multicast 项目的使用该项目。

### dubbo-rpc ###
**远程调用模块**：抽象各种协议，以及动态代理，只包含一对一的调用，**不关心集群的管理**。

- dubbo-rpc-api ，抽象各种协议以及动态代理，实现了一对一的调用。
- 其他模块，实现 dubbo-rpc-api ，提供对应的协议实现。

### dubbo-cluster ###
**集群模块**：将多个服务提供方伪装为一个提供方，包括：负载均衡, 集群容错，路由，分组聚合等。集群的地址列表可以是静态配置的，也可以是由注册中心下发。

集群模块包含多个功能：容错、目录、路由、配置、负载均衡、合并结果。

整体流程用图表示为：

![avatar](/picture/main-flow.png)

### dubbo-registry ###
**注册中心模块**：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。

- dubbo-registry-api ，抽象注册中心的注册与发现接口。
- 其他模块，实现 dubbo-registry-api ，提供对应的注册中心实现。

### dubbo-monitor ###
**监控模块**：统计服务调用次数，调用时间的，调用链跟踪的服务。

### dubbo-config ###
**配置模块**：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。

- dubbo-config-api ，实现了 API 配置 和 属性配置 功能。
- dubbo-config-spring ，实现了 XML 配置 和 注解配置 功能。

### dubbo-container ###
**容器模块**：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。

- dubbo-container-api ：定义了 com.alibaba.dubbo.container.Container 接口，并提供 加载所有容器启动的 Main 类。
	- dubbo-container-spring ，提供了 com.alibaba.dubbo.container.spring.SpringContainer 。
	- dubbo-container-log4j ，提供了 com.alibaba.dubbo.container.log4j.Log4jContainer 。
	- dubbo-container-logback ，提供了 com.alibaba.dubbo.container.logback.LogbackContainer 。

### dubbo-filter ###
**过滤器模块**：提供了内置的过滤器。
- dubbo-filter-cache ，缓存过滤器。
- dubbo-filter-validation ，参数验证过滤器。

### dubbo-plugin ###
**插件模块**：提供了内置的插件。

### hessian-lite ###
Dubbo 对 Hessian 2 的 序列化 部分的精简、改进、BugFix 。

### dubbo-demo ###
快速启动示例。

### dubbo-test ###
测试模块。

- dubbo-test-benchmark ，性能测试。
- dubbo-test-compatibility ，兼容性测试。
- dubbo-test-example ，使用示例。


# API 配置（一）之应用 #
**应用配置**：指的是配置应用的名称，应用地址等等。
包括的标签有：
````
<dubbo:application>//应用信息配置。对应的配置类：com.alibaba.dubbo.config.ApplicationConfig
<dubbo:registry>//注册中心配置。对应的配置类： com.alibaba.dubbo.config.RegistryConfig。同时如果有多个不同的注册中心，可以声明多个 <dubbo:registry> 标签，并在 <dubbo:service> 或 <dubbo:reference> 的 registry 属性指定使用的注册中心。
<dubbo:module>//模块信息配置。对应的配置类 com.alibaba.dubbo.config.ModuleConfig
<dubbo:monitor>//监控中心配置。对应的配置类： com.alibaba.dubbo.config.MonitorConfig
<dubbo:argument>方法参数配置。对应的配置类： com.alibaba.dubbo.config.ArgumentConfig。该标签为 <dubbo:method> 的子标签，用于方法参数的特征描述，比如：
	<dubbo:method name="findXxx" timeout="3000" retries="2">
	    <dubbo:argument index="0" callback="true" />
	</dubbo:method>
````
所有配置项分为三大类：
- 服务发现：表示该配置项用于服务的注册与发现，目的是让消费方找到提供方。
- 服务治理：表示该配置项用于治理服务间的关系，或为开发测试提供便利条件。
- 性能调优：表示该配置项用于调优性能，不同的选项对性能会产生影响。

所有配置最终都将转换为 Dubbo URL 表示，并由服务提供方生成，经注册中心传递给消费方，各属性对应 URL 的参数

配置关系图：
![avatar](/picture/schema-config-relation.png)


## Config ##

例子：消费者初始化代码
````
// 当前应用配置
ApplicationConfig application = new ApplicationConfig();
application.setName("yyy");

// 连接注册中心配置
RegistryConfig registry = new RegistryConfig();
registry.setAddress("10.20.130.230:9090");
registry.setUsername("aaa");
registry.setPassword("bbb");

// 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接

// 引用远程服务
ReferenceConfig<XxxService> reference = new ReferenceConfig<XxxService>(); // 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏
reference.setApplication(application);
reference.setRegistry(registry); // 多个注册中心可以用setRegistries()
reference.setInterface(XxxService.class);
reference.setVersion("1.0.0");

// 和本地bean一样使用xxxService
XxxService xxxService = reference.get(); // 注意：此代理对象内部封装了所有通讯细节，对象较重，请缓存复用
````

### AbstractConfig ###
AbstractConfig 主要提供配置解析与校验相关的工具方法。

appendParameters(parameters, config, prefix) 方法，将配置对象的属性，添加到参数集合。
- arameters ，参数集合。实际上，该集合会用于 URL.parameters 。
- onfig ，配置对象。
- refix ，属性前缀。用于配置项添加到 parameters 中时的前缀。

### URL ###
格式：protocol://username:password@host:port/path?key=value&key=value
例如：
````
dubbo://192.168.3.17:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&default.delay=-1&default.retries=0&default.service.filter=demoFilter&delay=-1&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=19031&side=provider&timestamp=1519651641799
````
appendAttributes(parameters, config, prefix) 方法，将 @Parameter(attribute = true) 配置对象的属性，添加到参数集合。
appendProperties(config) 方法，读取环境变量和 properties 配置到配置对象
appendAnnotation(annotationClass, annotation) 方法，读取注解配置到配置对象


### @Parameter ###
Parameter 参数注解，用于 Dubbo URL 的 parameters 拼接。

# API 配置（二）之服务提供者 #
包括 provider-config 和 sub-config 部分。
包括的标签有
````
<dubbo:protocol>//服务提供者协议配置。对应的配置类： com.alibaba.dubbo.config.ProtocolConfig。同时，如果需要支持多协议，可以声明多个 <dubbo:protocol> 标签，并在 <dubbo:service> 中通过 protocol 属性指定使用的协议。
<dubbo:method>//方法级配置。对应的配置类： com.alibaba.dubbo.config.MethodConfig。同时该标签为 <dubbo:service> 或 <dubbo:reference> 的子标签，用于控制到方法级。
<dubbo:method>
<dubbo:service>//服务提供者暴露服务配置。对应的配置类：com.alibaba.dubbo.config.ServiceConfig
<dubbo:provider>//服务提供者缺省值配置。对应的配置类： com.alibaba.dubbo.config.ProviderConfig。同时该标签为 <dubbo:service> 和 <dubbo:protocol> 标签的缺省值设置。
````
## ServiceConfig ##

暴露服务的方法是：ServiceConfig#export()。该方法主要做了如下几件事情：
1. 进一步初始化 ServiceConfig 对象。
2. 校验 ServiceConfig 对象的配置项。
3. 使用 ServiceConfig 对象，生成 Dubbo URL 对象数组。
4. 使用 Dubbo URL 对象，暴露服务。

### export() ###

执行步骤
1. 当 export 或 delay 未配置时，从 ProviderConfig 对象读取。
2. 当配置不需要暴露服务( export = false )时，直接返回。
3. 当配置延迟暴露( delay > 0 )时，使用 delayExportExecutor 延迟调度，调用 #doExport() 方法。
	1. 因为spring暴露服务不需要bean初始化全部完成，所以当暴露之后，有可能请求会进来，会导致服务不可用。
4. 立即暴露，调用 #doExport() 方法。

### doExport() ###
完成暴露服务前检查，并调用暴露url方法。大致过程如下

1. 检查是否可以暴露。若可以，标记已经暴露( exported = true )。
2. 校验接口名 interfaceName 非空。（校验暴露的interface类型的service是否为空）
3. 调用 #checkDefault() 方法，读取属性配置( 环境变量 + properties 属性 )到 ProviderConfig 对象。
4. 从 ProviderConfig 对象中，读取 application、module、registries、monitor、protocols 对象。（若没有配置这些对象，从provider中读取数据）
5. 从 ModuleConfig 对象中，读取 registries、monitor 对象。
6. 从 ApplicationConfig 对象中，读取 registries、monitor 对象。
7. 泛化接口的实现。（若配置了需要实现泛化接口，则需要实现，否则实现普通接口）
8. 普通接口的实现。
	1. 根据 interfaceName ，获得对应的接口类，并赋值给 interfaceClass。
	2. 调用 #checkInterfaceAndMethods(interfaceClass, methods) 方法，检查接口和方法。
	3. 调用 #checkRef() 方法，校验指向的 Service 对象。（校验指向的service是否为空）
	4. 标记 generic 为非泛化实现。
9. 处理服务接口客户端本地代理( local )相关。实际目前已经废弃，此处主要用于兼容，使用 stub 属性
10. 处理服务接口客户端本地代理( stub 属性，参见 AbstractInterfaceConfig#setLocal(local) )相关。
11. 调用 #checkApplication() 方法，校验 ApplicationConfig 配置。
12. 调用 #checkRegistry() 方法，校验 RegistryConfig 配置。
13. 调用 #checkProtocol() 方法，校验 ProtocolConfig 配置数组。
14. 调用 #appendProperties(config) 方法，读取属性配置( 环境变量 + properties 属性 )到 ServiceConfig 对象（自己）。
15. 调用 #checkStubAndMock(interfaceClass) 方法，校验 Stub 和 Mock 相关的配置。
16. 服务路径 path 为空时，缺省为接口名。
17. 调用 #doExportUrls() 方法，暴露服务。
18. 等待 qos

### doExportUrls() ###













123`