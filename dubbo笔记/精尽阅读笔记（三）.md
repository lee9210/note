# 47 NIO 服务器（三）之 Telnet 层 #
dubbo-remoting-api 模块， telnet 包，Telnet 命令。

Dubbo 支持通过 telnet 命令，用来服务治理。其中，clear exit help log status 通用指令，通过 telnet 包实现。而其它几个指令，需要不同协议( Protocol )自己实现。目前，仅有 Dubbo Protocol 实现了自定义指令。

主要分成三种不通的类。

- TelnetCodec ：负责编解码 Telnet 命令与结果。
- TelnetHandlerAdapter ：负责接收来自 HeaderExchangeHandler 的 telnet 命令，分发给对应的 TelnetHandler 实现类，进行处理，返回命令结果。
- XXXTelnetHandler ：处理对应的 telnet 命令，返回结果。

流程如下图：

![](/picture/dubbo-telnet-flow.png)

## 47.1 TelnetCodec ##

com.alibaba.dubbo.remoting.telnet.codec.TelnetCodec ，实现 TransportCodec 类，Telnet 命令编解码器。

**解码**

//  todo dubbo运维了解

----

# 48 NIO 服务器（四）之 Exchange 层 #
dubbo-remoting-api 模块， exchange 包，信息交换层。

exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer。

在一次 RPC 调用，每个请求( Request )，是关注对应的响应( Response )。那么 transport 层 提供的网络传输 功能，是无法满足 RPC 的诉求的。因此，exchange 层，在其 Message 之上，构造了Request-Response 的模型。

实现上，也非常简单，将 Message 分成 Request 和 Response 两种类型，并增加编号属性，将 Request 和 Response 能够一一映射。

实际上，RPC 调用，会有更多特性的需求：1）异步处理返回结果；2）内置事件；3）等等。因此，Request 和 Response 上会有类似编号的系统字段。

一条消息，我们分成两段：
- 协议头( Header ) ： 系统字段，例如编号等。
- 内容( Body ) ：具体请求的参数和响应的结果等。

dubbo心跳检测：
dubbo心跳时间heartbeat默认是60s，超过heartbeat时间没有收到消息，就发送心跳消息(provider，consumer一样),如果连着3次(heartbeatTimeout为heartbeat*3)没有收到心跳响应，provider会关闭channel，而consumer会进行重连;不论是provider还是consumer的心跳检测都是通过启动定时任务的方式实现；

## 48.1 ExchangeChannel ##

com.alibaba.dubbo.remoting.exchange.ExchangeChannel ，继承 Channel 接口，信息交换通道接口

### 48.1.1 HeaderExchangeChannel ###

com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeChannel ，实现 ExchangeChannel 接口，基于消息头部( Header )的信息交换通道实现类。

#### 48.1.1.1 构造方法 ####

````
private static final String CHANNEL_KEY = HeaderExchangeChannel.class.getName() + ".CHANNEL";

/** 通道。HeaderExchangeChannel 是传入 channel 属性的装饰器，每个实现的方法，都会调用 channel 。 */
private final Channel channel;
/** 是否关闭 */
private volatile boolean closed = false;

HeaderExchangeChannel(Channel channel) {
    if (channel == null) {
        throw new IllegalArgumentException("channel == null");
    }
    this.channel = channel;
}
````

getOrAddChannel(Channel) 静态方法，创建 HeaderExchangeChannel 对象。

基本流程如下：
1. 传入的 ch 属性，实际就是 HeaderExchangeChanel.channel 属性。
2. 通过 ch.attribute 的 CHANNEL_KEY 键值，保证有且仅有为 ch 属性，创建唯一的 HeaderExchangeChannel 对象。
3. 要求已连接。

removeChannelIfDisconnected(ch) 静态方法，移除 HeaderExchangeChannel 对象。

#### 48.1.1.2 发送请求 ####

基本流程如下：

1. 若已经关闭，不再允许发起新的请求。
2. 第 6 至 10 行：创建 Request 对象。其中，twoWay = true 需要响应；data = request 具体数据。
3. 创建 DefaultFuture 对象。
4. 调用 Channel#send(req) 方法，发送请求。
5. 发生 RemotingException 异常，调用 DefaultFuture#cancel() 方法，取消。
6. 返回 DefaultFuture 对象。从代码的形式上来说，有点类似线程池提交任务，返回 Future 对象。

#### 48.1.1.3 优雅关闭 ####

基本流程如下：
1. 标记 closed = true ，避免发起新的请求。
2. 调用 DefaultFuture#hasFuture(channel) 方法，判断已发起的已经是否已经都响应了。若否，等待完成或超时。
3. 关闭通道。

## 48.2 ExchangeClient ##
com.alibaba.dubbo.remoting.exchange.ExchangeClient ，实现 Client ，ExchangeChannel 接口，信息交换客户端接口。

### 48.2.1 HeaderExchangeClient ###
com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeClient ，实现 ExchangeClient 接口，基于消息头部( Header )的信息交换客户端实现类。

**构造方法**

````
/** 定时器线程池 */
private static final ScheduledThreadPoolExecutor scheduled = new ScheduledThreadPoolExecutor(2, new NamedThreadFactory("dubbo-remoting-client-heartbeat", true));
/** 客户端 */
private final Client client;
/** 信息交换通道 */
private final ExchangeChannel channel;
// heartbeat timer
/** 心跳定时器 */
private ScheduledFuture<?> heartbeatTimer;
/** 是否心跳 */
private int heartbeat;
// heartbeat timeout (ms), default value is 0 , won't execute a heartbeat.
/** 心跳间隔，单位：毫秒 */
private int heartbeatTimeout;
public HeaderExchangeClient(Client client, boolean needHeartbeat) {
    if (client == null) {
        throw new IllegalArgumentException("client == null");
    }
    this.client = client;
    // 创建 HeaderExchangeChannel 对象
    this.channel = new HeaderExchangeChannel(client);
    // 读取心跳相关配置
    String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);
    this.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != null && dubbo.startsWith("1.0.") ? Constants.DEFAULT_HEARTBEAT : 0);
    this.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * 3);
    if (heartbeatTimeout < heartbeat * 2) { // 避免间隔太短
        throw new IllegalStateException("heartbeatTimeout < heartbeatInterval * 2");
    }
    // 发起心跳定时器
    if (needHeartbeat) {
        startHeatbeatTimer();
    }
}
````

基本流程如下;
1. 使用传入的 client 属性，创建 HeaderExchangeChannel 对象。
2. 读取心跳相关配置。默认，开启心跳功能。
	1. 心跳间隔，对于长连接，当物理层断开时，比如拔网线，TCP的FIN消息来不及发送，对方收不到断开事件，此时需要心跳来帮助检查连接是否已断开
3.  调用 #startHeatbeatTimer() 方法，发起心跳定时器。

## 48.3 ExchangeServer ##

com.alibaba.dubbo.remoting.exchange.ExchangeServer ，继承 Server 接口，信息交换服务器接口

### 48.3.1 HeaderExchangeServer ###
com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeServer ，实现 ExchangeServer 接口，基于消息头部( Header )的信息交换服务器实现类。

- 代码实现上，和 HeaderExchangeChannel + HeaderExchangeClient 的综合。

#### 48.3.1.1 构造方法 ####
代码实现上，和 HeaderExchangeClient 的类似。

````
/** 定时器线程池 */
private final ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(1, new NamedThreadFactory("dubbo-remoting-server-heartbeat", true));
/** 服务器 */
private final Server server;
// heartbeat timer
/** 心跳定时器 */
private ScheduledFuture<?> heatbeatTimer;
/** 是否心跳 */
// heartbeat timeout (ms), default value is 0 , won't execute a heartbeat.
private int heartbeat;
/** 心跳间隔，单位：毫秒 */
private int heartbeatTimeout;
/** 是否关闭 */
private AtomicBoolean closed = new AtomicBoolean(false);

public HeaderExchangeServer(Server server) {
    if (server == null) {
        throw new IllegalArgumentException("server == null");
    }
    // 读取心跳相关配置
    this.server = server;
    this.heartbeat = server.getUrl().getParameter(Constants.HEARTBEAT_KEY, 0);
    this.heartbeatTimeout = server.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * 3);
    if (heartbeatTimeout < heartbeat * 2) {
        throw new IllegalStateException("heartbeatTimeout < heartbeatInterval * 2");
    }
    // 发起心跳定时器
    startHeatbeatTimer();
}
````

#### 48.3.1.2 优雅关闭 ####
Server 关闭的过程，分成两个阶段：正在关闭和已经关闭。

基本流程如下：
1. 调用 #startClose() 方法，标记正在关闭。
2. 发送 READONLY 事件给所有 Client ，表示 Server 不再接收新的消息，避免不断有新的消息接收到。
	1. 即使 client 处于连接中，但是 Server 处于正在关闭中，也算不可用，不进行发送请求( 消息 )。
3. sendChannelReadOnlyEvent() 方法，广播客户端，READONLY_EVENT 事件
4. 调用 #oClose() 方法，关闭心跳定时器。
5. 真正关闭服务器。

### 48.3.2 ExchangeServerDelegate ###
com.alibaba.dubbo.remoting.exchange.support.ExchangeServerDelegate ，实现 ExchangeServer 接口，信息交换服务器装饰者。在每个实现的方法里，直接调用被装饰的 server 属性的方法。

## 48.4 请求/响应模型 ##
### 48.4.1 Request ###
com.alibaba.dubbo.remoting.exchange.Request ，请求

内置两种事件：

- HEARTBEAT_EVENT ：心跳。因为心跳比较常用，所以在事件上时候了 null 。
- READONLY_EVENT ：只读。

属性：
- mId 属性：编号。使用 INVOKE_ID 属性生成，JVM 进程内唯一。
- mTwoWay 属性，标记请求是否响应( Response )，默认需要。
- mBroken 属性，是否异常的请求。在消息解析的时候，会出现。
- mData 属性，请求具体数据。

### 48.4.2 Response ###
com.alibaba.dubbo.remoting.exchange.Response ，响应。

- mId 属性，响应编号，和请求编号一致。
- mStatus 属性，状态。有多种状态：[状态码] (dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/Response.java)。
- mEvent 属性，是否事件。和 Request 内置了一样的事件，但是 READONLY_EVENT 并未使用。因为目前，只读事件，无需响应。
- mErrorMsg 属性，错误消息。
- mResult 属性，结果。

### 48.4.3 ResponseFuture ###
com.alibaba.dubbo.remoting.exchange.ResponseFuture ，响应 Future 接口。
和 java.util.concurrent.Future 很类似。

#### 48.4.3.1 DefaultFuture ####
com.alibaba.dubbo.remoting.exchange.support.DefaultFuture ，实现 ResponseFuture 接口，默认响应 Future 实现类。同时，它也是所有 DefaultFuture 的管理容器。

**构造方法**

````
/**
 * 通道集合
 * key：请求编号
 */
private static final Map<Long, Channel> CHANNELS = new ConcurrentHashMap<Long, Channel>();
/**
 * Future 集合
 * key：请求编号
 */
private static final Map<Long, DefaultFuture> FUTURES = new ConcurrentHashMap<Long, DefaultFuture>();

/** 请求编号 */
// invoke id.
private final long id;
/** 通道 */
private final Channel channel;
/** 请求 */
private final Request request;
/** 超时 */
private final int timeout;
/** 创建开始时间 */
private final long start = System.currentTimeMillis();
/** 发送请求时间 */
private volatile long sent;
/** 响应 */
private volatile Response response;
/** 回调 */
private volatile ResponseCallback callback;

public DefaultFuture(Channel channel, Request request, int timeout) {
    this.channel = channel;
    this.request = request;
    this.id = request.getId();
    this.timeout = timeout > 0 ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
    // put into waiting map.
    FUTURES.put(id, this);
    CHANNELS.put(id, channel);
}
````

CHANNELS 静态属性，通道集合。通过 #hasFuture(channel) 方法，判断通道是否有未结束的请求。
FUTURES 静态属性，Future 集合。
sent 属性，发送请求时间。因为在目前 Netty Mina 等通信框架中，发送请求一般是异步的，因此在 ChannelHandler#sent(channel, message) 方法中，调用 DefaultFuture#sent(channel, request) 静态方法，
callback 属性，回调，适用于异步请求。通过 #setCallback(callback) 方法设置。

**获得值**
get(timeout)函数：
基本流程如下：
1. 调用 #isDone() 方法，判断是否完成。若未完成，基于 Lock + Condition 的方式，实现等待。而等待的唤醒，通过 ChannelHandler#received(channel, message) 方法，接收到请求时执行 DefaultFuture#received(channel, response) 方法。
	1. 获得开始时间。注意，此处使用的不是 start 属性。后面我们会看到，#get(...) 方法中，使用的是重新获取开始时间；后台扫描调用超时任务，使用的是 start 属性。也就是说，#get(timeout) 方法的 timeout 参数，指的是从当前时刻开始的等待超时时间。当然，这不影响最终的结果，最终 Response 是什么，由是 ChannelHandler#received(channel, message) 还是后台扫描调用超时任务，谁先调用 DefaultFuture#received(channel, response) 方法决定。
	2. 获得锁。
	3. 等待完成或超时。
	4. 释放锁。
	5. 若未完成，抛出超时异常 TimeoutException 。
		1. TimeoutException.phase 的阶段，由 sent > 0 来决定，即 Client 是否发送给 Server 。
		2. getTimeoutMessage(scan) 方法，获得超时异常提示信息。
2. 调用 #returnFromResponse() 方法，返回响应( Response )

**响应结果**

````
public static void received(Channel channel, Response response) {
    try {
        // 移除 FUTURES
        DefaultFuture future = FUTURES.remove(response.getId());
        // 接收结果
        if (future != null) {
            future.doReceived(response);
        } else {
            logger.warn("The timeout response finally returned at " + (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date())) + ", response " + response + (channel == null ? "" : ", channel: " + channel.getLocalAddress() + " -> " + channel.getRemoteAddress()));
        }
    // 移除 CHANNELS
    } finally {
        CHANNELS.remove(response.getId());
    }
}
````

基本流程如下：
1. 移除 FUTURES 
2. 调用 DefaultFuture#doReceived(response) 方法，响应结果。
	1. 获得锁。
	2. 设置响应 response 。
	3. 调用 Condition#signal() 方法，通知，唤醒 DefaultFuture#get(..) 方法的等待。
	4. 释放锁。
	5. 调用 #invokeCallback(callback) 方法，执行回调方法。
3. 超时情况，打印告警日志。
4. 移除 CHANNELS 。

**设置回调**
基本流程如下：
1. 若已完成，调用 #invokeCallback(callback) 方法，执行回调方法。
2. 获得锁。
3. 若未完成，设置回调 callback 属性，等在 #doReceived(response) 方法中再回调。
4. 标记已完成。调用 #invokeCallback(callback) 方法，执行回调方法。
5. 释放锁。

**调用回调**
和 #returnFromResponse() 方法，情况一致。

基本流程如下：
1. 正常返回，调用 ResponseCallback#done(result) 方法，处理结果。
2. 超时异常，调用 ResponseCallback#caught(e) 方法，处理 TimeoutException 异常。
3. 其他异常，调用 ResponseCallback#caught(e)` 方法，处理 RuntimeException 异常。

**后台扫描调用超时任务**
基本流程如下：
1. 已完成，跳过
2. 超时
3. 创建超时 Response
4. 响应结果

#### 48.4.3.2 SimpleFuture**** ####
com.alibaba.dubbo.remoting.exchange.support.SimpleFuture ，实现 ResponseFuture 接口，简单的 Future 实现。

### 48.4.4 MultiMessage ###
com.alibaba.dubbo.remoting.exchange.support.MultiMessage ，实现 Iterable 接口，多消息的封装。

## 48.5 Handler ##
### 48.5.1 HeartbeatHandler ###
com.alibaba.dubbo.remoting.exchange.support.header.HeartbeatHandler ，实现 AbstractChannelHandlerDelegate 抽象类，心跳处理器，处理心跳事件。

#### 48.5.1.1 HeartBeatTask ####
com.alibaba.dubbo.remoting.exchange.support.header.HeartBeatTask ，实现 Runnable 接口，心跳任务。

channelProvider 属性，用于查询获得需要心跳的通道数组。

**执行任务**
基本流程如下：

1. 【任务一】最后读或写的时间，任一超过心跳间隔 heartbeat ，发送心跳。
2. 【任务二】最后读的时间，超过心跳超时时间 heartbeatTimeout ，分成两种情况：
3. 客户端侧，重连连接服务端。
4. 服务端侧，关闭客户端连接。

### 48.5.2 HeaderExchangeHandler ###
com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler，实现 ChannelHandlerDelegate 接口，基于消息头部( Header )的信息交换处理器实现类。

**接收消息**
基本流程如下：
1. 设置最后的读时间。
2. 创建 ExchangeChannel 对象。
3. 处理请求( Request)
	1. 调用 #handlerEvent(channel, request) 方法，处理事件请求。
	2. 调用 #handleRequest(channel, request) 方法，处理普通请求（需要响应），并将响应写回请求方。
	3. 调用 ChannelHandler#received(channel, message) 方法，处理普通请求（无需响应）。
4. 调用 #handleResponse(channel, message) 方法，处理响应。
5. 处理 String 的情况
	1. 客户端侧，不支持 String 的情况。
	2. 服务端侧，目前仅有 telnet 命令的情况，调用 TelnetHandler#telnet(channel, message) 方法，获得 telnet 命令的结果，并响应给 telnet 客户端。
6. 剩余的情况，调用 ChannelHandler#received(channel, message) 方法，处理。
7. 移除 ExchangeChannel 对象，若已断开。

**发生异常**
当发生 ExecutionException 异常，返回异常响应( Response )。目前会发生 ExecutionException 的情况，并且符合提交

### 48.5.3 ExchangeHandler ###
com.alibaba.dubbo.remoting.exchange.ExchangeHandler ，继承 ChannelHandler 和 TelnetHandler 接口，信息交换处理器接口。
- 注意，返回的是请求结果。正如我们在上文看到的，将请求结果，设置到 Response.mResult 属性中。

#### 48.5.3.1 ExchangeHandlerAdapter ####

com.alibaba.dubbo.remoting.exchange.support.ExchangeHandlerAdapter ，实现 ExchangeHandler 接口，继承 TelnetHandlerAdapter 抽象类，信息交换处理器适配器抽象类。

在 DubboProtocol 、ThirftProtocol 中，都会基于 ExchangeHandlerAdapter 实现自己的处理器，处理请求，返回结果。

### 48.5.4 Replier ###
//  todo 目前仅用于p2p

## 48.6 Exchanger ##
com.alibaba.dubbo.remoting.exchange.Exchanger ，数据交换者接口。
Exchanger 和 Transporter 类似。

- SPI(HeaderExchanger.NAME) 注解，Dubbo SPI 拓展点，默认为 "header"，即 HeaderExchanger 。
- Adaptive({Constants.EXCHANGER_KEY}) 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Server 实现，使用 URL.exchanger 属性。
- Adaptive({Constants.EXCHANGER_KEY}) 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Client 实现，使用 URL.exchanger 属性。

### 48.6.1 HeaderExchanger ###
com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchanger ，实现 Exchanger 接口，基于消息头部( Header )的信息交换者实现类。

### 48.6.2 Exchangers ###
Exchangers 和 Transporters 类似。
com.alibaba.dubbo.remoting.Transporters ，数据交换者门面类

## 48.7 ExchangeCodec ##
com.alibaba.dubbo.remoting.exchange.codec.ExchangeCodec ，继承 TelnetCodec 类，信息交换编解码器。

![](/picture/dubbo-nio-exchanger-codec.png)


- 基于消息长度的方式，做每条消息的粘包拆包处理。
- Header 部分，协议头，通过 Codec 编解码。Bits 位如下：
	- [0, 15]：Magic Number
	- [16, 20]：Serialization 编号。
	- [21]：event 是否为事件。
	- [22]：twoWay 是否需要响应。
	- [23]：是请求还是响应。
	- [24 - 31]：status 状态。
	- [32 - 95]：id 编号，Long 型。
	- [96 - 127]：Body 的长度。通过该长度，读取 Body 。
- Body 部分，协议体，通过 Serialization 序列化/反序列化。

**属性**

````
// header length.
protected static final int HEADER_LENGTH = 16;
// magic header.
protected static final short MAGIC = (short) 0xdabb;
protected static final byte MAGIC_HIGH = Bytes.short2bytes(MAGIC)[0];
protected static final byte MAGIC_LOW = Bytes.short2bytes(MAGIC)[1];
// message flag.
protected static final byte FLAG_REQUEST = (byte) 0x80; // 128
protected static final byte FLAG_TWOWAY = (byte) 0x40; // 64
protected static final byte FLAG_EVENT = (byte) 0x20; // 32
protected static final int SERIALIZATION_MASK = 0x1f; // 31
````
HEADER_LENGTH 静态属性，Header 总长度，16 Bytes = 128 Bits 。

**编码**
基本流程如下：
1. 调用 #encodeRequest(channel, buffer, request) 方法，编码请求。
2. 调用 #encodeResponse(channel, buffer, response) 方法，编码响应。
3. 调用 TelnetCodec#encode(channel, buffer, msg) 方法，编码 Telnet 命令的结果。

encodeRequest(channel, buffer, request) 方法基本流程：
1. Header 部分，先写入 header 数组，再写入 Buffer 中。
2. Body 部分，使用 Serialization 序列化 Request.data ，写入到 Buffer 中。
3. 调用 #checkPayload(channel, len) 方法，校验 Body 内容的长度

- 为什么 Buffer 先写入了 Body ，再写入 Header 呢？因为 Header 中，里面 [96 - 127] 的 Body 长度，需要序列化后才得到。

**解码**

基本流程如下：
1. 读取 header 数组。注意，这里的 Math.min(readable, HEADER_LENGTH) ，优先考虑解析 Dubbo 协议。
2. 调用 #decode(channel, buffer, readable, header) 方法，解码。
3. 基于消息长度的方式，拆包。
4. 调用 #decodeBody(channel, is, header) 方法，解析 Header + Body ，根据情况，返回 Request 或 Reponse 。🙂 逻辑上，是 #encodeRequest(...) 和 #encodeResponse(...) 方法的反向，
5. skip 未读完的流

----

# 49 NIO 服务器（五）之 Buffer 层 #

dubbo-remoting-api 模块， buffer 包，Buffer 层。
Buffer 在 NIO 框架中，扮演非常重要的角色，基本每个库都提供了自己的 Buffer 实现，例如：
- Java NIO 的 java.nio.ByteBuffer
- Mina 的 org.apache.mina.core.buffer.IoBuffer
- Netty4 的 io.netty.buffer.ByteBuf

在 dubbo-remoting-api 的 buffer 包中，一方面定义了 ChannelBuffer 和 ChannelBufferFactory 的接口，同时提供了多种默认的实现。

## 49.1 ChannelBuffer ##
com.alibaba.dubbo.remoting.buffer.ChannelBuffer ，实现 Comparable 接口，通道 Buffer 接口。

ChannelBuffer 在接口方法的定义上，主要参考了 Netty 的 ByteBuf 进行设计，所以接口和注释基本一致

独有的接口方法 #factory() 方法，用于逻辑中，需要创建 ChannelBuffer 的情况。

### 49.1.1 AbstractChannelBuffer ###
com.alibaba.dubbo.remoting.buffer.AbstractChannelBuffer ，实现 ChannelBuffer 接口，通道 Buffer 抽象类。

**构造方法**
````
/** 读取位置 */
private int readerIndex;
/** 写入位置 */
private int writerIndex;
/** 标记的读取位置 */
private int markedReaderIndex;
/** 标记的写入位置 */
private int markedWriterIndex;
````

**实现方法**
在 AbstractChannelBuffer 实现的方法，都是重载的方法，真正实质的方法，需要子类来实现。


### 49.1.2 ByteBufferBackedChannelBuffer ###
com.alibaba.dubbo.remoting.buffer.ByteBufferBackedChannelBuffer ，实现 AbstractChannelBuffer 抽象类，基于 java.nio.ByteBuffer 的 Buffer 实现类。

**构造方法**
````
/**
 * buffer
 * java.nio.ByteBuffer
 */
private final ByteBuffer buffer;
/** 容量 */
private final int capacity;

public ByteBufferBackedChannelBuffer(ByteBuffer buffer) {
    if (buffer == null) {
        throw new NullPointerException("buffer");
    }
    // buffer
    this.buffer = buffer.slice();
    // 容量
    capacity = buffer.remaining();
    // 设置 `writerIndex`
    writerIndex(capacity);
}

public ByteBufferBackedChannelBuffer(ByteBufferBackedChannelBuffer buffer) {
    // buffer
    this.buffer = buffer.buffer;
    // 容量
    capacity = buffer.capacity;
    // 设置 `writerIndex` `readerIndex`
    setIndex(buffer.readerIndex(), buffer.writerIndex());
}
````
**工厂**
对应的工厂是 DirectChannelBufferFactory 或 HeapChannelBufferFactory 。

### 49.1.3 HeapChannelBuffer ###
com.alibaba.dubbo.remoting.buffer.HeapChannelBuffer ，实现 AbstractChannelBuffer 抽象类，基于字节数组的 Buffer 实现类。

**工厂**
对应的工厂是 HeapChannelBufferFactory 。

### 49.1.4 DynamicChannelBuffer ###
com.alibaba.dubbo.remoting.buffer.DynamicChannelBuffer ，实现 AbstractChannelBuffer 抽象类，基于动态的 Buffer 实现类。或者说，基于传入的 ChannelBufferFactory 的 Buffer 实现类。

## 49.2 ChannelBuffers ##
com.alibaba.dubbo.remoting.buffer.ChannelBuffers ，Buffer 工具类，提供创建、比较 ChannelBuffer 等公用方法。

## 49.3 ChannelBufferFactory ##
com.alibaba.dubbo.remoting.buffer.ChannelBufferFactory ，通道 Buffer 工厂接口。

### 49.3.1 DirectChannelBufferFactory ###
com.alibaba.dubbo.remoting.buffer.DirectChannelBufferFactory ，实现 ChannelBufferFactory 接口，创建 DirectChannelBuffer 的工厂。

### HeapChannelBufferFactory ###
com.alibaba.dubbo.remoting.buffer.HeapChannelBufferFactory ，实现 ChannelBufferFactory 接口，创建 HeapChannelBufferFactory 的工厂。

## 49.4 IO ##
实际 IO 操作，是基于 InputStream 和 OutputStream 

### 49.4.1 ChannelBufferInputStream ###
com.alibaba.dubbo.remoting.buffer.ChannelBufferInputStream ，实现 InputStream 接口

### 49.4.2 ChannelBufferOutputStream ###
com.alibaba.dubbo.remoting.buffer.ChannelBufferOutputStream ，实现 OutputStream 接口






-----